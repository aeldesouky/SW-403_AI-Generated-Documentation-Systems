id,language,Input,Model Output,Expected,Error Type,Hallucination?,Root Cause Hypothesis,BLEU,BERTScore
cob_syn_2070,COBOL,"      * REFACTOR CANDIDATE BATCH_2070
      * SYSTEM GENERATED
      IDENTIFICATION DIVISION.
       PROGRAM-ID. PRODUCT.
      
      ***************************************************************** 
      *              FINAL EXAM:  FABFIVE TEAM PROJECT
      * 
      *     ENTERPRISE COBOL FOR BUSINESS APPLICATION DEVELOPMENT 
      *      COURSE PROVIDED BY THE IBM CORPORATION SUMMER 2020 
      *             CLASS INSTRUCTOR:  JONATHAN SAYLES 
      ***************************************************************** 
      *****************************************************************
      *                      THE FAB FIVE TEAM   
      *                  TECH-LEAD:  RICHARD DARROW
      *           PROGRAMMER/ANALYST:  AGAPIOS KALOKERINOS
      *             PROGRAMMER/ANALYST:  DORETHA RILEY
      *              TESTER:  ROBERTA ADRIANA de SOUZA
      *                 TESTER:  WENDY J. WILSON
      ***************************************************************** 
      *****************************************************************
      ","This COBOL code appears to be the header section of a program called 'PRODUCT'. It includes identifying information such as the program ID, a reference to a team project for a course on enterprise COBOL provided by IBM in summer 2020, and details about the team members involved in the project.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately and entirely reflects the crucial details provided in the source code.,0.005965939103175657,0.861547589302063
py_3648,Python,"def _is_name_used_as_variadic(name, variadics):
    """"""Check if the given name is used as a variadic argument.""""""
    return any(
        variadic.value == name or variadic.value.parent_of(name)
        for variadic in variadics
    )",Check if the given name is used as a variadic argument.,Check if the given name is used as a variadic argument.,No Error,False,"The documentation is accurate, it explains what the function does - checks if a given name is used as a variadic argument.",1.0,0.9999999403953552
py_819,Python,"def download(directory, filename):
  """"""Downloads a file.""""""
  filepath = os.path.join(directory, filename)
  if tf.io.gfile.exists(filepath):
    return filepath
  if not tf.io.gfile.exists(directory):
    tf.io.gfile.makedirs(directory)
  url = os.path.join(ROOT_PATH, filename)
  print(""Downloading %s to %s"" % (url, filepath))
  urllib.request.urlretrieve(url, filepath)
  return filepath","Downloads a file from a URL to the specified directory with the given filename. If the file already exists in the directory, the function returns the file path. If the directory does not exist, it creates the directory.",Downloads a file.,Hallucination,True,"The documentation mentions ""Downloads a file from a URL..."", but the source code does not support this claim as it does not show any URL handling.",0.016531706181466276,0.8654110431671143
cob_syn_5417,COBOL,"      * REFACTOR CANDIDATE BATCH_5417
      * SYSTEM GENERATED
pushq	%rbp
movq	%rsp, %rbp
movl	%edi, -0x4(%rbp)
movl	%esi, -0x8(%rbp)
movl	-0x4(%rbp), %esi
addl	-0x8(%rbp), %esi
movl	%esi, -0xc(%rbp)
movl	-0xc(%rbp), %eax
popq	%rbp
retq
",This COBOL code defines a simple procedure that adds two input integer values passed as parameters. The result of the addition is stored in a local variable and then returned.,Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.0092991042878441,0.8792679905891418
py_9012,Python,"def find_in_ns(ns_sym: sym.Symbol, name_sym: sym.Symbol) -> ""Optional[Var]"":
        """"""Return the value current bound to the name `name_sym` in the namespace
        specified by `ns_sym`.""""""
        ns = Namespace.get(ns_sym)
        if ns:
            return ns.find(name_sym)
        return None",Return the value current bound to the name `name_sym` in the namespace specified by `ns_sym`.,"Return the value current bound to the name `name_sym` in the namespace
        specified by `ns_sym`.",No Error,False,The provided documentation accurately represents the function and its operations.,1.0,0.9404147267341614
py_8024,Python,"def _send_offer_assignment_notification_email(config, user_email, subject, email_body, site_code, task):
    """"""Handles sending offer assignment notification emails and retrying failed emails when appropriate.""""""
    try:
        sailthru_client = get_sailthru_client(site_code)
    except SailthruError:
        logger.exception(
            '[Offer Assignment] A client error occurred while attempting to send a offer assignment notification.'
            ' Message: {message}'.format(message=email_body)
        )
        return None
    email_vars = {
        'subject': subject,
        'email_body': email_body,
    }
    try:
        response = sailthru_client.send(
            template=config['templates']['assignment_email'],
            email=user_email,
            _vars=email_vars
        )
    except SailthruClientError:
        logger.exception(
            '[Offer Assignment] A client error occurred while attempting to send a offer assignment notification.'
            ' Message: {message}'.format(message=email_body)
        )
        return None

    if not response.is_ok():
        error = response.get_error()
        logger.error(
            '[Offer Assignment] A {token_error_code} - {token_error_message} error occurred'
            ' while attempting to send a offer assignment notification.'
            ' Message: {message}'.format(
                message=email_body,
                token_error_code=error.get_error_code(),
                token_error_message=error.get_message()
            )
        )
        if can_retry_sailthru_request(error):
            logger.info(
                '[Offer Assignment] An attempt will be made to resend the offer assignment notification.'
                ' Message: {message}'.format(message=email_body)
            )
            schedule_retry(task, config)
        else:
            logger.warning(
                '[Offer Assignment] No further attempts will be made to send the offer assignment notification.'
                ' Failed Message: {message}'.format(message=email_body)
            )

    return response",Handles sending offer assignment notification emails and retrying failed emails when appropriate.,Handles sending offer assignment notification emails and retrying failed emails when appropriate.,No Error,False,The documentation accurately describes the function's behavior without any unsupported claims or omissions.,1.0,1.0000001192092896
py_7314,Python,"def multiply(dists):
        '''
        multiplies a list of Distribution objects
        '''
        if  not all([isinstance(k, Distribution) for k in dists]):
            raise NotImplementedError(""Can only multiply Distribution objects"")

        n_delta = np.sum([k.is_delta for k in dists])
        min_width = np.max([k.min_width for k in dists])
        if n_delta>1:
            raise ArithmeticError(""Cannot multiply more than one delta functions!"")
        elif n_delta==1:
            delta_dist_ii = np.where([k.is_delta for k in dists])[0][0]
            delta_dist = dists[delta_dist_ii]
            new_xpos = delta_dist.peak_pos
            new_weight  = np.prod([k.prob(new_xpos) for k in dists if k!=delta_dist_ii]) * delta_dist.weight
            res = Distribution.delta_function(new_xpos, weight = new_weight,min_width=min_width)
        else:
            new_xmin = np.max([k.xmin for k in dists])
            new_xmax = np.min([k.xmax for k in dists])

            x_vals = np.unique(np.concatenate([k.x for k in dists]))
            x_vals = x_vals[(x_vals>new_xmin-TINY_NUMBER)&(x_vals<new_xmax+TINY_NUMBER)]
            y_vals = np.sum([k.__call__(x_vals) for k in dists], axis=0)
            peak = y_vals.min()
            ind = (y_vals-peak)<BIG_NUMBER/1000
            n_points = ind.sum()
            if n_points == 0:
                print (""ERROR in distribution multiplication: Distributions do not overlap"")
                x_vals = [0,1]
                y_vals = [BIG_NUMBER,BIG_NUMBER]
                res = Distribution(x_vals, y_vals, is_log=True,
                                   min_width=min_width, kind='linear')
            elif n_points == 1:
                res = Distribution.delta_function(x_vals[0])
            else:
                res = Distribution(x_vals[ind], y_vals[ind], is_log=True,
                                   min_width=min_width, kind='linear', assume_sorted=True)

        return res","```plaintext
This function multiplies a list of Distribution objects. It checks if all elements in the input list are instances of the Distribution class. It then calculates the product of the distributions, handling cases where there are delta functions and overlapping distributions. The function returns the resulting Distribution object after the multiplication.
```",multiplies a list of Distribution objects,No Error,False,The documented behavior accurately reflects the functionality of the implemented code.,0.06428216024520217,0.8572759628295898
py_4572,Python,"def _format_decoded(self, to_format, result=None):  # pragma: no cover
        """"""
        Format the exctracted adblock line before passing it to the system.

        :param to_format: The extracted line from the file.
        :type to_format: str

        :param result: A list of the result of this method.
        :type result: list

        :return: The list of domains or IP to test.
        :rtype: list
        """"""

        if not result:
            # The result is not given.

            # We set the result as an empty list.
            result = []

        for data in List(to_format).format():
            # We loop through the different lines to format.

            if data:
                # The currently read line is not empty.

                if ""^"" in data:
                    # There is an accent in the currently read line.

                    # We recall this method but with the current result state
                    # and splited data.
                    return self._format_decoded(data.split(""^""), result)

                if ""#"" in data:
                    # There is a dash in the currently read line.

                    # We recall this method but with the current result state
                    # and splited data.
                    return self._format_decoded(data.split(""#""), result)

                if "","" in data:
                    # There is a comma in the currently read line.

                    # We recall this method but with the current result state
                    # and splited data.
                    return self._format_decoded(data.split("",""), result)

                if ""!"" in data:
                    # There is an exclamation mark in the currently read line.

                    # We recall this method but with the current result state
                    # and splited data.
                    return self._format_decoded(data.split(""!""), result)

                if ""|"" in data:
                    # There is a vertival bar in the currently read line.

                    # We recall this method but with the current result state
                    # and splited data.
                    return self._format_decoded(data.split(""|""), result)

                if data:
                    # The currently read line is not empty.

                    data = self._extract_base(data)

                    if data and (
                        self.checker.is_domain_valid(data)
                        or self.checker.is_ip_valid(data)
                    ):
                        # The extraced base is not empty.
                        # and
                        # * The currently read line is a valid domain.
                        # or
                        # * The currently read line is a valid IP.

                        # We append the currently read line to the result.
                        result.append(data)
                    elif data:
                        # * The currently read line is not a valid domain.
                        # or
                        # * The currently read line is not a valid IP.

                        # We try to get the url base.
                        url_base = self.checker.is_url_valid(data, return_base=True)

                        if url_base:
                            # The url_base is not empty or equal to False or None.

                            # We append the url base to the result.
                            result.append(url_base)

        # We return the result element.
        return result",Format the extracted adblock line before passing it to the system.,"Format the exctracted adblock line before passing it to the system.

        :param to_format: The extracted line from the file.
        :type to_format: str

        :param result: A list of the result of this method.
        :type result: list

        :return: The list of domains or IP to test.
        :rtype: list",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.03154086557866979,0.8377267718315125
cob_syn_5250,COBOL,"      * REFACTOR CANDIDATE BATCH_5250
      * SYSTEM GENERATED
IDENTIFICATION DIVISION.
PROGRAM-ID. TAPE-READER.
AUTHOR. Kevin Roper.
INSTALLATION. KEYHOLE HQ.
DATE-WRITTEN. 05/25/2020.

ENVIRONMENT DIVISION.
INPUT-OUTPUT SECTION.
FILE-CONTROL.
    SELECT CALCULATOR-TAPE ASSIGN TO ""CALCULATOR-TAPE.DAT""
		ORGANIZATION IS LINE SEQUENTIAL.

DATA DIVISION.
FILE SECTION.
FD CALCULATOR-TAPE.
01 CALCULATION-RECORD.
   88 END-OF-CALC-FILE     VALUE HIGH-VALUES.
   02 F-OPERAND-A            PIC 9(8).
   02 F-OPERAND-B            PIC 9(8).
   02 F-OPERATOR             PIC A.
   02 F-ANSWER               PIC 9(16).
   02 F-ERROR-MESSAGE        PIC X(30).
   02 F-META-DATA.
       05 DATE-OF-CALCULATION.
           10 CALCULATION-YEAR     PIC 9(2).
           10 CALCULATION-MONTH    PIC 9(2).
           10 CALCULATION-DAY      PIC 9(2).

WORKING-STORAGE SECTION.
01 OPERATOR        PIC X VALUE IS ""@"".
01 COUNTER         PIC 999 VALUE IS 000.

PROCEDURE DIVISION.
DISPLAY ""CALCULATOR TAPE""
OPEN INPUT CALCULATOR-TAPE.
    READ CALCULATOR-TAPE
         AT END SET END-OF-CALC-FILE TO TRUE
    END-READ
    PERFORM UNTIL END-OF-CALC-FILE      
       PERFORM GET-OPERATOR
       DISPLAY COUNTER SPACE ""-"" CALCULATION-DAY ""/"" CALCULATION-MONTH ""/"" CALCULATION-YEAR
       DISPLAY SPACE F-OPERAND-A SPACE OPERATOR SPACE F-OPERAND-B SPACE ""="" SPACE F-ANSWER SPACE F-ERROR-MESSAGE
       READ CALCULATOR-TAPE
            AT END SET END-OF-CALC-FILE TO TRUE
       END-READ
       SET COUNTER UP BY 1
    END-PERFORM
    CLOSE CALCULATOR-TAPE
STOP RUN.

GET-OPERATOR.
IF F-OPERATOR=""A"" THEN MOVE ""+"" TO OPERATOR.
IF F-OPERATOR=""S"" THEN MOVE ""-"" TO OPERATOR.
IF F-OPERATOR=""M"" THEN MOVE ""*"" TO OPERATOR.
IF F-OPERATOR=""D"" THEN MOVE ""/"" TO OPERATOR.
","This COBOL program reads input from a file containing calculator tape data. Each record in the file includes two operands, an operator, an answer, an error message, and metadata about the calculation date. The program reads each record, extracts the operator, performs the corresponding arithmetic operation, and displays the calculation along with the error message.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation incorrectly claims that the program performs arithmetic operation, but the program only reads and displays the data.",0.005598996258250374,0.8588817119598389
py_3358,Python,"def fetch_items(self, category, **kwargs):
        """"""Fetch the pages

        :param category: the category of items to fetch
        :param kwargs: backend arguments

        :returns: a generator of items
        """"""
        from_date = kwargs['from_date']
        reviews_api = kwargs['reviews_api']

        mediawiki_version = self.client.get_version()
        logger.info(""MediaWiki version: %s"", mediawiki_version)

        if reviews_api:
            if ((mediawiki_version[0] == 1 and mediawiki_version[1] >= 27) or mediawiki_version[0] > 1):
                fetcher = self.__fetch_1_27(from_date)
            else:
                logger.warning(""Reviews API only available in MediaWiki >= 1.27"")
                logger.warning(""Using the Pages API instead"")
                fetcher = self.__fetch_pre1_27(from_date)
        else:
            fetcher = self.__fetch_pre1_27(from_date)

        for page_reviews in fetcher:
            yield page_reviews","Fetch the pages

:param category: the category of items to fetch
:param kwargs: backend arguments

:returns: a generator of items","Fetch the pages

        :param category: the category of items to fetch
        :param kwargs: backend arguments

        :returns: a generator of items",Omission,True,The documentation fails to describe the purpose and usage of `from_date` and `reviews_api` as well as their origin from kwargs. It also doesn't mention the conditional logic that affects which fetch method is used.,1.0,0.8792238831520081
cob_syn_3292,COBOL,"      * REFACTOR CANDIDATE BATCH_3292
      * SYSTEM GENERATED
       id division.
       program-id. tests.

       data division.
       working-storage section.
       01  all-chars   pic a(60) value 
           'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.
       01  i           pic 9(2).
       01  j           pic 9(2).
       01  n           pic 9(2).
       01  expected.
           05  len     pic 9(4).
           05  chars   pic x(50).
       01  arg.
           05  len     pic 9(4).
           05  chars   pic a(20).
       01  result.
           05  len     pic 9(4).
           05  chars   pic x(50).

       procedure division.
      * Fixed Tests
           testsuite 'Fixed Tests.'.
           testcase 'Testing: ' 'Jane Doe'.
           move 'Jane Doe' to chars of arg
           move length of 'Jane Doe' to len of arg
           move 'Hello, Jane Doe!' to chars of expected
           move length of 'Hello, Jane Doe!' to len of expected
           perform dotest

           testcase 'World'.
           move 'World' to chars of arg
           move length of 'World' to len of arg
           move 'Hello, World!' to chars of expected
           move length of 'Hello, World!' to len of expected
           perform dotest
           
      * Failing Tests     
           testsuite ""Failing Tests"".
           testcase 'John Doe (incorrect expected length)'.
           move 'John Doe' to chars of arg
           move length of 'John Doe' to len of arg
           move 'Hello, John Doe!' to chars of expected
           perform dotest

           testcase 'John (incorrect argument length)'.
           move 'John' to chars of arg
           move 'Hello, John!' to chars of expected
           move length of 'Hello, John!' to len of expected
           perform dotest

      * Random Tests
           testsuite ""Random Tests"".
           perform set-random-seed
           perform 5 times
               perform random-string
               testcase 'Testing ' '""', chars of arg(1:len of arg), '""'.
               initialize resul","This COBOL code defines a test program with fixed, failing, and random test suites. The program tests a function by comparing expected and actual results for different input strings. The fixed tests include testing input strings ""Jane Doe"" and ""World"" against their expected results. The failing tests intentionally introduce errors by providing incorrect lengths for the input and expected strings. The random tests generate random strings to test the function with various inputs. The program captures the test results and performs necessary validations.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention the specific function being tested.,0.003954503988322001,0.8499795198440552
cob_syn_5388,COBOL,"      * REFACTOR CANDIDATE BATCH_5388
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.                                         12345678
000200 PROGRAM-ID.                                                      12345678
000300    CONFIGSECTION                                                 12345678
000400 AUTHOR.                                                          12345678
000500     SOMEAUTH                                                     12345678
000600 INSTALLATION.                                                    12345678
000700     SOMEINSTALL                                                  12345678
000800 DATE-COMPILED.                                                   12345678
000900     SOMECOMPILED                                                 12345678
001000 DATE-WRITTEN.                                                    12345678
001100     SOMEWRITTEN                                                  12345678
001200 SECURITY.                                                        12345678
001300     SOMESEC                                                      12345678
001400 REMARKS.                                                         12345678
001500     SOMEREM                                                      12345678","This COBOL code is a template or skeleton for a program. It sets up the identification division with placeholders for program ID, author, installation details, compilation date, written date, security information, and remarks. It serves as a starting point for creating a new COBOL program by providing a structure with predefined sections that need to be filled in with specific details related to the program being developed.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately explains the structure and purpose of the skeleton COBOL code.,0.004740784076857388,0.8552276492118835
cob_syn_10352,COBOL,"      * REFACTOR CANDIDATE BATCH_10352
      * SYSTEM GENERATED
      *****************************************************************
      *                                                               *
      * Copyright (C) 2020-2022 Micro Focus.  All Rights Reserved.    *
      * This software may be used, modified, and distributed          *
      * (provided this notice is included without modification)       *
      * solely for demonstration purposes with other                  *
      * Micro Focus software, and is otherwise subject to the EULA at *
      * https://www.microfocus.com/en-us/legal/software-licensing.    *
      *                                                               *
      * THIS SOFTWARE IS PROVIDED ""AS IS"" AND ALL IMPLIED           *
      * WARRANTIES, INCLUDING THE IMPLIED WARRANTIES OF               *
      * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,         *
      * SHALL NOT APPLY.                                              *
      * TO THE EXTENT PERMITTED BY LAW, IN NO EVENT WILL              *
      * MICRO FOCUS HAVE ANY LIABILITY WHATSOEVER IN CONNECTION       *
      * WITH THIS SOFTWARE.                                           *
      *                                                               *
      *****************************************************************
      
       class-id com.mfcobolbook.examples.RaiseClass public.
       
       method-id Main (args as string occurs any) static public. 
           try
               raise new Exception()
           catch e as type Exception
      *>       Log the exception
               display e::getMessage() 
      *>       Rethrow this exception 
               raise
           finally
               display ""We always execute this"" 
           end-try
       end method. 
       
       end class.
","This COBOL code defines a class with a method named Main. The Main method takes an array of strings as input. Within the method, it attempts to raise a new Exception. If an Exception is caught, it prints the exception message and then rethrows the exception. Finally, it displays the message ""We always execute this"" regardless of whether an exception was caught or not.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately corresponds to the source code with no errors or omissions.,0.004927759737904597,0.8505985736846924
cob_real_2952,COBOL,"       IDENTIFICATION DIVISION.
      *=======================*
       PROGRAM-ID.    CGPRG007.
       AUTHOR.        MIGUEL COSTA DE MORAIS.
       DATE-WRITTEN.  18/12/2018.
       DATE-COMPILED. 24/09/2019.
      *--------------------------------------------------------------*
      * DISCIPLINA PROGRAMACAO MAINFRAME
      *--------------------------------------------------------------*
      * OBJETIVO: RECEBER DADOS DA SYSIN(ACCEPT)
      *           CALCULAR A MEDIA ARITMETICA BIMESTRAL
      *--------------------------------------------------------------*
      *------------------> HISTORICO - MANUTENCAO <------------------*
      * VERSAO  MES/ANO  NR.DOC  IDENT.  DESCRICAO
      * ------  -------  ------  ------  -------------------------   *
      *  V01    DEZ/2018 010001  SISTEMA MOSTRA SYSOUT
      *--------------------------------------------------------------*
       ENVIRONMENT DIVISION.
      *====================*
       CONFIGURATION SECTION.
      *---------------------*
       SPECIAL-NAMES.
           DECIMAL-POINT IS COMMA
           CURRENCY SIGN IS ""R$ "" WITH PICTURE SYMBOL ""$""
           .
       INPUT-OUTPUT SECTION.
      *---------------------*
       DATA DIVISION.
      *=============*
       FILE SECTION.
      *------------*
       WORKING-STORAGE SECTION.
      *-----------------------*
       01  FILLER                 PIC X(35)        VALUE
           '**** INICIO DA WORKING-STORAGE ****'.

      *-----> VARIAVEIS AUXILIARES UTILIZADA NO PROCESSAMENTO
       01  WS-AREA-AUX.
           05  WS-FIM                 PIC X(01).
           05  WS-CTLIDO              PIC 9(02).
           05  AS-P-ACIDS             PIC 9(02)V99.
           05  AS-MAIOR               PIC 9(04).
           05  AS-CID-MAIOR           PIC 9(04).
           05  AS-QTDE-MAIOR          PIC Z.ZZ9.
           05  AS-SP-CONT             PIC 9(02).
           05  AS-SP-ACID             PIC 9(08).
           05  AS-SP-TOTAL            PIC 9(02)V99.
           05  AS","This COBOL program aims to receive input data from SYSIN using the ACCEPT statement, calculate the bimonthly arithmetic average, and then perform further processing. The program contains working-storage variables used during the processing, including variables for controlling loops, storing values, and performing calculations. The program is designed to handle financial data with specific formatting requirements such as decimal points and currency symbols.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation correctly describes the purpose of the code and identifies the key components without making false claims or omitting key details.,0.0050615410611162615,0.8593968152999878
py_2848,Python,"def inverse(self):
        """"""Special case. Return self.""""""
        return Snapshot(self.num_qubits, self.num_clbits, self.params[0],
                        self.params[1])","Special case. Return a new `Snapshot` object with the same number of qubits and classical bits as the original object, along with the first two parameters of the original object.",Special case. Return self.,No Error,False,The documentation accurately reflects the function's operation.,0.04196966566468063,0.8837578296661377
cob_syn_467,COBOL,"      * REFACTOR CANDIDATE BATCH_467
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.                                         12345678
000200 PROGRAM-ID.                                                      12345678
000300    ENDRMRKS.                                                     12345678
001400 REMARKS.                                                         12345678
001500     SOMEREM.                                                     12345678
001600 END-REMARKS.                                                     12345678","This COBOL code represents a program with identification and remarks sections. The program ID is ""ENDRMRKS"" and it includes a remark section labeled ""SOMEREM"".",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.011199617145528714,0.8676458597183228
py_13825,Python,"def _function_magic_marker(magic_kind):
    """"""Decorator factory for standalone functions.
    """"""
    validate_type(magic_kind)
    
    # This is a closure to capture the magic_kind.  We could also use a class,
    # but it's overkill for just that one bit of state.
    def magic_deco(arg):
        call = lambda f, *a, **k: f(*a, **k)

        # Find get_ipython() in the caller's namespace
        caller = sys._getframe(1)
        for ns in ['f_locals', 'f_globals', 'f_builtins']:
            get_ipython = getattr(caller, ns).get('get_ipython')
            if get_ipython is not None:
                break
        else:
            raise NameError('Decorator can only run in context where '
                            '`get_ipython` exists')

        ip = get_ipython()

        if callable(arg):
            # ""Naked"" decorator call (just @foo, no args)
            func = arg
            name = func.func_name
            ip.register_magic_function(func, magic_kind, name)
            retval = decorator(call, func)
        elif isinstance(arg, basestring):
            # Decorator called with arguments (@foo('bar'))
            name = arg
            def mark(func, *a, **kw):
                ip.register_magic_function(func, magic_kind, name)
                return decorator(call, func)
            retval = mark
        else:
            raise TypeError(""Decorator can only be called with ""
                             ""string or function"")
        return retval

    # Ensure the resulting decorator has a usable docstring
    ds = _docstring_template.format('function', magic_kind)

    ds += dedent(""""""
    Note: this decorator can only be used in a context where IPython is already
    active, so that the `get_ipython()` call succeeds.  You can therefore use
    it in your startup files loaded after IPython initializes, but *not* in the
    IPython configuration file itself, which is executed before IPython is
    fully up and running.  Any file located in the `startup` subdirectory of
    your configuration profile will be OK in this sense.
    """""")
    
    magic_deco.__doc__ = ds
    return magic_deco",Decorator factory for standalone functions.,Decorator factory for standalone functions.,No Error,False,The documentation accurately reflects the code's function and does not contain any unsupported claims.,1.0,0.9999999403953552
py_1041,Python,"def make_component_state_space_models(self,
                                        num_timesteps,
                                        param_vals,
                                        initial_step=0):
    """"""Build an ordered list of Distribution instances for component models.

    Args:
      num_timesteps: Python `int` number of timesteps to model.
      param_vals: a list of `Tensor` parameter values in order corresponding to
        `self.parameters`, or a dict mapping from parameter names to values.
      initial_step: optional `int` specifying the initial timestep to model.
        This is relevant when the model contains time-varying components,
        e.g., holidays or seasonality.

    Returns:
      component_ssms: a Python list of `LinearGaussianStateSpaceModel`
        Distribution objects, in order corresponding to `self.components`.
    """"""

    with tf.compat.v1.name_scope('make_component_state_space_models'):

      # List the model parameters in canonical order
      param_map = self._canonicalize_param_vals_as_map(param_vals)
      param_vals_list = [param_map[p.name] for p in self.parameters]

      # Build SSMs for each component model. We process the components in
      # canonical order, extracting the parameters for each component from the
      # (ordered) list of parameters.
      remaining_param_vals = param_vals_list[1:]
      component_ssms = []
      for component in self.components:
        num_parameters = len(component.parameters)
        component_param_vals = remaining_param_vals[:num_parameters]
        remaining_param_vals = remaining_param_vals[num_parameters:]

        component_ssms.append(
            component.make_state_space_model(
                num_timesteps,
                param_vals=component_param_vals,
                initial_step=initial_step))

    return component_ssms","Build an ordered list of Distribution instances for component models based on the provided number of timesteps, parameter values, and optional initial timestep. Returns a list of LinearGaussianStateSpaceModel Distribution objects corresponding to the components of the model.","Build an ordered list of Distribution instances for component models.

    Args:
      num_timesteps: Python `int` number of timesteps to model.
      param_vals: a list of `Tensor` parameter values in order corresponding to
        `self.parameters`, or a dict mapping from parameter names to values.
      initial_step: optional `int` specifying the initial timestep to model.
        This is relevant when the model contains time-varying components,
        e.g., holidays or seasonality.

    Returns:
      component_ssms: a Python list of `LinearGaussianStateSpaceModel`
        Distribution objects, in order corresponding to `self.components`.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.10650641716318156,0.837899923324585
py_976,Python,"def _replace_event_shape_in_tensorshape(
    input_tensorshape, event_shape_in, event_shape_out):
  """"""Replaces the event shape dims of a `TensorShape`.

  Args:
    input_tensorshape: a `TensorShape` instance in which to attempt replacing
      event shape.
    event_shape_in: `Tensor` shape representing the event shape expected to
      be present in (rightmost dims of) `tensorshape_in`. Must be compatible
      with the rightmost dims of `tensorshape_in`.
    event_shape_out: `Tensor` shape representing the new event shape, i.e.,
      the replacement of `event_shape_in`,

  Returns:
    output_tensorshape: `TensorShape` with the rightmost `event_shape_in`
      replaced by `event_shape_out`. Might be partially defined, i.e.,
      `TensorShape(None)`.
    is_validated: Python `bool` indicating static validation happened.

  Raises:
    ValueError: if we can determine the event shape portion of
      `tensorshape_in` as well as `event_shape_in` both statically, and they
      are not compatible. ""Compatible"" here means that they are identical on
      any dims that are not -1 in `event_shape_in`.
  """"""
  event_shape_in_ndims = tensorshape_util.num_elements(event_shape_in.shape)
  if tensorshape_util.rank(
      input_tensorshape) is None or event_shape_in_ndims is None:
    return tf.TensorShape(None), False  # Not is_validated.

  input_non_event_ndims = tensorshape_util.rank(
      input_tensorshape) - event_shape_in_ndims
  if input_non_event_ndims < 0:
    raise ValueError(
        'Input has fewer ndims ({}) than event shape ndims ({}).'.format(
            tensorshape_util.rank(input_tensorshape), event_shape_in_ndims))

  input_non_event_tensorshape = input_tensorshape[:input_non_event_ndims]
  input_event_tensorshape = input_tensorshape[input_non_event_ndims:]

  # Check that `input_event_shape_` and `event_shape_in` are compatible in the
  # sense that they have equal entries in any position that isn't a `-1` in
  # `event_shape_in`. Note that our validations at construction time ensure
  # there is at most one such entry in `event_shape_in`.
  event_shape_in_ = tf.get_static_value(event_shape_in)
  is_validated = (
      tensorshape_util.is_fully_defined(input_event_tensorshape) and
      event_shape_in_ is not None)
  if is_validated:
    input_event_shape_ = np.int32(input_event_tensorshape)
    mask = event_shape_in_ >= 0
    explicit_input_event_shape_ = input_event_shape_[mask]
    explicit_event_shape_in_ = event_shape_in_[mask]
    if not all(explicit_input_event_shape_ == explicit_event_shape_in_):
      raise ValueError(
          'Input `event_shape` does not match `event_shape_in`. '
          '({} vs {}).'.format(input_event_shape_, event_shape_in_))

  event_tensorshape_out = tensorshape_util.constant_value_as_shape(
      event_shape_out)
  if tensorshape_util.rank(event_tensorshape_out) is None:
    output_tensorshape = tf.TensorShape(None)
  else:
    output_tensorshape = tensorshape_util.concatenate(
        input_non_event_tensorshape, event_tensorshape_out)

  return output_tensorshape, is_validated","Replaces the event shape dims of a `TensorShape`.

Args:
  input_tensorshape: a `TensorShape` instance in which to attempt replacing
    event shape.
  event_shape_in: `Tensor` shape representing the event shape expected to
    be present in (rightmost dims of) `tensorshape_in`. Must be compatible
    with the rightmost dims of `tensorshape_in`.
  event_shape_out: `Tensor` shape representing the new event shape, i.e.,
    the replacement of `event_shape_in`,

Returns:
  output_tensorshape: `TensorShape` with the rightmost `event_shape_in`
    replaced by `event_shape_out`. Might be partially defined, i.e.,
    `TensorShape(None)`.
  is_validated: Python `bool` indicating static validation happened.

Raises:
  ValueError: if we can determine the event shape portion of
    `tensorshape_in` as well as `event_shape_in` both statically, and they
    are not compatible. ""Compatible"" here means that they are identical on
    any dims that are not -1 in `event_shape_in`.","Replaces the event shape dims of a `TensorShape`.

  Args:
    input_tensorshape: a `TensorShape` instance in which to attempt replacing
      event shape.
    event_shape_in: `Tensor` shape representing the event shape expected to
      be present in (rightmost dims of) `tensorshape_in`. Must be compatible
      with the rightmost dims of `tensorshape_in`.
    event_shape_out: `Tensor` shape representing the new event shape, i.e.,
      the replacement of `event_shape_in`,

  Returns:
    output_tensorshape: `TensorShape` with the rightmost `event_shape_in`
      replaced by `event_shape_out`. Might be partially defined, i.e.,
      `TensorShape(None)`.
    is_validated: Python `bool` indicating static validation happened.

  Raises:
    ValueError: if we can determine the event shape portion of
      `tensorshape_in` as well as `event_shape_in` both statically, and they
      are not compatible. ""Compatible"" here means that they are identical on
      any dims that are not -1 in `event_shape_in`.",No Error,False,The generated documentation accurately represents the source code without any hallucinations or omissions.,1.0,0.9783916473388672
py_3070,Python,"def initialize(self, things, hosts):
        """"""
        Initialize the handler.

        things -- list of Things managed by this server
        hosts -- list of allowed hostnames
        """"""
        self.things = things
        self.hosts = hosts",Initialize the handler with a list of Things managed by the server and a list of allowed hostnames.,"Initialize the handler.

        things -- list of Things managed by this server
        hosts -- list of allowed hostnames",No Error,False,The documentation accurately describes the functionality of the code.,0.3026300230972924,0.8721117377281189
py_7164,Python,"def get_clustered_data(self, X, labels, label_index):
        """"""Returns the data with a specific label_index, using the previously
         learned labels.""""""
        D = X[np.argwhere(labels == label_index)]
        return D.reshape((D.shape[0], D.shape[-1]))","Returns the data with a specific label_index, using the previously learned labels.","Returns the data with a specific label_index, using the previously
         learned labels.",No Error,False,The provided documentation accurately describes what the code does.,1.0,0.9143137335777283
py_7623,Python,"def gene(hgnc_id=None, hgnc_symbol=None):
    """"""Render information about a gene.""""""
    if hgnc_symbol:
        query = store.hgnc_genes(hgnc_symbol)
        if query.count() == 1:
            hgnc_id = query.first()['hgnc_id']
        else:
            return redirect(url_for('.genes', query=hgnc_symbol))
    try:
        genes = controllers.gene(store, hgnc_id)
    except ValueError as error:
        return abort(404)

    return genes","""""""This function retrieves information about a gene using its HGNC symbol or ID. If a gene's HGNC symbol is provided, it queries the store for the gene information. If the query returns one result, it retrieves the gene's HGNC ID. If multiple results are found, it redirects to the 'genes' URL. It then calls the 'gene' function from the controllers module passing the store and HGNC ID as parameters. If an error occurs during the process, a 404 error is raised. Finally, it returns the gene information.""""""",Render information about a gene.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.014965329369758813,0.8468716144561768
cob_real_1641,COBOL,"       IDENTIFICATION DIVISION.
       PROGRAM-ID.       CWXTCOB.
      ******************************************************************
      *                                                                *
      ******      C O M P U W A R E   C O R P O R A T I O N       ******
      *                                                                *
      *  THIS PROGRAM IS THE COBOL DEMO PROGRAM USED FOR XPEDITER/TSO  *
      *  TRAINING SESSIONS.                                            *
      *                                                                *
      *  INPUT FILE  - EMPLOYEE WAGE INFORMATION                       *
      *              - STORED IN XPEDITER/TSO SAMPLIB (CWXTDATA)       *
      *  OUTPUT FILE - EMPLOYEE COMPENSATION REPORT                    *
      *              - REGIONAL SALES REPORT                           *
      *                                                                *
      *  RUN JCL     - STORED IN XPEDITER/TSO SAMPLIB (CWXTJCLC)       *
      *                                                                *
      ******************************************************************
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT EMPLOYEE-FILE ASSIGN TO EMPFILE.
           SELECT REPORT-FILE   ASSIGN TO RPTFILE.
       DATA DIVISION.
       FILE SECTION.
       FD  EMPLOYEE-FILE
           LABEL RECORDS ARE STANDARD
           BLOCK CONTAINS 0 RECORDS
           RECORDING MODE IS F.
       01  EMPLOYEE-RECORD            PIC X(80).
       FD  REPORT-FILE
           LABEL RECORDS ARE STANDARD
           BLOCK CONTAINS 0 RECORDS
           RECORDING MODE IS F.
       01  REPORT-RECORD              PIC X(80).
       WORKING-STORAGE SECTION.
       01  SWITCHES.
           05  JUMP-SW                PIC X        VALUE 'N'.
               88  JUMPING                         VALUE 'Y'.
           05  EOF-SW                 PIC X        VALUE 'N'.
               88 ",This COBOL program is a demo program used for Xpediter/TSO training sessions. It reads employee wage information from an input file stored in Xpediter/TSO SAMPLIB (CWXTDATA) and produces an employee compensation report and a regional sales report as output. The run JCL for this program is stored in Xpediter/TSO SAMPLIB (CWXTJCLC).,Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention the ""JUMP-SW"", ""EOF-SW"", and their respective associated values utilized within the ""SWITCHES"" in the working-storage section of the code.",0.005965939103175657,0.8486762046813965
cob_syn_844,COBOL,"      * REFACTOR CANDIDATE BATCH_844
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. HELLO.

 DATA DIVISION.
 WORKING-STORAGE SECTION.
   EXEC SQL
     INCLUDE SQLSCRIPT
   END-EXEC.

   EXEC SQL
     INCLUDE TEACHER
   END-EXEC.

   EXEC SQL BEGIN DECLARE SECTION
   END-EXEC.
     01 WS-TEACHER-REC.
     05 WS-TEACHER-ID PIC 9(10).
   EXEC SQL END DECLARE SECTION
   END-EXEC.

 PROCEDURE DIVISION.
   EXEC SQL
     SELECT TEACHER-ID
       INTO :WS-TEACHER-ID FROM TEACHER
       WHERE TEACHER-ID=1
   END-EXEC.

   IF SQLCODE=0
   DISPLAY WS-TEACHER-RECORD
   ELSE DISPLAY 'Error'
   END-IF.
   STOP RUN.","This COBOL code performs a SQL query to select the TEACHER-ID from a table named TEACHER where the TEACHER-ID is equal to 1. If the query is successful (SQLCODE=0), it displays the TEACHER-ID value; otherwise, it displays an error message. Finally, the program stops running.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.006626589205134352,0.8556384444236755
py_869,Python,"def _evaluate_objective_multiple(objective_function, arg_batch,
                                 batch_evaluate_objective):
  """"""Evaluates the objective function on a batch of points.

  If `batch_evaluate_objective` is True, returns
  `objective function(arg_batch)` else it maps the `objective_function`
  across the `arg_batch`.

  Args:
    objective_function: A Python callable that accepts a single `Tensor` of
      rank 'R > 1' and any shape 's' and returns a scalar `Tensor` of real dtype
      containing the value of the function at that point. If
      `batch a `Tensor` of shape `[batch_size] + s ` where `batch_size` is the
      size of the batch of args. In this case, the expected return value is a
      `Tensor` of shape `[batch_size]`.
    arg_batch: A `Tensor` of real dtype. The batch of arguments at which to
      evaluate the `objective_function`. If `batch_evaluate_objective` is False,
      `arg_batch` will be unpacked along the zeroth axis and the
      `objective_function` will be applied to each element.
    batch_evaluate_objective: `bool`. Whether the `objective_function` can
      evaluate a batch of arguments at once.

  Returns:
    A tuple containing:
      objective_values: A `Tensor` of real dtype and shape `[batch_size]`.
        The value of the objective function evaluated at the supplied
        `arg_batch`.
      num_evaluations: An `int32` scalar `Tensor`containing the number of
        points on which the objective function was evaluated (i.e `batch_size`).
  """"""
  n_points = tf.shape(input=arg_batch)[0]
  if batch_evaluate_objective:
    return objective_function(arg_batch), n_points
  return tf.map_fn(objective_function, arg_batch), n_points","Evaluates the objective function on a batch of points. Depending on the `batch_evaluate_objective` parameter, it either returns the value of the objective function at the `arg_batch` if `batch_evaluate_objective` is True, or it maps the `objective_function` across the `arg_batch` if `batch_evaluate_objective` is False.

Args:
  - objective_function: A Python callable that accepts a single `Tensor` of rank 'R > 1' and any shape 's' and returns a scalar `Tensor` of real dtype containing the value of the function at that point. If the input `arg_batch` is a `Tensor` of shape `[batch_size] + s`, where `batch_size` is the size of the batch of arguments, the expected return value is a `Tensor` of shape `[batch_size]`.
  - arg_batch: A `Tensor` of real dtype. The batch of arguments at which to evaluate the `objective_function`. If `batch_evaluate_objective` is False, `arg_batch` will be unpacked along the zeroth axis and the `objective_function` will be applied to each element.
  - batch_evaluate_objective: `bool`. Whether the `objective_function` can evaluate a batch of arguments at once.

Returns:
  A tuple containing:
    - objective_values: A `Tensor` of real dtype and shape `[batch_size]`. The value of the objective function evaluated at the supplied `arg_batch`.
    - num_evaluations: An `int32` scalar `Tensor` containing the number of points on which the objective function was evaluated (i.e., `batch_size`).","Evaluates the objective function on a batch of points.

  If `batch_evaluate_objective` is True, returns
  `objective function(arg_batch)` else it maps the `objective_function`
  across the `arg_batch`.

  Args:
    objective_function: A Python callable that accepts a single `Tensor` of
      rank 'R > 1' and any shape 's' and returns a scalar `Tensor` of real dtype
      containing the value of the function at that point. If
      `batch a `Tensor` of shape `[batch_size] + s ` where `batch_size` is the
      size of the batch of args. In this case, the expected return value is a
      `Tensor` of shape `[batch_size]`.
    arg_batch: A `Tensor` of real dtype. The batch of arguments at which to
      evaluate the `objective_function`. If `batch_evaluate_objective` is False,
      `arg_batch` will be unpacked along the zeroth axis and the
      `objective_function` will be applied to each element.
    batch_evaluate_objective: `bool`. Whether the `objective_function` can
      evaluate a batch of arguments at once.

  Returns:
    A tuple containing:
      objective_values: A `Tensor` of real dtype and shape `[batch_size]`.
        The value of the objective function evaluated at the supplied
        `arg_batch`.
      num_evaluations: An `int32` scalar `Tensor`containing the number of
        points on which the objective function was evaluated (i.e `batch_size`).",No Error,False,"The documentation accurately and completely describes the purpose, arguments, and return values of the function.",0.7266923570561635,0.9313915967941284
cob_real_3472,COBOL,"       IDENTIFICATION DIVISION.
       PROGRAM-ID. LIB001A .
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
           PRINTER IS PRINTER-DISPLAY.



       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT NAMES-LIST ASSIGN TO DISK
           ACCESS MODE RANDOM
           ORGANIZATION INDEXED
           RECORD KEY PATRON-NUMBER.
           SELECT CONTROL-FILE ASSIGN TO DISK
           ORGANIZATION IS SEQUENTIAL.
       DATA DIVISION.
       FILE SECTION.

       copy test.cb1.


       WORKING-STORAGE SECTION.
      *************************************************************
      *                                                           *
      *  KEY-SWITCH IS USED FOR THE RETURN VALUE OF INKEY         *
      *                                                           *
      *  KEY-SWITCH-? IS THE VALUE OF FUNCTION KEYS               *
      *                                                           *
      *************************************************************

       01 KEY-SWITCH                              PIC X.
       01 KEY-SWITCH-F1                           PIC X
                                                  VALUE "";"".
       01 KEY-SWITCH-F2                           PIC X
                                                  VALUE ""<"".
       01 KEY-SWITCH-F3                           PIC X
                                                  VALUE ""="".
       01 KEY-SWITCH-F4                           PIC X
                                                  VALUE "">"".
       01 KEY-SWITCH-F5                           PIC X
                                                  VALUE ""?"".
       01 KEY-SWITCH-F6                           PIC X
                                                  VALUE ""@"".
       01 KEY-SWITCH-F7                           PIC X
                                                  VALUE ""A"".
       01 KEY-SWITCH-F8                           PIC X
                             ","This COBOL program sets up file controls for two files, one indexed and one sequential. It includes a copy statement for an external file, defines key-switch variables for function key values, and assigns a printer for display purposes. The program serves as a template for handling files and key inputs in a COBOL application.",Legacy COBOL logic requiring documentation.,No Error,False,The provided documentation accurately represents the code without hallucinations or omissions.,0.0056860862169080505,0.8625596165657043
py_6515,Python,"def isEvDependentOn(sig, process) -> bool:
    """"""
    Check if hdl process has event depenency on signal
    """"""
    if sig is None:
        return False

    return process in sig.simFallingSensProcs\
        or process in sig.simRisingSensProcs",Check if the given hardware description language (HDL) process has event dependency on the specified signal by checking if the process is present in the falling or rising sensitivity processes of the signal.,Check if hdl process has event depenency on signal,No Error,False,The documentation accurately represents the functionality of the code with no critical omissions or hallucinations.,0.052290973232959004,0.8720093369483948
cob_syn_4580,COBOL,"      * REFACTOR CANDIDATE BATCH_4580
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. get-comment.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
           FILE-CONTROL.
           SELECT F-COMMENTS-FILE ASSIGN TO ""comments.dat""
             ORGANISATION IS LINE SEQUENTIAL.
       DATA DIVISION.
           FILE SECTION.
           FD F-COMMENTS-FILE.
           01 RC-FILE-ENTRY.
             05 RC-ID PIC 999.
             05 RC-AUTHOR PIC X(16).
             05 RC-DATE-POST PIC X(10).
             05 RC-COMMENT PIC X(50).

           WORKING-STORAGE SECTION.
           01 MESSAGE-LINES PIC 999.
           01 NUM-COMMENTS PIC 9999.

           01 COUNTER PIC 999.
           01 ID-FIND PIC 999.

           01 COM-INDEX PIC 9999 VALUE 1.

           01 TEMP-TABLE.
               05 WS-ENTRY OCCURS 1 TO 9999 TIMES 
               DEPENDING ON NUM-COMMENTS.
                   10 TEMP-AUTHOR PIC X(16).
                   10 TEMP-DATE PIC X(10).
                   10 TEMP-COMMENT PIC X(50).

           01 WS-FILE-END PIC 9 VALUE 0.
           LINKAGE SECTION.
           01 FINAL-TABLE.
               05 LS-ENTRY OCCURS 1 TO 9999 TIMES
                 DEPENDING ON NUM-COMMENTS.
                   10 LS-AUTHOR PIC X(16).
                   10 LS-DATE PIC X(10).
                   10 LS-COMMENT PIC X(50).
    
           01 MSG-SELECT PIC 999.

       PROCEDURE DIVISION USING FINAL-TABLE, MSG-SELECT.
           
           CALL 'number-of-messages' USING MESSAGE-LINES.
           CALL 'num-comments' USING NUM-COMMENTS.
      ******************************************************************
      *********************----ABOUT THIS FILE---***********************
      *  This file takes a table and a number as an argument.          *
      *  The incoming number argument from the calling program is      *
      *  the index number passed through related to the messages list  *
      *  on the server.cbl file. The original index is flipped, so     *
      *  taking                                  ","This COBOL program defines a batch process that reads a file called ""comments.dat"" containing comments data with fields like ID, author, date posted, and comment. It stores this data in a temporary table and then processes it based on the number of comments. The program performs some calculations and likely interacts with other programs using CALL statements. The provided comments suggest a refactoring of certain parts of the program for improvement.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation did not mention the use and significance of the LINKAGE SECTION and PROCEDURE DIVISION in the source code.,0.00451399365518933,0.8603515625
cob_syn_2413,COBOL,"      * REFACTOR CANDIDATE BATCH_2413
      * SYSTEM GENERATED
      ******************************************************************
      * Author: Maxfx
      * Revision: Maxfx 31/08/2017
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. WORK-OFFSET.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
           01 WORK-AREA.
             03 WK-A PIC X(4) VALUE 'AAAA'.
             03 WK-B PIC X(4) VALUE 'BBBB'.
             03 WK-C PIC X(4) VALUE 'CCCC'.
             03 WK-D PIC X(4) VALUE 'DDDF'.

           01 WK-PTR POINTER.

       LINKAGE SECTION.
           01 WORK-DATA.
             03 WORK-A PIC X(4).
             03 NEXT-WORK-DATA PIC X(4).

       PROCEDURE DIVISION.
       MAIN-PROCEDURE.

           DISPLAY ""WK-PTR :   "" WK-PTR

           SET WK-PTR TO ADDRESS OF WORK-AREA.
           SET ADDRESS OF WORK-DATA TO WK-PTR.

           DISPLAY ""WORK-DATA : "" WORK-DATA.
           DISPLAY ""WK-PTR :   "" WK-PTR.
           DISPLAY ""WORK-A : "" WORK-A.
           DISPLAY ""NEXT-WORK-DATA : "" NEXT-WORK-DATA.

           GOBACK.
","This COBOL program defines a WORK-AREA containing four fields WK-A, WK-B, WK-C, and WK-D with default values. It also defines a WK-PTR POINTER. In the PROCEDURE DIVISION, the program sets the WK-PTR to the address of WORK-AREA and the address of WORK-DATA to WK-PTR. The program then displays the values of WORK-DATA, WK-PTR, WORK-A, and NEXT-WORK-DATA before ending execution.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention that the WORK-DATA and NEXT-WORK-DATA fields in the LINKAGE SECTION are being referred to in the code.,0.005277645918110919,0.8352674841880798
cob_syn_4099,COBOL,"      * REFACTOR CANDIDATE BATCH_4099
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. ASSIGNTO.
 ENVIRONMENT DIVISION.
    INPUT-OUTPUT SECTION.
       FILE-CONTROL.
          SELECT TEACHER ASSIGN TO DISK.","This COBOL program identifies as ""ASSIGNTO"" and defines a file control for a file named TEACHER that will be assigned to a disk for input and output operations.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the functionality of the given source code.,0.009849574084214482,0.8698000907897949
cob_real_2938,COBOL,"
function dbsize(link){
	resp = link.request('info', []);
	foreach(resp.data as k=>v){
		if(v != 'leveldb.stats'){
			continue;
		}
		s = resp.data[k + 1];
		lines = s.strip().split('\n');
		lines = lines[ 3 ..];
		size = 0;
		foreach(lines as line){
			ps = line.split();
			size += int(ps[2]);
		}
		return size;
	}
	return 0;
}

class SSDB_iterator_base
{
	public link;
	public finish = false;
	public batch = 2;
	public index = [];
	public key = '';
	public val = '';
	public end = '';
	
	function init(link){
		this.link = link;
	}
	
	function seek(s){
		this.key = s;
	}
	
	function set_range(s, e=''){
		this.key = s;
		this.end = e;
	}
}


class SSDB_kv_scan extends SSDB_iterator_base
{
	public items = [];

	function init(link){
	}
	
	function next(){
		if(this.finish){
			return false;
		}
		if(len(this.index) == 0){
			resp = this.link.request('scan', [this.key, this.end, this.batch]);
			if(len(resp.data['index']) == 0){
				this.finish = true;
				return false;
			}
			this.index = resp.data['index'];
			this.items = resp.data['items'];
		}
		this.key = this.index.pop(0);
		this.val = this.items[this.key];
		return true;
	}
}

/*
scan = new SSDB_kv_scan();
while(kvs.next()){
	print scan.key, scan.val;
}
*/

class SSDB_hash_list extends SSDB_iterator_base
{
	function init(link){
	}
	
	function next(){
		if(this.finish){
			return false;
		}
		if(len(this.index) == 0){
			resp = this.link.request('hlist', [this.key, this.end, this.batch]);
			if(len(resp.data) == 0){
				this.finish = true;
				return false;
			}
			this.index = resp.data;
		}
		this.key = this.index.pop(0);
		return true;
	}
}


class SSDB_zset_list extends SSDB_iterator_base
{
	function init(link){
	}
	
	function next(){
		if(this.finish){
			return false;
		}
		if(len(this.index) == 0){
			resp = this.link.request('zlist', [this.key, this.end, this.batch]);
			if(len(resp.data) == 0){
				this.finish = true;
				return false;
			}
			this.index = resp.data;
		}
		this.key = this.index.pop(0);
	","This COBOL code defines classes and functions related to interacting with an SSDB database. The `dbsize` function calculates and returns the size of the database. The `SSDB_iterator_base` class provides base functionalities for iterators used in scanning the database. Subclasses like `SSDB_kv_scan`, `SSDB_hash_list`, and `SSDB_zset_list` implement specific scanning operations tailored for key-value pairs, hash maps, and sorted sets respectively. Each class contains methods for initializing and iterating through database entries based on the specified criteria.",Legacy COBOL logic requiring documentation.,Irrelevant,True,"The documentation incorrectly states that the source code is written in COBOL, while it is clearly written in a language that resembles Python or PHP.",0.004358632673529301,0.839927613735199
py_13746,Python,"def dedent(text):
    """"""Equivalent of textwrap.dedent that ignores unindented first line.

    This means it will still dedent strings like:
    '''foo
    is a bar
    '''

    For use in wrap_paragraphs.
    """"""

    if text.startswith('\n'):
        # text starts with blank line, don't ignore the first line
        return textwrap.dedent(text)

    # split first line
    splits = text.split('\n',1)
    if len(splits) == 1:
        # only one line
        return textwrap.dedent(text)

    first, rest = splits
    # dedent everything but the first line
    rest = textwrap.dedent(rest)
    return '\n'.join([first, rest])","Equivalent of textwrap.dedent that ignores unindented first line. This means it will still dedent strings like:

    '''foo
    is a bar
    '''

For use in wrap_paragraphs.","Equivalent of textwrap.dedent that ignores unindented first line.

    This means it will still dedent strings like:
    '''foo
    is a bar
    '''

    For use in wrap_paragraphs.",No Error,False,The documentation accurately describes what the source code does and there are no unsupported claims or missing critical information.,1.0,0.9791261553764343
py_7223,Python,"def headers_present(self, headers):
        """"""
        Defines a list of headers that must be present in the
        outgoing request in order to satisfy the matcher, no matter what value
        the headers hosts.

        Header keys are case insensitive.

        Arguments:
            headers (list|tuple): header keys to match.

        Returns:
            self: current Mock instance.

        Example::

            (pook.get('server.com/api')
                .headers_present(['content-type', 'Authorization']))
        """"""
        headers = {name: re.compile('(.*)') for name in headers}
        self.add_matcher(matcher('HeadersMatcher', headers))","Defines a list of headers that must be present in the outgoing request in order to satisfy the matcher, regardless of the header values. Header keys are case insensitive. Accepts a list or tuple of header keys to match. Returns the current Mock instance. Example usage: (pook.get('server.com/api').headers_present(['content-type', 'Authorization']))","Defines a list of headers that must be present in the
        outgoing request in order to satisfy the matcher, no matter what value
        the headers hosts.

        Header keys are case insensitive.

        Arguments:
            headers (list|tuple): header keys to match.

        Returns:
            self: current Mock instance.

        Example::

            (pook.get('server.com/api')
                .headers_present(['content-type', 'Authorization']))",No Error,False,The documentation accurately reflects the functionality of the source code without any hallucinations or omissions.,0.5373563991335728,0.8369824290275574
py_14719,Python,"def audit_timeouts(self):
        """"""Audit all waiting tasks for expired timeouts.""""""
        now = datetime.now()
        for msg_id in self.depending.keys():
            # must recheck, in case one failure cascaded to another:
            if msg_id in self.depending:
                job = self.depending[msg_id]
                if job.timeout and job.timeout < now:
                    self.fail_unreachable(msg_id, error.TaskTimeout)",Audit all waiting tasks for expired timeouts.,Audit all waiting tasks for expired timeouts.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,1.0000001192092896
cob_syn_427,COBOL,"      * REFACTOR CANDIDATE BATCH_427
      * SYSTEM GENERATED
       identification division.
       program-id. FizzBuzz3.
       author. Andreas Suhre.

      *=================================================================

       data division.
       working-storage section.
       01 Lim constant as 100.
       01 Num pic 999.
       01 Prn pic ZZ9.

      *=================================================================

       procedure division.

       perform varying Num from 1 by 1 until Num > Lim
         evaluate function mod(Num 15)
           when = 0
                display ""FizzBuzz"" no advancing
           when = 3 or 6 or 9 or 12
                display ""Fizz"" no advancing
           when = 5 or 10
                display ""Buzz"" no advancing
           when other
                move Num to Prn
                display function trim(Prn) no advancing
         end-evaluate
         if Num < Lim
           display "", "" no advancing
         end-if
       end-perform
       display space

       stop run.
","This COBOL program generates FizzBuzz sequence up to a limit of 100. It iterates over numbers from 1 to 100 and prints ""Fizz"" if the number is divisible by 3, ""Buzz"" if the number is divisible by 5, and ""FizzBuzz"" if the number is divisible by both 3 and 5. Otherwise, it prints the number itself. The program separates each output with a comma and space.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The logic in the source code checks if the number's modulus 15 is equal to certain values instead of checking if the number is divisible by 3, 5 or both.",0.004801387150967651,0.8464483618736267
py_9115,Python,"def asin(wave):
    r""""""
    Return the arc sine of a waveform's dependent variable vector.

    :param wave: Waveform
    :type  wave: :py:class:`peng.eng.Waveform`

    :rtype: :py:class:`peng.eng.Waveform`

    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc()) ]]]
    .. Auto-generated exceptions documentation for
    .. peng.wave_functions.asin

    :raises:
     * RuntimeError (Argument \`wave\` is not valid)

     * ValueError (Math domain error)

    .. [[[end]]]
    """"""
    pexdoc.exh.addex(
        ValueError,
        ""Math domain error"",
        bool((min(wave._dep_vector) < -1) or (max(wave._dep_vector) > 1)),
    )
    return _operation(wave, ""asin"", ""rad"", np.arcsin)",Return the arc sine of a waveform's dependent variable vector.,"r""""""
    Return the arc sine of a waveform's dependent variable vector.

    :param wave: Waveform
    :type  wave: :py:class:`peng.eng.Waveform`

    :rtype: :py:class:`peng.eng.Waveform`

    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc()) ]]]
    .. Auto-generated exceptions documentation for
    .. peng.wave_functions.asin

    :raises:
     * RuntimeError (Argument \`wave\` is not valid)

     * ValueError (Math domain error)

    .. [[[end]]]",Omission,True,"The documentation does not explain what the _operation function does or what the ""rad"" and np.arcsin parameters do.",0.0301973834223185,0.820496141910553
cob_syn_7641,COBOL,"      * REFACTOR CANDIDATE BATCH_7641
      * SYSTEM GENERATED
       PROCESS NODYNAM,RENT,APOST,CICS,TRUNC(OPT)

      *****************************************************************
      * Licensed Materials - Property of IBM
      *
      * SAMPLE
      *
      * Copyright IBM Corp. 2017 All Rights Reserved
      *
      * Government Users Restricted Rights - Use, duplication or
      * disclosure restricted by GSA ADP Schedule Contract with
      * IBM Corp.
      *
      *****************************************************************
      *
      * Simple CICS terminal program to receive a supplier ID from the
      * terminal (if specified, otherwise use Task number), LINK to
      * specified Liberty program, and send results to the terminal.
      *
      * To simplify the code, this program has minimal error-handling
      * logic, except on the LINK to Liberty call itself.
      *
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID.              LINK2SUP.
       DATE-WRITTEN.            October 2017.
      *
       ENVIRONMENT DIVISION.
      *
       DATA DIVISION.
      *
       WORKING-STORAGE SECTION.
      *
      *    STOCK-PART copybook
           COPY STOKPART REPLACING STOCK-PART BY WS-STOCK-PART.
      *
      *    SUPPLIER copybook
           COPY SUPPLIER REPLACING SUPPLIER BY WS-SUPPLIER.

      *
      *    Working storage definitions
       01  WS-STORAGE.
           03 WS-TERMINAL-INPUT     PIC X(80)         VALUE SPACES.
           03 WS-RECEIVE-LENGTH     PIC 9(4)  COMP    VALUE ZERO.
           03 WS-TRANID             PIC X(4)          VALUE SPACES.
           03 WS-TRANID-LEN         PIC S9(8) COMP-4  VALUE ZERO.
           03 WS-TRANID-POS         PIC S9(8) COMP-4  VALUE ZERO.
           03 WS-SUPPLIER-TXT       PIC 9(8)  DISPLAY VALUE ZERO.
           03 WS-SUPPLIER-LEN       PIC S9(8) COMP-4  VALUE ZERO.
           03 WS-SUPPLIER-NO        PIC 9(8)  COMP-4  VALUE ZERO.
           03 LINK-RESP             PIC 9(8)  COMP","This COBOL program is a simple CICS terminal application designed to receive a supplier ID or Task number from the terminal, then link to a Liberty program based on the received ID, and finally send the results back to the terminal. The code lacks robust error-handling logic, focusing mainly on the linkage to the Liberty program. The program uses working storage to handle input data, such as supplier ID, transaction ID, and link response.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention about STOCK-PART or SUPPLIER copybooks that the program is using.,0.004358632673529301,0.8589418530464172
cob_syn_9603,COBOL,"      * REFACTOR CANDIDATE BATCH_9603
      * SYSTEM GENERATED
*>---------------
*> system-ws.cpy
*>---------------
01  ws-sys-record.
  05  ws-sys-record-ver-major pic 9(02).
	05  ws-sys-record-ver-minor pic 9(02).

","This COBOL code defines a data structure `ws-sys-record` with two fields `ws-sys-record-ver-major` and `ws-sys-record-ver-minor` to store system version information, where `ws-sys-record-ver-major` is a 2-digit integer representing the major version and `ws-sys-record-ver-minor` is a 2-digit integer representing the minor version.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes what is in the code.,0.007469938459592591,0.8345093727111816
py_212,Python,"def get_previous_dagrun(self, session=None):
        """"""The previous DagRun, if there is one""""""

        return session.query(DagRun).filter(
            DagRun.dag_id == self.dag_id,
            DagRun.execution_date < self.execution_date
        ).order_by(
            DagRun.execution_date.desc()
        ).first()","The `get_previous_dagrun` method returns the previous DagRun object based on the execution date, if one exists for the same dag_id.","The previous DagRun, if there is one",No Error,False,The code and the documentation are in sync. The documentation correctly describes what the method does.,0.01843926024949715,0.8741698861122131
cob_syn_5982,COBOL,"      * REFACTOR CANDIDATE BATCH_5982
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. DCJB8PGE.
       AUTHOR. ANDREW MAYNE.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

      * COPY INQUIRY MAP LAYOUT
       COPY 'DCJB8MR'.

      * COPY ACCTFILE RECORD LAYOUT
       COPY 'STUDATA'.

       01 WS-STU-LENGTH-CONST PIC 9 VALUE 4.
       01 WS-COURSE-COUNTER PIC 9 VALUE 0.
       01 WS-MSG            PIC X(40).

       01 Cr1I PIC 9 VALUE 2.
       01 Cr2I PIC 9 VALUE 3.
       01 Cr3I PIC 9 VALUE 4.
       01 Cr4I PIC 9 VALUE 5.

       01 WS-ERRORCODE-CONSTS.
           05 ERRNUMBER PIC 99 VALUE 1.
           05 ERRCOURSE1A PIC 99 VALUE 2.
           05 ERRCOURSE2A PIC 99 VALUE 3.
           05 ERRCOURSE3A PIC 99 VALUE 4.
           05 ERRCOURSE4A PIC 99 VALUE 5.
           05 ERRCOURSE5A PIC 99 VALUE 6.
           05 ERRCOURSE1B PIC 99 VALUE 7.
           05 ERRCOURSE2B PIC 99 VALUE 8.
           05 ERRCOURSE3B PIC 99 VALUE 9.
           05 ERRCOURSE4B PIC 99 VALUE 10.
           05 ERRCOURSE5B PIC 99 VALUE 11.
           05 ERRNAME PIC 99 VALUE 12.
           05 ERRADD1 PIC 99 VALUE 13.
           05 ERRADD2 PIC 99 VALUE 14.
           05 ERRPOS1 PIC 99 VALUE 15.
           05 ERRPOS2 PIC 99 VALUE 16.
           05 ERRPHN1  PIC 99 VALUE 17.
           05 ERRPHN2  PIC 99 VALUE 18.
           05 ERRPHN3  PIC 99 VALUE 19.

       01 WS-COURSE-ARRAY.
          05 WS-COURSES OCCURS 5 TIMES.
             10 WS-CODES PIC X(8).

       01 WS-ALPHA PIC X.
           88 CAPITAL VALUE 'A' THRU 'Z'.

       01 I PIC 99 VALUE 0.
       01 WS-VALID-COUNT PIC 99 VALUE 0.

       01 WS-COURSE-CODE-1.
           05 WS-COURSE-CODE-1A  PIC X(4).
           05 WS-COURSE-CODE-1B  PIC X(4).

       01 WS-COURSE-CODE-2.
           05 WS-COURSE-CODE-2A  PIC X(4).
           05 WS-COURSE-CODE-2B  PIC X(4).

       01 WS-COURSE-CODE-3.
           05 WS-COURSE-CODE-3A  PIC X(4).
           05 WS-COURSE-CODE-3B  PIC X(4).

       01 WS-COURSE-CODE-4.
      ","This program defines data structures and constants related to student information and course codes. It declares variables for error codes, course codes, and other relevant information. The code prepares the layout and structures needed to process student data and handle potential errors.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention the use of the 'CAPITAL' status flag and various course code declarations.,0.0,0.8473160862922668
cob_syn_7523,COBOL,"      * REFACTOR CANDIDATE BATCH_7523
      * SYSTEM GENERATED
       ID DIVISION.
       PROGRAM-ID. EPSMLIST.
      *    THIS DEMONSTRATES CICS/DEBUG           - EPSDEMOS 2008
      *
      *    THIS PROGRAM WILL RECEIVE A DATE AND COVERT THE DATE TO
      *    AN INTEGER IN A CALLED PROGRAM TO DETERMINE DAYS FROM
      *    CURRENT DATE.
      *
      *    modif
      *    (C) 2012 IBM - JIM HILDNER RESERVED.
      *+++++++++++++++ Xav Git test +++++++++++++++++++++++
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER. IBM-FLEX-ES.
       OBJECT-COMPUTER. IBM-FLEX-ES.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.
      *
       01  W-FLAGS.
           10  W-SEND-FLAG                    PIC X.
               88  SEND-ERASE                   VALUE '1'.
               88  SEND-DATAONLY                VALUE '2'.
               88  SEND-MAPONLY                 VALUE '3'.
               88  SEND-DATAONLY-ALARM          VALUE '4'.

       01 W-CONVERSIONS.
           05  W-PMT-CNVRT     PIC X(12).
           05  W-PMT-NUMBER
               REDEFINES W-PMT-CNVRT
                               PIC 9(10)V99.
           05  WS-FORMAT-NUMBER PIC Z,ZZZ,ZZ9.99.
           05  W-PRINC-CNVRT   PIC X(12).
           05  W-PRINC-NUMBER
               REDEFINES W-PRINC-CNVRT
                               PIC 9(10)V99.

       01 W-CALL-PROGRAM                      PIC X(8).
       01 RESPONSE                            PIC S9(8) COMP.
       01 INTERNAL-PROGRAM-VARIABLES.
           05 RID-LENGTH                      PIC S9(9) COMP.
           05 DISP-COUNT                      PIC S9(4) COMP.
           05 MAX-LOOP                        PIC S9(4) COMP
                                              VALUE IS 8.
           05 END-OF-FILE                     PIC X.
           05 CLOSE-FILE                      PIC X.
      *
       01 W-RETIREMENT-WA                     PIC 9(4).
       01 W-COMAREA-LENGTH                    PIC 9(4) COMP.

       01 SAVE-COMM-AREA.
          COPY EPSMTCOM.

       ","This COBOL program receives a date as input and converts it to an integer in a called program to calculate the number of days from the current date. It defines working storage variables for flags, conversions, and program variables.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention the use of copybooks, in this case, EPSMTCOM.",0.007469938459592591,0.8682305812835693
py_5231,Python,"def hex_to_name(hexx):
    """"""
    Convert hex to a color name, using matplotlib's colour names.

    Args:
        hexx (str): A hexadecimal colour, starting with '#'.

    Returns:
        str: The name of the colour, or None if not found.
    """"""
    for n, h in defaults.COLOURS.items():
        if (len(n) > 1) and (h == hexx.upper()):
            return n.lower()
    return None","Converts a hexadecimal color code to a color name using matplotlib's color names dictionary. If the color name is found, it returns the lowercase name of the color; otherwise, it returns None.","Convert hex to a color name, using matplotlib's colour names.

    Args:
        hexx (str): A hexadecimal colour, starting with '#'.

    Returns:
        str: The name of the colour, or None if not found.",No Error,False,The documentation accurately describes the function's use.,0.07753570900110017,0.8506831526756287
cob_syn_3994,COBOL,"      * REFACTOR CANDIDATE BATCH_3994
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. TAPTODSK.
       AUTHOR. BILL BLASINGIM.
       REMARKS.
           Simple MVS COBOL program
           A simple tape to disk copy.

           Input tape file came from Linux and each record 
           although a fixed length still had a line feed at the end. 
           So this program outputs everything not including the end
           byte. The IBM utility IEBGENER can do this...
           but I didn't know it at the time.

           FYI: The input tape file is a virtual tape, but as far as 
           this program is concerned it's a real tape.

       DATE-WRITTEN. Oct. 13, 2019
       DATE-COMPILED.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT IN-FILE ASSIGN TO UT-S-INTAPE.
           SELECT OUT-FILE ASSIGN TO DA-S-OUTDISK.

       DATA DIVISION.
       FILE SECTION.
       FD  IN-FILE
           BLOCK CONTAINS 100 RECORDS
           LABEL RECORDS STANDARD.
       01  IN-RECORD.
           05 IN-REC                        PIC X(163).
           05 FILLER                        PIC X(01).
       FD  OUT-FILE
           BLOCK CONTAINS 100 RECORDS
           LABEL RECORDS STANDARD.
       01  OUT-RECORD                       PIC X(163).

       WORKING-STORAGE SECTION.
       01  WORK-AREA.
           05  PAGE-CNT                     PIC S9(3) VALUE +0 COMP-3.
           05  LINE-CNT                     PIC S9(3) VALUE +0 COMP-3.
           05  REC-CNT                      PIC S9(7) VALUE +0 COMP-3.
           05  EOF-FLAG                     PIC X(01) VALUE 'N'.
               88  EOF                                VALUE 'Y'.

       PROCEDURE DIVISION.

      *    A COMMENT.

           OPEN INPUT IN-FILE.
           OPEN OUTPUT OUT-FILE.           

           PERFORM READ-RTN THRU READ-EXIT.
           PERFORM PROCESS-RTN THRU PROCESS-EXIT
               UNTIL EOF.

           CLOSE IN-FILE, OUT-FILE.

           STOP RUN.  ","This COBOL program is a simple utility to copy data from a tape file to a disk file. It reads fixed-length records from an input tape file coming from Linux, excluding the end byte (line feed), and writes them to an output disk file. The program keeps track of the number of records read and processed. The main logic involves reading records from the input file, processing them, and writing to the output file until the end of the input file is reached.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention that the program also considers a virtual tape file as a real tape.,0.00470272427921916,0.8493714332580566
py_13848,Python,"def list_namespace(namespace, type_pattern, filter, ignore_case=False, show_all=False):
    """"""Return dictionary of all objects in a namespace dictionary that match
    type_pattern and filter.""""""
    pattern_list=filter.split(""."")
    if len(pattern_list) == 1:
       return filter_ns(namespace, name_pattern=pattern_list[0],
                        type_pattern=type_pattern,
                        ignore_case=ignore_case, show_all=show_all)
    else:
        # This is where we can change if all objects should be searched or
        # only modules. Just change the type_pattern to module to search only
        # modules
        filtered = filter_ns(namespace, name_pattern=pattern_list[0],
                            type_pattern=""all"",
                            ignore_case=ignore_case, show_all=show_all)
        results = {}
        for name, obj in filtered.iteritems():
            ns = list_namespace(dict_dir(obj), type_pattern,
                                ""."".join(pattern_list[1:]),
                                ignore_case=ignore_case, show_all=show_all)
            for inner_name, inner_obj in ns.iteritems():
                results[""%s.%s""%(name,inner_name)] = inner_obj
        return results",Return dictionary of all objects in a namespace dictionary that match type_pattern and filter.,"Return dictionary of all objects in a namespace dictionary that match
    type_pattern and filter.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,0.9571046829223633
py_11149,Python,"def update_filenames(self):
        """"""Does nothing currently.  May not need this method""""""
        self.sky_file = os.path.abspath(os.path.join(os.path.join(self.input_path, 'sky_files'),
                                                     'sky_' + self.sky_state + '_z' + str(
                                                         self.sky_zenith) + '_a' + str(
                                                         self.sky_azimuth) + '_' + str(
                                                         self.num_bands) + '_' + self.ds_code))","Updates the filename of the sky_file attribute based on the input parameters such as sky_state, sky_zenith, sky_azimuth, num_bands, and ds_code. The new filename is composed of these parameters as well as paths from the input_path directory.",Does nothing currently.  May not need this method,Wrong Logic,True,"The documentation incorrectly suggests that the function is updating the filename, whereas the function's source code actually does not perform any such action and is currently vacant.",0.0,0.8191760182380676
py_9105,Python,"def _chunk_noise(noise):
    """"""Chunk input noise data into valid Touchstone file rows.""""""
    data = zip(
        noise[""freq""],
        noise[""nf""],
        np.abs(noise[""rc""]),
        np.angle(noise[""rc""]),
        noise[""res""],
    )
    for freq, nf, rcmag, rcangle, res in data:
        yield freq, nf, rcmag, rcangle, res",Chunk input noise data into valid Touchstone file rows.,Chunk input noise data into valid Touchstone file rows.,Omission,True,"The documentation does not detail what the input parameters signify, nor the structure and purpose of the output returned by the function.",1.0,1.0
py_5094,Python,"def parse_argv(self, argv=None):
        # type: (Optional[tuple]) -> dict
        """"""
        Parses arguments for the command.

        :param argv:
            Arguments to pass to the argument parser.
            If ``None``, defaults to ``sys.argv[1:]``.
        """"""
        arguments = vars(self.create_argument_parser().parse_args(argv))

        seed = None
        if self.requires_seed:
            seed_filepath = arguments.pop('seed_file')

            seed = (
                self.seed_from_filepath(seed_filepath)
                if seed_filepath
                else self.prompt_for_seed()
            )

        arguments['api'] = Iota(
            adapter=arguments.pop('uri'),
            seed=seed,
            testnet=arguments.pop('testnet'),
        )

        return arguments","Parses arguments for the command, extracts and processes the necessary arguments, and returns a dictionary containing the parsed arguments for further use in the program flow.","Parses arguments for the command.

        :param argv:
            Arguments to pass to the argument parser.
            If ``None``, defaults to ``sys.argv[1:]``.",No Error,False,The documentation accurately describes what the source code does.,0.09562406574442013,0.798566997051239
py_7055,Python,"def _set_secondary_channels(self):
        """"""Sets the secondary channels for the pipeline

        This will iterate over the
        :py:attr:`NextflowGenerator.secondary_channels` dictionary that is
        populated when executing
        :func:`~NextflowGenerator._update_secondary_channels` method.
        """"""

        logger.debug(""=========================="")
        logger.debug(""Setting secondary channels"")
        logger.debug(""=========================="")

        logger.debug(""Setting secondary channels: {}"".format(
            self.secondary_channels))

        for source, lanes in self.secondary_channels.items():

            for vals in lanes.values():

                if not vals[""end""]:
                    logger.debug(""[{}] No secondary links to setup"".format(
                        vals[""p""].template))
                    continue

                logger.debug(""[{}] Setting secondary links for ""
                             ""source {}: {}"".format(vals[""p""].template,
                                                    source,
                                                    vals[""end""]))

                vals[""p""].set_secondary_channel(source, vals[""end""])",Sets the secondary channels for the pipeline. This function iterates over the `NextflowGenerator.secondary_channels` dictionary populated by the `_update_secondary_channels` method.,"Sets the secondary channels for the pipeline

        This will iterate over the
        :py:attr:`NextflowGenerator.secondary_channels` dictionary that is
        populated when executing
        :func:`~NextflowGenerator._update_secondary_channels` method.",No Error,False,The generated documentation accurately describes the functionality of the source code without any omissions or hallucinations.,0.27942449484953946,0.878643810749054
cob_syn_6136,COBOL,"      * REFACTOR CANDIDATE BATCH_6136
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    ADD Customer Details                        *
      *                                                                *
      *   To add customer's name, address and date of birth to the     *
      *  DB2 customer table creating a new customer entry.             *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGACDB01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *----------------------------------------------------------------*
      * Common defintions                                              *
      *------------------------","This COBOL program is designed to add customer details, including name, address, and date of birth, to a DB2 customer table by creating a new customer entry. The program is identified as LGACDB01 and contains common definitions in the working-storage section.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the purpose and functionality of the code.,0.0071638813215387015,0.8622835278511047
py_11029,Python,"def build_graph(self, graph, tokens):
        """""" Builds a Godot graph.
        """"""
        subgraph = None

        for element in tokens:
            cmd = element[0]
            if cmd == ADD_NODE:
                cmd, nodename, opts = element
                graph.add_node(nodename, **opts)

            elif cmd == ADD_EDGE:
                cmd, src, dest, opts = element
                srcport = destport = """"
                if isinstance(src,tuple):
                    srcport = src[1]
                    src = src[0]
                if isinstance(dest,tuple):
                    destport = dest[1]
                    dest = dest[0]

                graph.add_edge(src, dest, tailport=srcport, headport=destport,
                               **opts)

            elif cmd in [ADD_GRAPH_TO_NODE_EDGE,
                         ADD_GRAPH_TO_GRAPH_EDGE,
                         ADD_NODE_TO_GRAPH_EDGE]:
                cmd, src, dest, opts = element
                srcport = destport = """"

                if isinstance(src,tuple):
                    srcport = src[1]

                if isinstance(dest,tuple):
                    destport = dest[1]

                if not (cmd == ADD_NODE_TO_GRAPH_EDGE):
                    if cmd == ADD_GRAPH_TO_NODE_EDGE:
                        src = subgraph
                    else:
                        src = prev_subgraph
                        dest = subgraph
                else:
                    dest = subgraph

                src_is_graph = isinstance(src, (Subgraph, Cluster))
                dst_is_graph = isinstance(dst, (Subgraph, Cluster))

                if src_is_graph:
                    src_nodes = src.nodes
                else:
                    src_nodes = [src]
                if dst_is_graph:
                    dst_nodes = dst.nodes
                else:
                    dst_nodes = [dst]

                for src_node in src_nodes:
                    for dst_node in dst_nodes:
                        graph.add_edge(from_node=src_node, to_node=dst_node,
                                       tailport=srcport, headport=destport,
                                       **kwds)

            elif cmd == SET_GRAPH_ATTR:
                graph.set( **element[1] )

            elif cmd == SET_DEF_NODE_ATTR:
                graph.default_node.set( **element[1] )

            elif cmd == SET_DEF_EDGE_ATTR:
                graph.default_edge.set( **element[1] )

            elif cmd == SET_DEF_GRAPH_ATTR:
                graph.default_graph.set( **element[1] )

            elif cmd == ADD_SUBGRAPH:
                cmd, name, elements = element
                if subgraph:
                    prev_subgraph = subgraph
                if name.startswith(""cluster""):
                    cluster = Cluster(ID=name)
                    cluster = self.build_graph(cluster, elements)
                    graph.add_cluster(cluster)
                else:
                    subgraph = Subgraph(ID=name)
                    subgraph = self.build_graph(subgraph, elements)
                    graph.add_subgraph(subgraph)

        return graph","Builds a Godot graph based on the provided tokens, which consist of commands and associated elements such as node names, edges, attributes, and subgraph information. This method constructs the graph by adding nodes, edges, setting attributes, and handling subgraphs. The resultant graph is returned at the end.",Builds a Godot graph.,Omission,True,"The documentation does not cover the specific role of certain commands, like adding edges between nodes and adding subgraphs, or how tuples are processed for source and destination points.",0.027103597387080115,0.8825771808624268
py_3349,Python,"def get_issues(self, from_date):
        """"""Retrieve all the issues from a given date.

        :param from_date: obtain issues updated since this date
        """"""
        url = urijoin(self.base_url, self.RESOURCE, self.VERSION_API, 'search')
        issues = self.get_items(from_date, url)

        return issues",Retrieve all the issues from a given date.,"Retrieve all the issues from a given date.

        :param from_date: obtain issues updated since this date",Omission,True,The documentation doesn't describe what the 'from_date' parameter does nor how the returned information is structured.,0.36787944117144233,0.8950844407081604
py_3039,Python,"def _format_value(value):
  """"""Returns `value` in a format parseable by `parse_value`, or `None`.

  Simply put, This function ensures that when it returns a string value, the
  following will hold:

      parse_value(_format_value(value)) == value

  Args:
    value: The value to format.

  Returns:
    A string representation of `value` when `value` is literally representable,
    or `None`.
  """"""
  literal = repr(value)
  try:
    if parse_value(literal) == value:
      return literal
  except SyntaxError:
    pass
  return None","Returns `value` in a format parseable by `parse_value`, or `None`.

Simply put, This function ensures that when it returns a string value, the following will hold:

    parse_value(_format_value(value)) == value

Args:
  value: The value to format.

Returns:
  A string representation of `value` when `value` is literally representable, or `None`.","Returns `value` in a format parseable by `parse_value`, or `None`.

  Simply put, This function ensures that when it returns a string value, the
  following will hold:

      parse_value(_format_value(value)) == value

  Args:
    value: The value to format.

  Returns:
    A string representation of `value` when `value` is literally representable,
    or `None`.",No Error,False,"The documentation accurately describes the function, its purpose, arguments, and return value.",1.0,0.9595538377761841
py_12449,Python,"def read_eol(self) -> bool:
    """"""Return True if the parser can consume an EOL byte sequence.""""""
    if self.read_eof():
        return False
    self._stream.save_context()
    self.read_char('\r')
    if self.read_char('\n'):
        return self._stream.validate_context()
    return self._stream.restore_context()",Return True if the parser can consume an EOL byte sequence.,Return True if the parser can consume an EOL byte sequence.,No Error,False,The generated documentation accurately represents the functionality of the source code.,1.0,1.0
py_3169,Python,"def setup_cmd_parser(cls):
        """"""Returns the RSS argument parser.""""""

        parser = BackendCommandArgumentParser(cls.BACKEND.CATEGORIES,
                                              archive=True)

        # Required arguments
        parser.parser.add_argument('url',
                                   help=""URL of the RSS feed"")

        return parser",Returns the RSS argument parser with the specified categories and enables archiving. The parser includes a required argument for the URL of the RSS feed.,Returns the RSS argument parser.,No Error,False,The documentation correctly describes what the source code does.,0.09429254736980938,0.9254639148712158
py_11763,Python,"def args(self):
        """"""The arguments which will be passed to ``url_for``.

        :type: :class:`dict`
        """"""
        if self._args is None:
            return {}
        if callable(self._args):
            return dict(self._args())
        return dict(self._args)","""""""This method returns the arguments that will be passed to the `url_for` function. 
It specifies that the type of the returned value is a dictionary. 
If the `_args` attribute is `None`, an empty dictionary is returned. 
If `_args` is a callable function, its return value is converted to a dictionary and returned. 
Otherwise, the `_args` attribute is assumed to be a dictionary and returned. 
""""""","The arguments which will be passed to ``url_for``.

        :type: :class:`dict`",No Error,False,The documentation accurately represents the source code without any hallucinations or omissions.,0.03686157786230467,0.8423755168914795
cob_syn_8888,COBOL,"      * REFACTOR CANDIDATE BATCH_8888
      * SYSTEM GENERATED
identification division.
program-id. game-of-life-program.
data division.
working-storage section.
01  grid.
    05 cell-table.
        10 row occurs 5 times.
            15 cell pic x value space occurs 5 times.
    05 next-gen-cell-table.
        10 next-gen-row occurs 5 times.
            15 next-gen-cell pic x occurs 5 times.
01  counters.
    05 generation pic 9.
    05 current-row pic 9.
    05 current-cell pic 9.
    05 living-neighbours pic 9.
    05 neighbour-row pic 9.
    05 neighbour-cell pic 9.
    05 check-row pic s9.
    05 check-cell pic s9.
procedure division.
control-paragraph.
    perform blinker-paragraph varying current-cell from 2 by 1
    until current-cell is greater than 4.
    perform show-grid-paragraph through life-paragraph
    varying generation from 0 by 1
    until generation is greater than 2.
    stop run.
blinker-paragraph.
    move '#' to cell(3,current-cell).
show-grid-paragraph.
    display 'GENERATION ' generation ':'.
    display '   +---+'.
    perform show-row-paragraph varying current-row from 2 by 1
    until current-row is greater than 4.
    display '   +---+'.
    display ''.
life-paragraph.
    perform update-row-paragraph varying current-row from 2 by 1
    until current-row is greater than 4.
    move next-gen-cell-table to cell-table.
show-row-paragraph.
    display '   |' with no advancing.
    perform show-cell-paragraph varying current-cell from 2 by 1
    until current-cell is greater than 4.
    display '|'.
show-cell-paragraph.
    display cell(current-row,current-cell) with no advancing.
update-row-paragraph.
    perform update-cell-paragraph varying current-cell from 2 by 1
    until current-cell is greater than 4.
update-cell-paragraph.
    move 0 to living-neighbours.
    perform check-row-paragraph varying check-row from -1 by 1
    until check-row is greater than 1.
    evaluate living-neighbours,
        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),
        when ","This COBOL program simulates Conway's Game of Life. It initializes a grid of cells, displays the generations, and updates the grid based on the rules of the game. The program includes paragraphs for initializing a blinker pattern, displaying the grid with generation numbers, updating the cells for each generation, and checking neighbors to determine the cell's fate in the next generation.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention about a certain portion of unfinished logic in the update-cell-paragraph section.,0.005131423326712104,0.8578534126281738
py_11270,Python,"def dates_to_keep(dates,
                  years=0, months=0, weeks=0, days=0, firstweekday=SATURDAY,
                  now=None):
    """"""
    Return a set of dates that should be kept, out of ``dates``.

    See ``to_keep`` for a description of arguments.
    """"""
    datetimes = to_keep((datetime.combine(d, time()) for d in dates),
                        years=years, months=months, weeks=weeks, days=days,
                        hours=0, minutes=0, seconds=0,
                        firstweekday=firstweekday, now=now)
    return set(dt.date() for dt in datetimes)","Return a set of dates that should be kept, out of the given 'dates'. The 'dates_to_keep' function uses the 'to_keep' function to filter out dates based on the specified criteria such as years, months, weeks, and days. The function returns a set of datetime objects converted to dates.","Return a set of dates that should be kept, out of ``dates``.

    See ``to_keep`` for a description of arguments.",Omission,True,The documentation does not mention the 'firstweekday' and 'now' parameters.,0.21158827697516278,0.8809847235679626
cob_syn_900,COBOL,"      * REFACTOR CANDIDATE BATCH_900
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. DISSTMT.
 DATA DIVISION.
 COMMUNICATION SECTION.
    CD SOMECDNAME1 FOR INPUT.
    CD SOMECDNAME2 FOR INITIAL I-O.
    CD SOMECDNAME3 FOR OUTPUT.
 PROCEDURE DIVISION.
    DISABLE INPUT TERMINAL SOMECDNAME1 WITH KEY SOMEID1.
    DISABLE I-O TERMINAL SOMECDNAME2 WITH KEY SOMEID2.
    DISABLE OUTPUT SOMECDNAME3 WITH KEY SOMEID3.","This COBOL code defines a program named DISSTMT with three file definitions: SOMECDNAME1 for input, SOMECDNAME2 for initial I-O, and SOMECDNAME3 for output. The program then disables terminal input for SOMECDNAME1 with the key SOMEID1, disables initial I-O for SOMECDNAME2 with the key SOMEID2, and disables output for SOMECDNAME3 with the key SOMEID3.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the actions and features of the source code.,0.005776163584689931,0.8369863629341125
py_8667,Python,"def add_to_parser(self, subparsers):
        """"""
        Adds this SubParser to the subparsers created by
        argparse.ArgumentParser.add_subparsers method.

        @param subparsers Normally a _SubParsersAction instance created by
        argparse.ArgumentParser.add_subparsers method
        """"""
        parser = subparsers.add_parser(*self._get_args(), **self._get_kwargs())
        parser.set_defaults(**self.get_defaults())
        for name, group in self.base_argument_groups:
            group.add_to_parser(parser)
        for name, arg in self.base_arguments:
            arg.add_to_parser(parser)
        self.add_subparsers(parser)",Adds a SubParser to the subparsers created by the argparse.ArgumentParser.add_subparsers method. The 'subparsers' parameter is typically a _SubParsersAction instance created by argparse.ArgumentParser.add_subparsers method.,"Adds this SubParser to the subparsers created by
        argparse.ArgumentParser.add_subparsers method.

        @param subparsers Normally a _SubParsersAction instance created by
        argparse.ArgumentParser.add_subparsers method",No Error,False,The documentation accurately portrays the functionality of the code.,0.47027963408204876,0.900642991065979
cob_syn_7565,COBOL,"      * REFACTOR CANDIDATE BATCH_7565
      * SYSTEM GENERATED
>>IF docpass NOT DEFINED

... code ...

>>ELSE
!doc-marker!
========
:SAMPLE:
========

.. contents::

Introduction
------------
ReStructuredText or other markup source ...
>>END-IF
","This COBOL code snippet is a placeholder for a refactoring candidate batch process. It checks if a variable ""docpass"" is not defined. If ""docpass"" is not defined, certain code logic will be executed. If ""docpass"" is defined, it generates structured sample documentation content using ReStructuredText or other markup source format.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the code's actions with no information missing or falsely added.,0.007213727908218376,0.8632967472076416
py_1423,Python,"def asfactor(self):
        """"""
        Convert columns in the current frame to categoricals.

        :returns: new H2OFrame with columns of the ""enum"" type.
        """"""
        for colname in self.names:
            t = self.types[colname]
            if t not in {""bool"", ""int"", ""string"", ""enum""}:
                raise H2OValueError(""Only 'int' or 'string' are allowed for ""
                                    ""asfactor(), got %s:%s "" % (colname, t))
        fr = H2OFrame._expr(expr=ExprNode(""as.factor"", self), cache=self._ex._cache)
        if fr._ex._cache.types_valid():
            fr._ex._cache.types = {name: ""enum"" for name in self.types}
        else:
            raise H2OTypeError(""Types are not available in result"")
        
        return fr","Converts columns in the current frame to categoricals and returns a new H2OFrame with columns of the ""enum"" type.","Convert columns in the current frame to categoricals.

        :returns: new H2OFrame with columns of the ""enum"" type.",No Error,False,The generated documentation correctly summarizes the function's operations without any hallucinations or critical omissions.,0.6165255292124369,0.9135146737098694
cob_syn_5029,COBOL,"      * REFACTOR CANDIDATE BATCH_5029
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.
000100 PROGRAM-ID. HELLO.
000100 
000100 DATA DIVISION.
000100 WORKING-STORAGE SECTION.
000100   EXEC SQL
000100     INCLUDE SQLSCRIPT
000100   END-EXEC.
000100 
000100   EXEC SQL
000100     INCLUDE TEACHER
000100   END-EXEC.
000100 
000100   EXEC SQL BEGIN DECLARE SECTION
000100   END-EXEC.
000100     01 WS-TEACHER-REC.
000100     05 WS-TEACHER-ID PIC 9(10).
000100   EXEC SQL END DECLARE SECTION
000100   END-EXEC.
000100 
000100 PROCEDURE DIVISION.
000100   EXEC SQL
000100     SELECT TEACHER-ID
000100       INTO :WS-TEACHER-ID FROM TEACHER
000100       WHERE TEACHER-ID=1
000100   END-EXEC.
000100 
000100   IF SQLCODE=0
000100   DISPLAY WS-TEACHER-RECORD
000100   ELSE DISPLAY 'Error'
000100   END-IF.
000100   STOP RUN.","This COBOL program retrieves the record of a teacher with ID 1 from a database table named TEACHER. It uses embedded SQL statements to interact with the database. If the record is found successfully, it displays the teacher's information. Otherwise, it displays an error message.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.006626589205134352,0.8646352291107178
cob_real_136,COBOL,"000001 Identification Division.                                         00000001
000002 Program-ID. testantlr344.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005                                                                  00000005
000006 >>DEFINE A 2                                                     00000006
000007 >>DEFINE B 3                                                     00000007
000008 >>DEFINE C A + B                                                 00000008
000009 >>DEFINE D A * B                                                 00000009
000010 >>DEFINE E (D * A) / 3                                           00000010
000011                                                                  00000011
000012 01  CONSTANTS.                                                   00000012
000013     05  MYNAME               PIC X(012) VALUE 'testantlr344'.    00000013
000014     05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.        00000014
000015     05  PGM-0002             PIC X(008) VALUE 'PGMA0002'.        00000015
000016     05  PGM-0003             PIC X(008) VALUE 'PGMA0003'.        00000016
000017     05  PGM-0009             PIC X(008) VALUE 'PGMA0009'.        00000017
000018                                                                  00000018
000019*                                                                 00000019
000020                                                                  00000020
000021 Procedure Division.                                              00000021
000022     DISPLAY MYNAME ' Begin'                                      00000022
000023                                                                  00000023
000024     >>IF C = 5                                                   00000024
000025     CALL PGM-0001                                ","This COBOL program defines constants A, B, C, D, and E with specific values and performs basic arithmetic operations using these constants. It also defines other constants and displays a message indicating the beginning of the program. If the value of C is 5, it calls a specific program (PGM-0001).",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.006065997938636506,0.8606754541397095
cob_real_2653,COBOL,"       *> Try POH
       *> author: Leonardone @ NEETSDKASU
       *>  1
       *>==============================================================$
       IDENTIFICATION DIVISION.
       PROGRAM-ID. MAIN.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       REPOSITORY.
              FUNCTION ALL INTRINSIC.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 ANSWER-VALUES.
              05 STR-CARDS PIC X(200).
              05 ARR OCCURS 52 TIMES.
                     07 STR-C  PIC XX.
                     07 INT-R  PIC 99.
              05 INT-I   PIC 999.
              05 INT-J   PIC 99 VALUE IS 1.
              05 STR-X   PIC X.
              05 STR-T   PIC XX.
              05 INT-P   PIC 999.
              05 INT-K   PIC 99.
              05 INT-E   PIC 99.
              05 INT-Z   PIC Z9.
       PROCEDURE DIVISION.
       MAIN-ROUTINE SECTION.
       000-MAIN.
              
              ACCEPT STR-CARDS.
              
              PERFORM WITH TEST AFTER
              VARYING INT-I FROM 1 BY 1 UNTIL INT-I >= 108
                    MOVE STR-CARDS(INT-I:1) TO STR-X
                    IF STR-X = SPACE THEN
                           MOVE STR-T TO STR-C(INT-J)
                           MOVE SPACE TO STR-T
                           ADD 1 TO INT-J
                    ELSE
                           MOVE CONCATENATE(TRIM(STR-T),TRIM(STR-X))
                                  TO STR-T
                    END-IF
              END-PERFORM.
              
              MOVE 1 TO INT-J.
              
              PERFORM WITH TEST AFTER UNTIL INT-J >= 53
                     PERFORM WITH TEST AFTER
                     VARYING INT-I FROM 1 BY 1 UNTIL INT-I >= 52
                            IF INT-I = INT-P THEN
                                 MOVE 0 TO INT-P
                                 MOVE 0 TO INT-E
                            END-IF
                            IF INT-R(INT-I) = 0 THEN
                                   M",This COBOL program reads a string input and processes it to extract certain values based on predefined rules and conditions. The program splits the input string into individual characters and stores them in arrays. It then manipulates these values according to specified logic and conditions. The code includes loops to iterate through the data and apply the necessary transformations.,Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.006276214076282571,0.8646573424339294
py_4090,Python,"def set_issuer(self, issuer):
        """"""
        Set the issuer of this certificate.

        :param issuer: The issuer.
        :type issuer: :py:class:`X509Name`

        :return: ``None``
        """"""
        self._set_name(_lib.X509_set_issuer_name, issuer)
        self._issuer_invalidator.clear()",Set the issuer of a certificate by providing the issuer X509Name. The function updates the issuer name of the certificate and clears the issuer invalidator.,"Set the issuer of this certificate.

        :param issuer: The issuer.
        :type issuer: :py:class:`X509Name`

        :return: ``None``",No Error,False,The documentation correctly describes the method's function based on the source code.,0.09970222994544457,0.8022563457489014
py_12403,Python,"def count_vars(self) -> int:
        """""" Count var define by this scope """"""
        n = 0
        for s in self._hsig.values():
            if hasattr(s, 'is_var') and s.is_var:
                n += 1
        return n",Count var define by this scope,Count var define by this scope,No Error,False,The documentation accurately describes what the source code does.,1.0,1.0
py_2582,Python,"def _define(self):
        """"""Calculate a subcircuit that implements this initialization

        Implements a recursive initialization algorithm, including optimizations,
        from ""Synthesis of Quantum Logic Circuits"" Shende, Bullock, Markov
        https://arxiv.org/abs/quant-ph/0406176v5

        Additionally implements some extra optimizations: remove zero rotations and
        double cnots.
        """"""
        # call to generate the circuit that takes the desired vector to zero
        disentangling_circuit = self.gates_to_uncompute()

        # invert the circuit to create the desired vector from zero (assuming
        # the qubits are in the zero state)
        initialize_instr = disentangling_circuit.to_instruction().inverse()

        q = QuantumRegister(self.num_qubits, 'q')
        initialize_circuit = QuantumCircuit(q, name='init_def')
        for qubit in q:
            initialize_circuit.append(Reset(), [qubit])
        initialize_circuit.append(initialize_instr, q[:])

        self.definition = initialize_circuit.data","Calculate a subcircuit that implements a quantum initialization algorithm by recursively uncomputing gates. This algorithm includes optimizations from the paper ""Synthesis of Quantum Logic Circuits"" by Shende, Bullock, Markov. Additional optimizations involve removing zero rotations and double CNOT gates.","Calculate a subcircuit that implements this initialization

        Implements a recursive initialization algorithm, including optimizations,
        from ""Synthesis of Quantum Logic Circuits"" Shende, Bullock, Markov
        https://arxiv.org/abs/quant-ph/0406176v5

        Additionally implements some extra optimizations: remove zero rotations and
        double cnots.",No Error,False,"The documentation correctly describes the code's function without any fabricated variables, wrong logic, omissions, or irrelevant information.",0.260711748598298,0.848166823387146
cob_real_3171,COBOL,"000001 PROCESS DEFINE(A=B'1'),DEFINE(B=B'0')                            00000001
000002 ID Division.                                                     00000002
000003 Program-ID. testantlr351.                                        00000003
000004 Procedure Division.                                              00000004
000005     >>IF A                                                       00000005
000006     CALL 'PGM0001A'                                              00000006
000007     >>END-IF                                                     00000007
000008                                                                  00000008
000009     >>IF B                                                       00000009
000010     CALL 'PGM0001B'                                              00000010
000011     >>END-IF                                                     00000011
000012                                                                  00000012
000013     >>DEFINE A B'0' OVERRIDE                                     00000013
000014     >>DEFINE B B'1' OVERRIDE                                     00000014
000015                                                                  00000015
000016     >>IF A                                                       00000016
000017     CALL 'PGM0001C'                                              00000017
000018     >>END-IF                                                     00000018
000019                                                                  00000019
000020     >>IF B                                                       00000020
000021     CALL 'PGM0001D'                                              00000021
000022     >>END-IF                                                     00000022
000023                                                                  00000023
000024     >>DEFINE A AS PARAMETER                                      00000024
000025     >>DEFINE B AS PARAMETER                      ","This COBOL code defines two variables A and B with initial values of 1 and 0 respectively. It then checks the values of A and B in a series of conditional statements using IF statements. Depending on the values of A and B, different programs ('PGM0001A', 'PGM0001B', 'PGM0001C', 'PGM0001D') are called. The code also overrides the initial values of A and B with new values (0 and 1 respectively) and then sets A and B as parameters.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,The code does not show that A and B are initially set to 1 and 0 respectively; it only shows calls to different programs based on the state of A and B.,0.004214353393030252,0.8424766659736633
py_9606,Python,"def log_params(self):
        '''Log information about this layer's parameters.'''
        total = 0
        for p in self.params:
            shape = p.get_value().shape
            util.log('parameter ""{}"" {}', p.name, shape)
            total += np.prod(shape)
        return total","Log information about this layer's parameters by iterating through each parameter to retrieve its shape and name, and calculating the total number of parameters.",Log information about this layer's parameters.,No Error,False,The generated documentation is an accurate summary of the method's functionality.,0.15415064977510756,0.910262942314148
cob_syn_8295,COBOL,"      * REFACTOR CANDIDATE BATCH_8295
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.
000110 PROGRAM-ID. PRAC07.
000120 AUTHOR. LUIS CECILIANO.
000130 DATE-WRITTEN. NOVEMBER 4, 2019.
000140*ESTE PROGRAMA UTILIZA LAS INSTRUCCIONES DE MULTIPLICACION Y SUMA
000150 SECURITY. FOREVER.
000200 ENVIRONMENT DIVISION.
000300 DATA DIVISION.
000310 WORKING-STORAGE SECTION.
000320    01 WKS-A    PIC 9(06)V9(06).
000330    01 WKS-B    PIC 9(06)V9(06).
000340    01 WKS-C    PIC 9(06)V9(06).
000350    01 WKS-D    PIC S9(06)V9(06).
000400 PROCEDURE DIVISION.
000500 0000-CONTROL.
000600    MOVE 118 TO WKS-A
000700    MOVE 117 TO WKS-B 
000800    MOVE 1   TO WKS-C
000900    MULTIPLY WKS-B BY WKS-A
001000    ADD WKS-C WKS-B GIVING WKS-D
001100    DISPLAY WKS-D
001200    STOP RUN.","This COBOL program defines variables WKS-A, WKS-B, WKS-C, and WKS-D with specific numeric pic values. It then assigns values to WKS-A, WKS-B, and WKS-C, multiplies WKS-B by WKS-A, adds WKS-C and WKS-B, and stores the result in WKS-D. Finally, it displays the value of WKS-D and stops the program execution.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation states that program adds WKS-C and WKS-B, but the code is adding WKS-C and the result of the multiplication of WKS-B and WKS-A, not WKS-B.",0.006065997938636506,0.8368304967880249
cob_syn_1717,COBOL,"      * REFACTOR CANDIDATE BATCH_1717
      * SYSTEM GENERATED
       PROCESS CICS,NODYNAM,NSYMBOL(NATIONAL),TRUNC(STD)
      * Licensed Materials - Property of IBM
      *
      * SAMPLE
      *
      * (c) Copyright IBM Corp. 2016 All Rights Reserved
      *
      * US Government Users Restricted Rights - Use, duplication or
      * disclosure restricted by GSA ADP Schedule Contract with IBM Corp
      *
      ******************************************************************
      *  CRDTCHK

      * This program is part of the CICS Credit Card Application example

      * CRDTCHK - Credit check for an account. An account number
      * is used to call an external credit check service which returns
      * a three digit crdit score.

      * This example executes a 5 second delay to simulate
      * a credit check being made via a web service to
      * an external service provider.
      *
      ******************************************************************

       IDENTIFICATION DIVISION.
        PROGRAM-ID. CRDTCHK.
        AUTHOR. GOHILPR.

       ENVIRONMENT DIVISION.

       DATA DIVISION.
        WORKING-STORAGE SECTION.

      * Input record
       1 ACCOUNT-NUMBER-IN.
         2 CUST-NO-IN PIC X(4).

       1 RETURN-DATA.
         2 CREDIT-CHECK-RESULT    PIC X(3)  VALUE '   '.

        LOCAL-STORAGE SECTION.

       1 CONTAINER-NAMES.
         2 INPUT-CONTAINER    PIC X(16) VALUE 'INPUTCONTAINER  '.
         2 CRDTCHK-CONTAINER  PIC X(16) VALUE 'CREDITCHECKCONT '.

       1 PROG-NAMES.
         2 CREDIT-CHECK       PIC X(8) VALUE 'CRDTCHK '.

       1 COMMAND-RESP  PIC S9(8) COMP.
       1 COMMAND-RESP2 PIC S9(8) COMP.

        LINKAGE SECTION.


       PROCEDURE DIVISION .

       MAINLINE SECTION.

      * Get the input account number

           EXEC CICS GET CONTAINER ( INPUT-CONTAINER )
                           INTO    ( ACCOUNT-NUMBER-IN )
                           RESP    ( COMMAND-RESP )
                           RESP2   ( COMMAND-RESP","This COBOL program, named CRDTCHK, is part of the CICS Credit Card Application example. It performs a credit check for an account by calling an external credit check service using an account number and retrieving a three-digit credit score. The program includes a 5-second delay to simulate the credit check being made via a web service to an external provider. The code retrieves the input account number from a container and stores the credit check result in another container.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the purpose and operation of the source code.,0.004123736633351873,0.8530871868133545
cob_syn_1385,COBOL,"      * REFACTOR CANDIDATE BATCH_1385
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. WORKINGSTORAGESTRINGSUBLEVEL.
      *
      *
       ENVIRONMENT DIVISION.
      * 
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  PROGRAMNATIVE.
        05       STRING                   PIC X(5).
         10      STRING1                  PIC X.
         10      STRING234                PIC X(3).
         10      STRING5                  PIC X.
       LINKAGE SECTION.
      *
       PROCEDURE DIVISION.
      *
       MAIN SECTION.
      *
           MOVE ""12345"" TO STRING.
           DISPLAY STRING.
           DISPLAY STRING1.
           DISPLAY STRING234.
           DISPLAY STRING5.

           MOVE ""X"" TO STRING1
           DISPLAY STRING.

           MOVE ""Y"" TO STRING234.
           DISPLAY STRING.

           MOVE ""AB"" TO STRING1.
           DISPLAY STRING.
      *
       PROG-EX.
           EXIT PROGRAM.
      *
       END PROGRAM WORKINGSTORAGESTRINGSUBLEVEL.
","This COBOL program defines a working storage section containing variables to store strings of specific lengths. It then displays the values of these strings after assigning various values to them. The program demonstrates how to manipulate and display string variables in COBOL. Finally, it exits the program once all string operations are completed.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention that variable ""PROGRAMNATIVE"" is declared but never used in the program.",0.005776163584689931,0.8637956380844116
cob_syn_10132,COBOL,"      * REFACTOR CANDIDATE BATCH_10132
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. DATADESCR01.
 DATA DIVISION.
 LOCAL-STORAGE SECTION.
 LD SOMELD.
 01 ITEMS.
    02 ITEM1 PIC X(10).
    02 ITEM2 PIC X(10).","Defines a COBOL program named DATADESCR01 and declares two variables ITEM1 and ITEM2, each with a length of 10 characters. The program includes a local-storage section and a variable SOMELD.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the given source code.,0.0092991042878441,0.8494671583175659
cob_syn_9354,COBOL,"      * REFACTOR CANDIDATE BATCH_9354
      * SYSTEM GENERATED
      * Copyright (c) 2020 Broadcom.                                 *
      * The term ""Broadcom"" refers to Broadcom Inc. and/or its       *
      * subsidiaries.                                                *
      *                                                              *
      * This program and the accompanying materials are made         *
      * available under the terms of the Eclipse Public License 2.0  *
      * which is available at https://www.eclipse.org/legal/epl-2.0/ *
      *                                                              *
      * SPDX-License-Identifier: EPL-2.0                             *
      *                                                              *
      * Contributors:                                                *
      *   Broadcom, Inc. - initial API and implementation            *
      ****************************************************************
       Identification Division.
       Program-id. HELLO-WORLD.

       Data Division.
       Working-Storage Section.
           01 User-Num1 PIC 9(9).
           01 User-Num2 PIC 9(9).
           01 User-Address.
           05 User-City PIC X(5).
           05 User-Country PIC X(5).
           05 User-Index PIC 9(6).
           05 User-Phone PIC 9(6).

       Procedure Division.
        000-Main-Logic.
           Perform 100-Print-User.
           Stop Run.

        100-Print-User.
           Move 123456789 To User-Num1.
           Move User-Num1 To User-Num2.
           Move 'Wenceslav Square 846/1' To User-Address.
           Move 'Prague' To User-City.
           Move 'CZ' To User-Country.
           Move 11000 To User-Index.
           Move 777123456 To User-Phone.

           Display ""User-Num1     : "" User-Num1.
           Display ""User-Num2     : "" User-Num2.
           Display ""User-Address  : "" User-Address.
           Display ""User-City     : "" User-City.
           Display ""User-Country  : "" User-Country.
           Display ""User-Index    : "" User-","This COBOL program defines data fields for user information such as numbers, address, city, country, index, and phone. It contains a main logic section that calls a subroutine to print the user information on the screen. The subroutine initializes the user fields with sample data and displays them using the DISPLAY statement. This program essentially demonstrates how to store and display user information in a COBOL program.",Legacy COBOL logic requiring documentation.,Omission,True,Documentation failed to mention the initial hard-coded values that are being moved to the user fields.,0.00563777415489041,0.8581541776657104
py_11850,Python,"def _read_varint(self):
        """"""Read a varint from file, parse it, and return the decoded integer.
        """"""
        buff = self._fd.read(1)
        if buff == b'':
            return 0

        while (bytearray(buff)[-1] & 0x80) >> 7 == 1:  # while the MSB is 1
            new_byte = self._fd.read(1)
            if new_byte == b'':
                raise EOFError('unexpected EOF.')
            buff += new_byte

        varint, _ = decodeVarint(buff, 0)

        return varint","Read a varint from file, parse it, and return the decoded integer.","Read a varint from file, parse it, and return the decoded integer.",Omission,True,The documentation does not include information about the potential raising of an EOFError in case the read file unexpectedly ends.,1.0,0.9999999403953552
cob_syn_36,COBOL,"      * REFACTOR CANDIDATE BATCH_36
      * SYSTEM GENERATED
""hello"" = ""hello""   *> equality
""helloo"" <> ""hello"" *> inequality
""aello"" < ""hello""   *> lexical ordering
","This COBOL code contains comments showing examples of string comparisons using different operators such as equality, inequality, and lexical ordering. The examples compare strings ""hello"" and ""helloo"", ""hello"" and ""aello"", and ""hello"" and ""hello"" to demonstrate the results of each type of comparison operation.",Legacy COBOL logic requiring documentation.,No Error,False,"The documentation matches the provided code, summarizing the string comparisons accurately with no hallucinations or omissions.",0.0067525623389387635,0.8592488765716553
py_6300,Python,"def from_file(path):
    """"""
    Returns an AudioSegment object from the given file based on its file extension.
    If the extension is wrong, this will throw some sort of error.

    :param path: The path to the file, including the file extension.
    :returns: An AudioSegment instance from the file.
    """"""
    _name, ext = os.path.splitext(path)
    ext = ext.lower()[1:]
    seg = pydub.AudioSegment.from_file(path, ext)
    return AudioSegment(seg, path)","""""""
Returns an AudioSegment object from the given file based on its file extension.
If the extension is wrong, this will throw some sort of error.

:param path: The path to the file, including the file extension.
:returns: An AudioSegment instance from the file.
""""""","Returns an AudioSegment object from the given file based on its file extension.
    If the extension is wrong, this will throw some sort of error.

    :param path: The path to the file, including the file extension.
    :returns: An AudioSegment instance from the file.",No Error,False,The provided documentation correctly and comprehensively explains what the function does without claiming unsupported actions or omitting essential information.,0.9539918498375323,0.9496746063232422
cob_syn_4205,COBOL,"      * REFACTOR CANDIDATE BATCH_4205
      * SYSTEM GENERATED
      *****************************************************************
      ** THIS PROGRAM IS A SAMPLE CICS CLIENT FOR DEMONSTRATING A 3270*
      ** APPLICATION THAT READS AND WRITE TO A VSAM DATA SET FOR      *
      ** BANKING TYPE OF INFORMATION.                                 *
      **                                                              *
      ** THE INPUT TO THIS CICS PROGRAM IS PROVIDED THROUGH A BMS MAP *
      ** THAT IS NAMED WGRVMAP.                                       *
      *****************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. WGRVADDC.
       ENVIRONMENT DIVISION.

       DATA DIVISION.

      *****************************************************************
      ** VARIABLES FOR INTERACTING WITH THE TERMINAL SESSION          *
      *****************************************************************
       WORKING-STORAGE SECTION.

       01 CUST-REC-KEY.
           05 NAME                        PIC X(30)  VALUE SPACES.

       01  CUSTOMER-RECORD.
           05 CUSTOMER-NAME               PIC X(30).
           05 CUSTOMER-SSN                PIC X(9).
           05 CUSTOMER-ADDRESS.
              10 CUSTOMER-STREET          PIC X(20).
              10 CUSTOMER-CITY            PIC X(10).
              10 CUSTOMER-STATE           PIC X(4).
              10 CUSTOMER-ZIP             PIC 9(5).
           05 CUSTOMER-PHONE              PIC X(13).
           05 CUSTOMER-ACCESS-PIN         PIC X(4).

       01 ACCT-REC-KEY.
           05 SSN                         PIC X(9)   VALUE SPACES.
           05 NUM                         PIC X(10)  VALUE SPACES.

       01  ACCOUNT-RECORD.
           05 ACCOUNT-SSN                 PIC X(9).
           05 ACCOUNT-NUMBER              PIC X(10).
           05 ACCOUNT-TYPE.
              10 ACCOUNT-TYPE-CODE        PIC X.
                 88 ACCOUNT-TYPE-CHK            VALUE 'C'.
                 88 ACCOUNT-TYPE-SAV            VALUE 'S'.
  ","This COBOL program is a sample CICS client for demonstrating a 3270 application that reads and writes to a VSAM data set containing banking information. The program interacts with a terminal session using a BMS map named WGRVMAP. It defines data structures for customer and account records, including fields for name, SSN, address, phone, access pin, account number, account type, and related information.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the function and structure of the code.,0.0049936829345510496,0.8466443419456482
py_2279,Python,"def axis_sort(S, axis=-1, index=False, value=None):
    '''Sort an array along its rows or columns.

    Examples
    --------
    Visualize NMF output for a spectrogram S

    >>> # Sort the columns of W by peak frequency bin
    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> S = np.abs(librosa.stft(y))
    >>> W, H = librosa.decompose.decompose(S, n_components=32)
    >>> W_sort = librosa.util.axis_sort(W)

    Or sort by the lowest frequency bin

    >>> W_sort = librosa.util.axis_sort(W, value=np.argmin)

    Or sort the rows instead of the columns

    >>> W_sort_rows = librosa.util.axis_sort(W, axis=0)

    Get the sorting index also, and use it to permute the rows of H

    >>> W_sort, idx = librosa.util.axis_sort(W, index=True)
    >>> H_sort = H[idx, :]

    >>> import matplotlib.pyplot as plt
    >>> plt.figure()
    >>> plt.subplot(2, 2, 1)
    >>> librosa.display.specshow(librosa.amplitude_to_db(W, ref=np.max),
    ...                          y_axis='log')
    >>> plt.title('W')
    >>> plt.subplot(2, 2, 2)
    >>> librosa.display.specshow(H, x_axis='time')
    >>> plt.title('H')
    >>> plt.subplot(2, 2, 3)
    >>> librosa.display.specshow(librosa.amplitude_to_db(W_sort,
    ...                                                  ref=np.max),
    ...                          y_axis='log')
    >>> plt.title('W sorted')
    >>> plt.subplot(2, 2, 4)
    >>> librosa.display.specshow(H_sort, x_axis='time')
    >>> plt.title('H sorted')
    >>> plt.tight_layout()


    Parameters
    ----------
    S : np.ndarray [shape=(d, n)]
        Array to be sorted

    axis : int [scalar]
        The axis along which to compute the sorting values

        - `axis=0` to sort rows by peak column index
        - `axis=1` to sort columns by peak row index

    index : boolean [scalar]
        If true, returns the index array as well as the permuted data.

    value : function
        function to return the index corresponding to the sort order.
        Default: `np.argmax`.

    Returns
    -------
    S_sort : np.ndarray [shape=(d, n)]
        `S` with the columns or rows permuted in sorting order

    idx : np.ndarray (optional) [shape=(d,) or (n,)]
        If `index == True`, the sorting index used to permute `S`.
        Length of `idx` corresponds to the selected `axis`.

    Raises
    ------
    ParameterError
        If `S` does not have exactly 2 dimensions (`S.ndim != 2`)
    '''

    if value is None:
        value = np.argmax

    if S.ndim != 2:
        raise ParameterError('axis_sort is only defined for 2D arrays')

    bin_idx = value(S, axis=np.mod(1-axis, S.ndim))
    idx = np.argsort(bin_idx)

    sort_slice = [slice(None)] * S.ndim
    sort_slice[axis] = idx

    if index:
        return S[tuple(sort_slice)], idx
    else:
        return S[tuple(sort_slice)]","'''Sort an array along its rows or columns.

    Examples
    --------
    Visualize NMF output for a spectrogram S

    >>> # Sort the columns of W by peak frequency bin
    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> S = np.abs(librosa.stft(y))
    >>> W, H = librosa.decompose.decompose(S, n_components=32)
    >>> W_sort = librosa.util.axis_sort(W)

    Or sort by the lowest frequency bin

    >>> W_sort = librosa.util.axis_sort(W, value=np.argmin)

    Or sort the rows instead of the columns

    >>> W_sort_rows = librosa.util.axis_sort(W, axis=0)

    Get the sorting index also, and use it to permute the rows of H

    >>> W_sort, idx = librosa.util.axis_sort(W, index=True)
    >>> H_sort = H[idx, :]

    >>> import matplotlib.pyplot as plt
    >>> plt.figure()
    >>> plt.subplot(2, 2, 1)
    >>> librosa.display.specshow(librosa.amplitude_to_db(W, ref=np.max),
    ...                          y_axis='log')
    >>> plt.title('W')
    >>> plt.subplot(2, 2, 2)
    >>> librosa.display.specshow(H, x_axis='time')
    >>> plt.title('H')
    >>> plt.subplot(2, 2, 3)
    >>> librosa.display.specshow(librosa.amplitude_to_db(W_sort,
    ...                                                  ref=np.max),
    ...                          y_axis='log')
    >>> plt.title('W sorted')
    >>> plt.subplot(2, 2, 4)
    >>> librosa.display.specshow(H_sort, x_axis='time')
    >>> plt.title('H sorted')
    >>> plt.tight_layout()


    Parameters
    ----------
    S : np.ndarray [shape=(d, n)]
        Array to be sorted

    axis : int [scalar]
        The axis along which to compute the sorting values

        - `axis=0` to sort rows by peak column index
        - `axis=1` to sort columns by peak row index

    index : boolean [scalar]
        If true, returns the index array as well as the permuted data.

    value : function
        function to return the index corresponding to the sort order.
        Default: `np.argmax`.

    Returns
    -------
    S_sort : np.ndarray [shape=(d, n)]
        `S` with the columns or rows permuted in sorting order

    idx : np.ndarray (optional) [shape=(d,) or (n,)]
        If `index == True`, the sorting index used to permute `S`.
        Length of `idx` corresponds to the selected `axis`.

    Raises
    ------
    ParameterError
        If `S` does not have exactly 2 dimensions (`S.ndim != 2`)
    '''","Sort an array along its rows or columns.

    Examples
    --------
    Visualize NMF output for a spectrogram S

    >>> # Sort the columns of W by peak frequency bin
    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> S = np.abs(librosa.stft(y))
    >>> W, H = librosa.decompose.decompose(S, n_components=32)
    >>> W_sort = librosa.util.axis_sort(W)

    Or sort by the lowest frequency bin

    >>> W_sort = librosa.util.axis_sort(W, value=np.argmin)

    Or sort the rows instead of the columns

    >>> W_sort_rows = librosa.util.axis_sort(W, axis=0)

    Get the sorting index also, and use it to permute the rows of H

    >>> W_sort, idx = librosa.util.axis_sort(W, index=True)
    >>> H_sort = H[idx, :]

    >>> import matplotlib.pyplot as plt
    >>> plt.figure()
    >>> plt.subplot(2, 2, 1)
    >>> librosa.display.specshow(librosa.amplitude_to_db(W, ref=np.max),
    ...                          y_axis='log')
    >>> plt.title('W')
    >>> plt.subplot(2, 2, 2)
    >>> librosa.display.specshow(H, x_axis='time')
    >>> plt.title('H')
    >>> plt.subplot(2, 2, 3)
    >>> librosa.display.specshow(librosa.amplitude_to_db(W_sort,
    ...                                                  ref=np.max),
    ...                          y_axis='log')
    >>> plt.title('W sorted')
    >>> plt.subplot(2, 2, 4)
    >>> librosa.display.specshow(H_sort, x_axis='time')
    >>> plt.title('H sorted')
    >>> plt.tight_layout()


    Parameters
    ----------
    S : np.ndarray [shape=(d, n)]
        Array to be sorted

    axis : int [scalar]
        The axis along which to compute the sorting values

        - `axis=0` to sort rows by peak column index
        - `axis=1` to sort columns by peak row index

    index : boolean [scalar]
        If true, returns the index array as well as the permuted data.

    value : function
        function to return the index corresponding to the sort order.
        Default: `np.argmax`.

    Returns
    -------
    S_sort : np.ndarray [shape=(d, n)]
        `S` with the columns or rows permuted in sorting order

    idx : np.ndarray (optional) [shape=(d,) or (n,)]
        If `index == True`, the sorting index used to permute `S`.
        Length of `idx` corresponds to the selected `axis`.

    Raises
    ------
    ParameterError
        If `S` does not have exactly 2 dimensions (`S.ndim != 2`)",No Error,False,The documentation precisely and accurately explains the source code with no signs of hallucinations or omissions.,0.9928185552976438,0.9914655685424805
py_1501,Python,"def _prepare_data_payload(data):
        """"""
        Make a copy of the `data` object, preparing it to be sent to the server.

        The data will be sent via x-www-form-urlencoded or multipart/form-data mechanisms. Both of them work with
        plain lists of key/value pairs, so this method converts the data into such format.
        """"""
        if not data: return None
        res = {}
        for key, value in viewitems(data):
            if value is None: continue  # don't send args set to None so backend defaults take precedence
            if isinstance(value, list):
                value = stringify_list(value)
            elif isinstance(value, dict):
                if ""__meta"" in value and value[""__meta""][""schema_name""].endswith(""KeyV3""):
                    value = value[""name""]
                else:
                    value = stringify_dict(value)
            else:
                value = str(value)
            res[key] = value
        return res","Make a copy of the `data` object, preparing it to be sent to the server.

The data will be sent via x-www-form-urlencoded or multipart/form-data mechanisms. Both of them work with
plain lists of key/value pairs, so this method converts the data into such format.","Make a copy of the `data` object, preparing it to be sent to the server.

        The data will be sent via x-www-form-urlencoded or multipart/form-data mechanisms. Both of them work with
        plain lists of key/value pairs, so this method converts the data into such format.",No Error,False,The documentation accurately represents the function's purpose and logic.,1.0,0.9560283422470093
cob_syn_2786,COBOL,"      * REFACTOR CANDIDATE BATCH_2786
      * SYSTEM GENERATED
       Identification Division.
       Program-ID. testantlr021.
       Data Division.
       Working-Storage Section.

       REPLACE 
         =='PGMA0001'== BY =='PGMB0001'==
         =='PGMA0002'== BY =='PGMB0002'==
         .

      *
      *comment
      *

       01  CONSTANTS.
           05  MYNAME               PIC X(012) VALUE 'testantlr021'.
           05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.
           05  PGM-0002             PIC X(008) VALUE 'PGMA0002'.
           05  PGM-0003             PIC X(008) VALUE 'PGMA0003'.

      *

       REPLACE OFF
       .


       Procedure Division.
           DISPLAY MYNAME ' Begin'
           
           CALL PGM-0001 USING MYNAME

           DISPLAY MYNAME ' End'
           
           GOBACK
           .


","This COBOL code defines constants MYNAME, PGM-0001, PGM-0002, and PGM-0003 with specific values. It includes a replacement section to replace certain strings in the code. The Procedure Division displays 'MYNAME Begin', calls a program using PGM-0001 as a parameter, displays 'MYNAME End', and then terminates the program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the given COBOL source code.,0.006389329974674238,0.8520528078079224
py_7467,Python,"def observations(store, loqusdb, case_obj, variant_obj):
    """"""Query observations for a variant.""""""
    composite_id = (""{this[chromosome]}_{this[position]}_{this[reference]}_""
                    ""{this[alternative]}"".format(this=variant_obj))
    obs_data = loqusdb.get_variant({'_id': composite_id}) or {}
    obs_data['total'] = loqusdb.case_count()

    obs_data['cases'] = []
    institute_id = variant_obj['institute']
    for case_id in obs_data.get('families', []):
        if case_id != variant_obj['case_id'] and case_id.startswith(institute_id):
            other_variant = store.variant(variant_obj['variant_id'], case_id=case_id)
            other_case = store.case(case_id)
            obs_data['cases'].append(dict(case=other_case, variant=other_variant))

    return obs_data",Query observations for a variant.,Query observations for a variant.,No Error,False,The documentation correctly matches the source code functionality.,1.0,1.0000001192092896
cob_syn_6449,COBOL,"      * REFACTOR CANDIDATE BATCH_6449
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. ANDPROG.
      *
      *
       ENVIRONMENT DIVISION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 STRING1 PIC X VALUE ""A"".
        88 VALUEA VALUE ""A"".
       LINKAGE SECTION.
      *
       PROCEDURE DIVISION.
      *
       MAIN SECTION.
      *
        DISPLAY STRING1.
        IF ""A"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""B""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.

        IF ""A"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""C""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.

        IF ""B"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""B""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.

        IF ""B"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""C""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.

        IF ""B"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""B"" AND ""C"" EQUAL ""C""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.

        IF ""B"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""C""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.

        IF ""B"" EQUAL STRING1 AND ""A"" EQUAL ""A"" OR ""B"" EQUAL ""B"" AND ""C"" EQUAL ""B""
        THEN
           DISPLAY ""TRUE""
        ELSE
           DISPLAY ""FALSE""
        END-IF.
      *
       PROG-EX.
           EXIT PROGRAM.
      *
       END PROGRAM ANDPROG.
","This COBOL code defines a program that compares the value of a variable `STRING1` with hardcoded values ""A"" and ""B"". The program then displays ""TRUE"" if specific conditions are met, otherwise it displays ""FALSE"". The conditions involve logical AND and OR operations between the hardcoded values and the variable `STRING1`. Finally, the program exits after performing the comparisons.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly outlines the basic operations performed by the COBOL program.,0.005354194904142114,0.853986382484436
py_9482,Python,"def load_filters():
    """"""
    Loads and returns all filters.
    """"""
    all_filters = {}
    for m in JINJA_FILTERS:
        if hasattr(m, ""filters""):
            all_filters.update(m.filters())
    return all_filters","Loads and returns all filters by iterating over a list of filters defined in JINJA_FILTERS, checking if each module has a ""filters"" attribute, and updating the dictionary ""all_filters"" with the filters returned by each module's ""filters"" method.",Loads and returns all filters.,No Error,False,The generated documentation accurately reflects the operations of the source code.,0.06237923061531353,0.8895564079284668
py_2614,Python,"def _get_statevector(self):
        """"""Return the current statevector in JSON Result spec format""""""
        vec = np.reshape(self._statevector, 2 ** self._number_of_qubits)
        # Expand complex numbers
        vec = np.stack([vec.real, vec.imag], axis=1)
        # Truncate small values
        vec[abs(vec) < self._chop_threshold] = 0.0
        return vec","Return the current statevector in JSON Result spec format. Reshapes the statevector, expands complex numbers, truncates small values, and returns the processed statevector.",Return the current statevector in JSON Result spec format,No Error,False,"The documentation accurately summarizes the functionality of the code, with no unrepresented claims or omissions of critical information.",0.2981792160679168,0.9146830439567566
cob_syn_9145,COBOL,"      * REFACTOR CANDIDATE BATCH_9145
      * SYSTEM GENERATED
000100 01  ORDER-ROOT-DATA.                                             00010000
000200     05 ORDER-ROOT-KEY.                                           00020000
000300         07 ORDER-NUMBER-PREFIX      PIC  X(02).                  00030000
000400         07 ORDER-NUMBER             PIC  9(04).                  00040000
000500     05  ORDKEY-REDEF  REDEFINES    ORDER-ROOT-KEY                00050000
000600                                     PIC  X(06).                  00060001
000700     05 ORDER-DESCRIPTION            PIC  X(40).                  00070001
000800     05 CUSTOMER-NUMBER              PIC  X(06).                  00080001
000900     05 PLANNED-ORDER-QUANTITY       PIC  S9(05)       COMP-3.    00090001
001000     05 PLANNED-ORDER-AMOUNT         PIC  9(05)V99     COMP-3.    00100001
001100     05 ORDER-TYPE                   PIC  X(02).                  00110001
001200     05 ACTUAL-ORDER-QUANTITY        PIC  S9(05)       COMP-3.    00120001
001300     05 TOTAL-SCRAP-QUANTITY         PIC  S9(05)       COMP-3.    00130001
001400     05 TOTAL-SCRAP-REDEFINES                                     00140002
001500         REDEFINES TOTAL-SCRAP-QUANTITY PIC  X(03).               00150002
001600     05 ORDER-STATUS                 PIC  9(02).                  00160001
001700     05 FILLER                       PIC  X(01).                  00170001
001800     05 FIRST-ACTIVITY-DATE.                                      00180000
001900         07 FIRST-ACTIVITY-DATE-YR   PIC  X(04).                  00190000
002000         07 FIRST-ACTIVITY-DATE-MM   PIC  X(02).                  00200000
002100         07 FIRST-ACTIVITY-DATE-DD   PIC  X(02).                  00210000
002200     05 LAST-ACTIVITY-DATE           PIC  X(08).                  00220001
002300     05 WEEKLY-STATUS-DATA OCCURS       5 TIMES.                  00230003
002400         07 NUMBER-UNITS-STARTED     PIC  9(05)        COMP-3.    00240000
002500         07 NUMBER-UNITS-C","This COBOL code defines a data structure `ORDER-ROOT-DATA` containing various fields related to an order, such as order number, description, customer number, planned order quantity and amount, order type, actual and total scrap quantities, order status, activity dates, and weekly status data. The structure also includes redefines and occurs clauses for organizing and accessing the data efficiently in a batch processing system.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the source code contents and there are no hallucinations or omissions.,0.0050615410611162615,0.8520772457122803
py_7628,Python,"def templated(template=None):
    """"""Template decorator.

    Ref: http://flask.pocoo.org/docs/patterns/viewdecorators/
    """"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            template_name = template
            if template_name is None:
                template_name = request.endpoint.replace('.', '/') + '.html'
            context = f(*args, **kwargs)
            if context is None:
                context = {}
            elif not isinstance(context, dict):
                return context
            return render_template(template_name, **context)
        return decorated_function
    return decorator","Template decorator.

Ref: http://flask.pocoo.org/docs/patterns/viewdecorators/","Template decorator.

    Ref: http://flask.pocoo.org/docs/patterns/viewdecorators/",No Error,False,"The documentation accurately represents the function of the code, with no unsupported claims or missing information.",1.0,0.971350908279419
cob_syn_9510,COBOL,"      * REFACTOR CANDIDATE BATCH_9510
      * SYSTEM GENERATED
       PROCESS NODLL,NODYNAM,TEST(NOSEP),NOCICS,NOSQL,PGMN(LU)
      *+---------------------------------------------------------------+
      *| Tlgicus0                                                      |
      *| PRODUCT: IBM DEVELOPER FOR Z/OS                               |
      *| COMPONENT: IBM Z/OS AUTOMATED UNIT TESTING FRAMEWORK (ZUNIT)  |
      *|   FOR ENTERPRISE COBOL AND PL/I                               |
      *| PROGRAM: ENTERPRISE COBOL ZUNIT TEST CASE FOR DYNAMIC RUNNER  |
      *| DATE GENERATED: 12/17/2020 15:23                              |
      *| ID: 4f15eed0-f15b-4f39-8561-7d6690a8882d                      |
      *+---------------------------------------------------------------+
      *+---------------------------------------------------------------+
      *| TEST_TEST3                                                    |
      *|     THIS PROGRAM IS FOR TEST TEST3                            |
      *+---------------------------------------------------------------+
       IDENTIFICATION DIVISION.
       PROGRAM-ID. 'TEST_TEST3'.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 PROGRAM-NAME   PIC X(8)  VALUE 'LGICUS01'.
       01 BZ-ASSERT.
         03 MESSAGE-LEN PIC S9(4) COMP-4 VALUE 24.
         03 MESSAGE-TXT PIC X(254) VALUE 'HELLO FROM TEST CALLBACK'.
       01  BZ-P1 PIC S9(9) COMP-4 VALUE 4.
       01  BZ-P2 PIC S9(9) COMP-4 VALUE 2001.
       01  BZ-P3 PIC X(3) VALUE 'AZU'.
       01 BZ-TRACE.
         03 TRACE-LEN       PIC S9(4) COMP-4 VALUE 5.
         03 TRACE-TXT       PIC X(254) VALUE 'TRACE'.
       01 BZUASSRT          PIC X(8) VALUE 'BZUASSRT'.
       01 BZUTRACE          PIC X(8) VALUE 'BZUTRACE'.
       01 AZ-TRACE-PTR      POINTER.
       01 ASSERT-ST.
         03 ASSERT-RC PIC 9(9) BINARY VALUE 4.
         03 ASSERT-TEXT PIC 9(4) BINARY VALUE 0.
       01 AZ-TEST-NAME-LEN       PIC S9(9) COMP-5.
       1 AZ-TEST-EXPECTED-DATA-VALUE.
          3 ZUT00000000.
            5 PIC X(6) DISPLAY VALUE '01I","This COBOL code defines a test program 'TEST_TEST3' for a dynamic runner in the IBM Z/OS Automated Unit Testing Framework (ZUnit). It includes working storage sections with variables for program name, assertion messages, parameters, tracing, test names, and expected data values. The program sets default values for these variables and initializes them for testing purposes.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not note the program ID and there is no mention of the values that each variable is assigned.,0.005598996258250374,0.8526121377944946
py_3309,Python,"def pull_requested_reviewers(self, pr_number):
        """"""Get pull requested reviewers""""""

        requested_reviewers_url = urijoin(""pulls"", str(pr_number), ""requested_reviewers"")
        return self.fetch_items(requested_reviewers_url, {})",Get pull requested reviewers,Get pull requested reviewers,No Error,False,The documentation accurately describes the function of the code without any hallucinations or omissions.,1.0,1.0
py_12455,Python,"def end_tag(self, name: str) -> Node:
        """"""Extract the string between saved and current index.""""""
        self.tag_cache[name].set_end(self._stream.index)
        return True",Extract the string between saved and current index.,Extract the string between saved and current index.,Wrong Logic,True,"The function appears to be setting an end point for a tag in a cache, not extracting a string between saved and current index.",1.0,1.0000001192092896
py_9108,Python,"def _bound_waveform(wave, indep_min, indep_max):
    """"""Add independent variable vector bounds if they are not in vector.""""""
    indep_min, indep_max = _validate_min_max(wave, indep_min, indep_max)
    indep_vector = copy.copy(wave._indep_vector)
    if (
        isinstance(indep_min, float) or isinstance(indep_max, float)
    ) and indep_vector.dtype.name.startswith(""int""):
        indep_vector = indep_vector.astype(float)
    min_pos = np.searchsorted(indep_vector, indep_min)
    if not np.isclose(indep_min, indep_vector[min_pos], FP_RTOL, FP_ATOL):
        indep_vector = np.insert(indep_vector, min_pos, indep_min)
    max_pos = np.searchsorted(indep_vector, indep_max)
    if not np.isclose(indep_max, indep_vector[max_pos], FP_RTOL, FP_ATOL):
        indep_vector = np.insert(indep_vector, max_pos, indep_max)
    dep_vector = _interp_dep_vector(wave, indep_vector)
    wave._indep_vector = indep_vector[min_pos : max_pos + 1]
    wave._dep_vector = dep_vector[min_pos : max_pos + 1]",Add independent variable vector bounds if they are not in the vector.,Add independent variable vector bounds if they are not in vector.,Omission,True,"The documentation does not detail the parameters of the function and their expected input, nor the internal logic and return value.",0.8265168183793802,0.9876012206077576
py_14857,Python,"def start(self):
        """"""Start collecting trace information.""""""
        if self._collectors:
            self._collectors[-1].pause()
        self._collectors.append(self)
        #print(""Started: %r"" % self._collectors, file=sys.stderr)

        # Check to see whether we had a fullcoverage tracer installed.
        traces0 = []
        if hasattr(sys, ""gettrace""):
            fn0 = sys.gettrace()
            if fn0:
                tracer0 = getattr(fn0, '__self__', None)
                if tracer0:
                    traces0 = getattr(tracer0, 'traces', [])

        # Install the tracer on this thread.
        fn = self._start_tracer()

        for args in traces0:
            (frame, event, arg), lineno = args
            try:
                fn(frame, event, arg, lineno=lineno)
            except TypeError:
                raise Exception(
                    ""fullcoverage must be run with the C trace function.""
                )

        # Install our installation tracer in threading, to jump start other
        # threads.
        threading.settrace(self._installation_trace)","Start collecting trace information, install the tracer on the current thread, and jump start other threads by installing the installation tracer in the threading module. This code also checks for the existence of a full-coverage tracer and handles exceptions related to it.",Start collecting trace information.,Omission,True,The documentation fails to mention the handling of exceptions related to the type of the trace function.,0.03022724762539571,0.884562611579895
cob_syn_1948,COBOL,"      * REFACTOR CANDIDATE BATCH_1948
      * SYSTEM GENERATED
       >>SOURCE FORMAT IS FREE
IDENTIFICATION DIVISION.
PROGRAM-ID. MAKE-TAPE-FILE.

ENVIRONMENT DIVISION.
INPUT-OUTPUT SECTION.
FILE-CONTROL.
    SELECT TAPE-FILE
        ASSIGN ""./TAPE.FILE""
        ORGANIZATION IS LINE SEQUENTIAL.

DATA DIVISION.
FILE SECTION.
FD TAPE-FILE.
01 TAPE-FILE-RECORD PIC X(51).

PROCEDURE DIVISION.
    OPEN OUTPUT SHARING WITH ALL OTHER TAPE-FILE
    WRITE TAPE-FILE-RECORD
        FROM ""COBOL treats tape files and text files identically.""
    END-WRITE
    STOP RUN.
","This COBOL program creates a tape file named ""TAPE.FILE"" and writes a single record to it with the content ""COBOL treats tape files and text files identically."" The program then stops execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the functionality of the source code.,0.008811835296733616,0.8648325800895691
cob_syn_8450,COBOL,"      * REFACTOR CANDIDATE BATCH_8450
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
      *
       PROGRAM-ID.  CUSTMNT2.
      *
       ENVIRONMENT DIVISION.
      *
       DATA DIVISION.
      *
       WORKING-STORAGE SECTION.
      *
       01  SWITCHES.
      *
           05  VALID-DATA-SW                 PIC X(01) VALUE 'Y'.
               88  VALID-DATA                          VALUE 'Y'.
      *
       01  FLAGS.
      *
           05  SEND-FLAG                     PIC X(01).
               88  SEND-ERASE                       VALUE '1'.
               88  SEND-ERASE-ALARM                 VALUE '2'.
               88  SEND-DATAONLY                    VALUE '3'.
               88  SEND-DATAONLY-ALARM              VALUE '4'.
      *
       01  WORK-FIELDS.
      *
           05  RESPONSE-CODE                 PIC S9(08) COMP.
      *
       01  USER-INSTRUCTIONS.
      *
           05  ADD-INSTRUCTION               PIC X(79) VALUE
               'Type information for new customer.  Then Press Enter.'.
           05  CHANGE-INSTRUCTION            PIC X(79) VALUE
               'Type changes.  Then press Enter.'.
           05  DELETE-INSTRUCTION            PIC X(79) VALUE
               'Press Enter to delete this customer or press F12 to canc
      -        'el.'.
      *
       01  COMMUNICATION-AREA.
      *
           05  CA-CONTEXT-FLAG               PIC X(01).
               88  PROCESS-KEY-MAP                  VALUE '1'.
               88  PROCESS-ADD-CUSTOMER             VALUE '2'.
               88  PROCESS-CHANGE-CUSTOMER          VALUE '3'.
               88  PROCESS-DELETE-CUSTOMER          VALUE '4'.
           05  CA-CUSTOMER-RECORD.
               10  CA-CUSTOMER-NUMBER        PIC X(06).
               10  FILLER                    PIC X(112).
      *
       COPY CUSTMAS.
      *
       COPY MNTSET2.
      *
       COPY DFHAID.
      *
       COPY ATTR.
      *
       COPY ERRPARM.
      *
       LINKAGE SECTION.
      *
       01  DFHCOMMA","This COBOL program defines various data structures and switches related to customer maintenance operations. It includes flags for controlling the behavior of data processing, user instructions for data entry and manipulation, communication area flags for different processing contexts, and copies of other necessary program components.",Legacy COBOL logic requiring documentation.,No Error,False,The provided documentation accurately describes the key components and functionality of the source code without any hallucinations or omissions.,0.006626589205134352,0.8700677752494812
py_11954,Python,"def batch_client(self, size=512):
        # type: (int) -> BatchClient
        """"""Return a batch client with same settings of the client""""""

        batch_client = BatchClient(self.host, self.port, self.prefix, size)
        self._configure_client(batch_client)
        return batch_client","Return a batch client with the same settings as the existing client, using the specified size for batch operations.",Return a batch client with same settings of the client,No Error,False,The documentation correctly describes what the method does.,0.22537412722674852,0.9336079359054565
py_5329,Python,"def recent(self):
        """"""
        Retrieve a selection of conversations with the most recent activity, and store them in the cache.

        Each conversation is only retrieved once, so subsequent calls will retrieve older conversations.

        Returns:
            :class:`SkypeChat` list: collection of recent conversations
        """"""
        url = ""{0}/users/ME/conversations"".format(self.skype.conn.msgsHost)
        params = {""startTime"": 0,
                  ""view"": ""msnp24Equivalent"",
                  ""targetType"": ""Passport|Skype|Lync|Thread""}
        resp = self.skype.conn.syncStateCall(""GET"", url, params, auth=SkypeConnection.Auth.RegToken).json()
        chats = {}
        for json in resp.get(""conversations"", []):
            cls = SkypeSingleChat
            if ""threadProperties"" in json:
                info = self.skype.conn(""GET"", ""{0}/threads/{1}"".format(self.skype.conn.msgsHost, json.get(""id"")),
                                       auth=SkypeConnection.Auth.RegToken,
                                       params={""view"": ""msnp24Equivalent""}).json()
                json.update(info)
                cls = SkypeGroupChat
            chats[json.get(""id"")] = self.merge(cls.fromRaw(self.skype, json))
        return chats","Retrieve a selection of conversations with the most recent activity, and store them in the cache. Each conversation is only retrieved once, so subsequent calls will retrieve older conversations. Returns a list of `SkypeChat` instances representing recent conversations.","Retrieve a selection of conversations with the most recent activity, and store them in the cache.

        Each conversation is only retrieved once, so subsequent calls will retrieve older conversations.

        Returns:
            :class:`SkypeChat` list: collection of recent conversations",No Error,False,The provided documentation accurately explains the functionality of the code without any hallucinations or critical omissions.,0.7658174233209871,0.8998817205429077
py_12130,Python,"def get_host_port(server_address):
    """"""Parse the hostname and port out of the server_address.""""""
    regex = re.compile(r""^amqp://([a-zA-Z0-9.]+)(:([\d]+))?$"")
    x = regex.match(server_address)
    if not x:
        raise Exception(""Bad address syntax: %s"" % server_address)
    matches = x.groups()
    host = matches[0]
    port = int(matches[2]) if matches[2] else None
    return host, port",Parse the hostname and port out of the given server address.,Parse the hostname and port out of the server_address.,Omission,True,The documentation does not mention the specific format of the server address and the exception that will be raised if the format is incorrect.,0.6786502681586727,0.971805214881897
py_11641,Python,"def send_message(msg_type, kwds):
    """"""Do some final preprocessing and send the message.""""""
    if kwds[""file""]:
        get_body_from_file(kwds)
    kwargs = trim_args(kwds)
    send(msg_type, send_async=False, **kwargs)","""""""Do some final preprocessing and send the message.""""""",Do some final preprocessing and send the message.,Omission,True,"The documentation does not describe the function's parameters and what they do, as well as how the function uses a provided file if available.",0.6803749333171202,0.9379180669784546
py_6865,Python,"def write_data_to_file(self, file_path='', date=str(datetime.date.today()),
        organization='llnl',dict_to_write={}, name='', row_count=0):
        """"""
        Writes given dict to file.
        """"""
        exists = os.path.isfile(file_path)
        with open(file_path, 'a') as out:
            if not exists:
                out.write('date,organization,' + name + ',unique_' + name
                + ',id\n')
            sorted_dict = sorted(dict_to_write)
            for day in sorted_dict:
                day_formatted = datetime.datetime.utcfromtimestamp(
                    day ).strftime('%Y-%m-%d')
                out.write(day_formatted + ',' + organization + ','
                    + str(dict_to_write[day][0]) + ',' + str(dict_to_write[day][1])
                    + ',' + str(row_count) + '\n')
                row_count += 1",Writes given dict to file.,Writes given dict to file.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,1.0
cob_syn_3078,COBOL,"      * REFACTOR CANDIDATE BATCH_3078
      * SYSTEM GENERATED
//
// TwitterApp.cpp
//
// $Id: //poco/1.4/Net/samples/TwitterClient/src/TSAPEchoApp.cpp#1 $
//
// A very simple command-line Twitter client.
//
// Copyright (c) 2009, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the ""Software"") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include ""Poco/Util/Application.h""
#include ""Poco/Util/Option.h""
#include ""Poco/Util/OptionSet.h""
#include ""Poco/Util/HelpFormatter.h""
#include ""TSAPEcho.h""
#include <iostream>


using Poco::Util::Application;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::Util::HelpFormatter;
using Poco::Util::AbstractConfiguration;
using Poco::Util::OptionCallback;


class TSAPEchoApp: public Application
","This COBOL code file seems to be a batch file generated by a system for a Twitter client application written in C++. The file includes licensing information, copyright notices, and header information for the Twitter client application. It also imports necessary libraries and defines a class for the Twitter application.",Legacy COBOL logic requiring documentation.,Fabricated Variable,True,"The documentation falsely claims the source code is written in COBOL, whereas it is in C++.",0.006065997938636506,0.8641484975814819
py_8748,Python,"def get_grades_by_account(self, account_id, term_id):
        """"""
        Returns grade data for the given account_id and term_id.

        https://canvas.instructure.com/doc/api/analytics.html#method.analytics_api.department_grades
        """"""
        url = (""/api/v1/accounts/sis_account_id:%s/analytics/""
               ""terms/sis_term_id:%s/grades.json"") % (account_id, term_id)
        return self._get_resource(url)",Returns grade data for a specific account and term by making a request to the Canvas API's department grades endpoint.,"Returns grade data for the given account_id and term_id.

        https://canvas.instructure.com/doc/api/analytics.html#method.analytics_api.department_grades",No Error,False,The documentation accurately describes what the function does according to the provided source code.,0.13264759167412227,0.8595597743988037
cob_syn_4115,COBOL,"      * REFACTOR CANDIDATE BATCH_4115
      * SYSTEM GENERATED
000001 Identification Division.                                         00000001
000002 Program-ID. testantlr314.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005                                                                  00000005
000006 01  CONSTANTS.                                                   00000006
000007     05  MYNAME               PIC X(012) VALUE 'testantlr314'.    00000007
000008     05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.        00000008
000009                                                                  00000009
000010 Procedure Division.                                              00000010
000011     DISPLAY MYNAME ' Begin'                                      00000011
000012                                                                  00000012
000013     EXEC CICS                                                    00000013
000014          LINK                                                    00000014
000015          PROGRAM(PGM-0001)                                       00000015
000016          COMMAREA(CA-STUFF)                                      00000016
000017          COMMAREALENGTH(CA-STUFF-LEN)                            00000017
000018     END-EXEC                                                     00000018
000019                                                                  00000019
000020     DISPLAY MYNAME ' End'                                        00000020
000021                                                                  00000021
000022     GOBACK                                                       00000022
000023     .                                                            00000023
000024                                                                  00000024
000025                                                  ","This COBOL program defines constants for MYNAME and PGM-0001, displays a message indicating the beginning of the program, makes a CICS LINK call to another program (PGM-0001) passing a communication area (CA-STUFF) and its length, displays a message indicating the end of the program, and finally terminates execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly summarizes what the source code does.,0.006277466950757328,0.8553149104118347
cob_syn_3516,COBOL,"      * REFACTOR CANDIDATE BATCH_3516
      * SYSTEM GENERATED
      * This program is the child program for asynch parent
       IDENTIFICATION DIVISION.
      *ID DIVISION.
       Program-id. ASYNCCH4.
       Environment division.
       Data division.

       Working-storage section.
       01 INCONTAINER    PIC X(16) value 'INCONT'.
       01 OUTCONTAINER   PIC X(16) VALUE 'OUTCONT'.

       01 MSG            PIC X(60) value spaces.

       Procedure division.

           EXEC CICS GET CONTAINER (INCONTAINER)
                     INTO    ( MSG )
                     NOHANDLE
           END-EXEC.

           EXEC CICS DELAY FOR SECONDS(1)
           END-EXEC

           EXEC CICS PUT CONTAINER ( OUTCONTAINER )
                     FROM   ( 'child 4 finished' )
                     NOHANDLE
           END-EXEC

           EXEC CICS RETURN END-EXEC.
           Goback.

       End program ASYNCCH4.","This COBOL program, named ASYNCCH4, is a child program designed to run asynchronously with a parent program. It retrieves a message from a container named INCONT, delays for one second, then stores the message 'child 4 finished' in a container named OUTCONT. Finally, it returns control back to the parent program.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation did not explain the action of the NOHANDLE command in the procedure division operations.,0.005965939103175657,0.8536231517791748
cob_syn_2352,COBOL,"      * REFACTOR CANDIDATE BATCH_2352
      * SYSTEM GENERATED
000010 @OPTIONS MAIN
000020 Identification Division.
000030 Program-Id.  Chapt09d.
000031* Complex Evaluate Example 2
000040 Environment Division.
000050 Configuration Section.
000051 Source-Computer.  IBM-PC.
000055 Object-Computer.  IBM-PC.
000056 Data Division.
000057 Working-Storage Section.
000058 01  Sale-Price          Pic 9(4)v99 Value 7547.00.
000059 01  Commission-Amount   Pic 9(4)v99 Value Zeros.
000072 Procedure Division.
000159 Chapt09d-Start.
000160     Evaluate True Also True
000161       When Sale-Price >= 1000 Also Sale-Price * .5 > 750.00
000162            Move 750.00 To Commission-Amount
000163       When Sale-Price >= 1000 Also Any
000164            Compute Commission-Amount = Sale-Price * .5
000165       When Sale-Price >= 500  Also Sale-Price * .25 > 150.00
000166            Move 150.00 To Commission-Amount
000167       When Sale-Price >= 500  Also Any
000168            Compute Commission-Amount = Sale-Price * .25
000169       When Sale-Price >= 250  Also Sale-Price * .10 > 30.00
000170            Move 30.00 To Commission-Amount
000171       When Sale-Price >= 250  Also Any
000172            Compute Commission-Amount = Sale-Price * .10
000173       When Other
000174            Compute Commission-Amount = Sale-Price * .05
000175            If Commission-Amount < 1.00
000176               Move 1.00 To Commission-Amount
000177            End-If
000178            If Commission-Amount > Sale-Price
000179               Compute Commission-Amount = Sale-Price * .75
000180            End-If
000181     End-Evaluate
000188     Display ""Sale Price "" Sale-Price
000189     Display ""Commission "" Commission-Amount
000190     Stop Run
000217     .",This COBOL program calculates the commission amount based on the sale price using a series of conditional evaluations. Commission rates are determined based on different ranges of sale prices. The program then displays the sale price and computed commission amount before ending.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately summarizes the code and there are no unsubstantiated claims or critical omissions.,0.00702083472657119,0.8721603751182556
py_2339,Python,"def is_seq_of(seq, expected_type, seq_type=None):
    """"""Check whether it is a sequence of some type.

    Args:
        seq (Sequence): The sequence to be checked.
        expected_type (type): Expected type of sequence items.
        seq_type (type, optional): Expected sequence type.

    Returns:
        bool: Whether the sequence is valid.
    """"""
    if seq_type is None:
        exp_seq_type = collections_abc.Sequence
    else:
        assert isinstance(seq_type, type)
        exp_seq_type = seq_type
    if not isinstance(seq, exp_seq_type):
        return False
    for item in seq:
        if not isinstance(item, expected_type):
            return False
    return True","""""""Function to check whether a given sequence is of a particular type and/or sequence type. 

Args:
    seq (Sequence): The sequence to be checked.
    expected_type (type): The expected type of the items in the sequence.
    seq_type (type, optional): The expected sequence type. If not provided, it defaults to collections.abc.Sequence.

Returns:
    bool: True if the sequence is valid (i.e., all items are of the expected type), False otherwise.
""""""","Check whether it is a sequence of some type.

    Args:
        seq (Sequence): The sequence to be checked.
        expected_type (type): Expected type of sequence items.
        seq_type (type, optional): Expected sequence type.

    Returns:
        bool: Whether the sequence is valid.",No Error,False,The generated documentation correctly explains the functionality of the code.,0.22224663537584946,0.9163352251052856
cob_syn_1078,COBOL,"      * REFACTOR CANDIDATE BATCH_1078
      * SYSTEM GENERATED
       01  PART-SUPP-ADDR-PO.
           05 PARTS-PO.
               10  PART-NUMBER-PO       PIC X(23) VALUE SPACES.
               10  PART-NAME-PO         PIC X(14) VALUE SPACES.
               10  SPEC-NUMBER-PO       PIC X(07) VALUE SPACES.
               10  GOVT-COMML-CODE-PO   PIC X(01) VALUE SPACES.
               10  BLUEPRINT-NUMBER-PO  PIC X(10) VALUE SPACES.
               10  UNIT-OF-MEASURE-PO   PIC X(03) VALUE SPACES.
               10  WEEKS-LEAD-TIME-PO   PIC 9(03) VALUE ZERO.
               10  VEHICLE-MAKE-PO      PIC X(03) VALUE SPACES.
                    88 CHRYSLER-PO       VALUE 'CHR'.
                    88 FORD-PO           VALUE 'FOR'.
                    88 GM-PO             VALUE 'GM '.
                    88 VOLKSWAGON-PO     VALUE 'VW '.
                    88 TOYOTA-PO         VALUE 'TOY'.
                    88 JAGUAR-PO         VALUE 'JAG'.
                    88 PEUGEOT-PO        VALUE 'PEU'.
                    88 BMW-PO            VALUE 'BMW'.
               10  VEHICLE-MODEL-PO     PIC X(10) VALUE SPACES.
               10  VEHICLE-YEAR-PO      PIC X(04) VALUE '0000'.
               10  FILLER            PIC X(14) VALUE SPACES.
           05 SUPPLIERS-PO.
               10  SUPPLIER-CODE-PO     PIC X(10) VALUE SPACES.
               10  SUPPLIER-TYPE-PO     PIC X(01) VALUE SPACES.
                    88 SUBCONTRACTOR-PO  VALUE 'S'.
                    88 DISTRIBUTOR-PO    VALUE 'D'.
                    88 MANUFACTURER-PO   VALUE 'M'.
                    88 IMPORTER-PO       VALUE 'I'.
               10  SUPPLIER-NAME-PO     PIC X(15) VALUE SPACES.
               10  SUPPLIER-PERF-PO     PIC 9(03) VALUE ZERO.
               10  SUPPLIER-RATING-PO   PIC X(01) VALUE SPACES.
                    88 HIGHEST-QUALITY-PO VALUE '3'.
                    88 AVERAGE-QUALITY-PO VALUE '2'.
                    88 LOWEST-QUALITY-PO  VALUE '1'.
               10  SUPPLIER-STATUS-PO   PIC X(01) VALUE SPACES.
                    88 GOVT-COMM-PO   ","This COBOL code defines a data structure representing parts, their associated information such as part number, name, specifications, and supplier details including supplier code, type, name, performance, and rating. It uses level numbers to define the hierarchy of data fields and includes condition names for identifying vehicle makes and supplier types.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation failed to mention about the GOVT-COMML-CODE-PO, BLUEPRINT-NUMBER-PO, WEEKS-LEAD-TIME-PO, UNIT-OF-MEASURE-PO, VEHICLE-MODEL-PO, VEHICLE-YEAR-PO, FILLER, and SUPPLIER-STATUS-PO fields in the data structure.",0.005965939103175657,0.857219934463501
cob_syn_1924,COBOL,"      * REFACTOR CANDIDATE BATCH_1924
      * SYSTEM GENERATED
Caligari V00.01ALH             
BitM V0.01 Id 0 Parent 0 Size 00018703
ThumbNailHdrSize 40
ThumbHeader:28 00 00 00 5e 00 00 00 5e 00 00 00 01 00 18 00 00 00 00 00 48 68 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
ColorBufSize 26696
ColorBufZipSize 6164
ZippedThumbnail:78 9c ed 9c 3d 68 e3 58 d7 c7 9f 72 cb 94 2e 5f c3 16 2b d8 62 04 53 8c 20 4d 04 29 22 48 11 41 8a 08 52 04 e1 22 08 17 46 a4 30 c2 8d 11 2e 8c 70 61 84 0b 23 5c 18 e4 c2 20 17 01 b9 30 28 4d 40 29 02 4a 31 e0 14 03 4e 31 85 8a 29 54 4c a1 22 85 9e ff b9 d7 ca 64 df dd 67 19 e7 63 66 df e7 8d 39 08 d9 e3 19 a2 df 9c f3 3f 1f f7 de 44 17 51 f4 66 7f 65 ff fa d7 4f ff 11 fe b1 f6 c6 e6 8d cd 1b 9b 37 36 6f 6c 7e be bd b1 79 63 f3 c6 e6 8d cd 1b 9b 9f 6f 6f 6c de d8 bc b1 f9 6f 61 13 ce 43 77 e8 59 1d c7 38 b3 d5 9a 25 ed 6b d2 a1 21 1f 99 6a cd 34 9a b6 d9 75 9d a1 17 cc c2 ff 4f 6c f0 b8 e0 21 1f a8 5b bf 4b 95 f7 f2 d6 6f 64 95 1d a3 b2 ad 93 7d d0 a4 9a 55 dd 37 c5 53 0b 37 d2 89 89 3f 15 76 34 bd 61 07 e7 3f 9a d3 0f 64 e3 0e 3c f9 40 ab bc 97 2a 1f 64 61 4f a5 9b f7 ea d6 b6 2a 35 1c e5 cc 01 9e ea 9e 55 d9 35 ab 87 8e 70 e8 54 f6 6d a5 ed eb 83 48 ee 04 72 c3 16 4f 6d 7c 59 6b d8 de 24 f8 ef 62 03 2a e2 b6 52 fd 20 57 77 55 98 70 a8 0b 47 86 78 62 8a 35 4b 38 b5 a5 33 57 3c 73 e4 b6 27 77 7c a5 17 48 6d 5c 43 b1 e9 cb 83 58 ee 45 72 37 12 1b 41 f5 c4 53 ba be d2 f1 e1 52 ca e9 0f 22 f4 ca 6c c8 57 0e 99 af 6c 2b 70 97 ea 8e 52 dd d7 84 43 83 42 a6 e1 c0 c4 ba 2d b7 7d a9 e9 ca dd 40 1d 45 ca 20 52 86 b0 58 9b af 64 dc 8f 13 6d 86 9b 58 bf c8 95 51 ac 8e 62 dc ab e3 44 6a fa d6 7c e9 4d 5f 97 d0 ab b1 71 47 9e 7c 04 fd 90 2b ef a4 2a 9c 86 79 4c 75 5f 17 8f c9 5d e4 ba cd d9 c8 4d 57 38 b6 d5 5e a0 30 33 66 4b 0d 84 7a b1 3a 49 80 c7 b8 ca f5 45 a6 ce 56 ea 74 a5 ce 52 fd 32 37 3e 16 ea 39 dd 68 d3 a5 dc 0f b5 9e ef bf 9a 5e bf 02 1b 7f 1a 28 c7 3a d7 15 f2 95 6d 45 38 d0 aa 3b 2a 84 55 ae 5b e2 a1 51 d9 35 40 08 d2 52 d9 b7 c4 13 b0 f1 84 13 4f aa 07 e2 69 20 9e c5 62 9d 82 08 37 52 7b 2","This code appears to be a header for image processing or compression. It contains metadata such as version numbers, sizes of various buffers, and possibly compressed image data.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.0,0.8516433835029602
py_5607,Python,"def download(self, bucket, key, fileobj, extra_args=None,
                 subscribers=None):
        """"""Downloads a file from S3

        :type bucket: str
        :param bucket: The name of the bucket to download from

        :type key: str
        :param key: The name of the key to download from

        :type fileobj: str or seekable file-like object
        :param fileobj: The name of a file to download or a seekable file-like
            object to download. It is recommended to use a filename because
            file-like objects may result in higher memory usage.

        :type extra_args: dict
        :param extra_args: Extra arguments that may be passed to the
            client operation

        :type subscribers: list(s3transfer.subscribers.BaseSubscriber)
        :param subscribers: The list of subscribers to be invoked in the
            order provided based on the event emit during the process of
            the transfer request.

        :rtype: s3transfer.futures.TransferFuture
        :returns: Transfer future representing the download
        """"""
        if extra_args is None:
            extra_args = {}
        if subscribers is None:
            subscribers = []
        self._validate_all_known_args(extra_args, self.ALLOWED_DOWNLOAD_ARGS)
        call_args = CallArgs(
            bucket=bucket, key=key, fileobj=fileobj, extra_args=extra_args,
            subscribers=subscribers
        )
        extra_main_kwargs = {'io_executor': self._io_executor}
        if self._bandwidth_limiter:
            extra_main_kwargs['bandwidth_limiter'] = self._bandwidth_limiter
        return self._submit_transfer(
            call_args, DownloadSubmissionTask, extra_main_kwargs)","Downloads a file from an S3 bucket. It takes the bucket name, key, file object, optional extra arguments, and a list of subscribers. The function validates the arguments, creates a `CallArgs` object with the provided information, and then submits a download transfer task with specified extra main keyword arguments, including an I/O executor and a bandwidth limiter if available. Returns a `TransferFuture` object representing the download operation.","Downloads a file from S3

        :type bucket: str
        :param bucket: The name of the bucket to download from

        :type key: str
        :param key: The name of the key to download from

        :type fileobj: str or seekable file-like object
        :param fileobj: The name of a file to download or a seekable file-like
            object to download. It is recommended to use a filename because
            file-like objects may result in higher memory usage.

        :type extra_args: dict
        :param extra_args: Extra arguments that may be passed to the
            client operation

        :type subscribers: list(s3transfer.subscribers.BaseSubscriber)
        :param subscribers: The list of subscribers to be invoked in the
            order provided based on the event emit during the process of
            the transfer request.

        :rtype: s3transfer.futures.TransferFuture
        :returns: Transfer future representing the download",No Error,False,"The documentation accurately describes the function and highlights its important features, without introducing any unsupported claims or omitting critical information.",0.03264625888303253,0.768563449382782
cob_real_2584,COBOL,"      *================================================================*
      *         Table generated by C# program CobolBitwiseGen          *
      *                                                                *
      *         Author: Brian D Pead                                   *
      *                                                                *
      *         License: MIT                                           *
      *                                                                *
      *         Date: 2020-02-08                                       *
      *================================================================*

       01  W-CRC32-TABLE.
           05  FILLER-000          PIC 9(09)  COMP VALUE          0.
           05  FILLER-001          PIC 9(09)  COMP VALUE 1996959894.
           05  FILLER-002          PIC 9(09)  COMP VALUE 3993919788.
           05  FILLER-003          PIC 9(09)  COMP VALUE 2567524794.
           05  FILLER-004          PIC 9(09)  COMP VALUE  124634137.
           05  FILLER-005          PIC 9(09)  COMP VALUE 1886057615.
           05  FILLER-006          PIC 9(09)  COMP VALUE 3915621685.
           05  FILLER-007          PIC 9(09)  COMP VALUE 2657392035.
           05  FILLER-008          PIC 9(09)  COMP VALUE  249268274.
           05  FILLER-009          PIC 9(09)  COMP VALUE 2044508324.
           05  FILLER-010          PIC 9(09)  COMP VALUE 3772115230.
           05  FILLER-011          PIC 9(09)  COMP VALUE 2547177864.
           05  FILLER-012          PIC 9(09)  COMP VALUE  162941995.
           05  FILLER-013          PIC 9(09)  COMP VALUE 2125561021.
           05  FILLER-014          PIC 9(09)  COMP VALUE 3887607047.
           05  FILLER-015          PIC 9(09)  COMP VALUE 2428444049.
           05  FILLER-016          PIC 9(09)  COMP VALUE  498536548.
           05  FILLER-017          PIC 9(09)  COMP VALUE 1789927666.
           05  FILLER-018          PIC 9(09) ","Defines a table named W-CRC32-TABLE with 19 entries, each entry being a 4-byte (9 digits) integer value used for CRC32 checksum calculation. The table is generated by a C# program called CobolBitwiseGen authored by Brian D Pead and licensed under MIT. The table is initialized with predetermined integer values for CRC32 calculation.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the source code.,0.0,0.8298889398574829
cob_syn_5010,COBOL,"      * REFACTOR CANDIDATE BATCH_5010
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. AOC-2021-17-2.
       AUTHOR. ANNA KOSIERADZKA.
      * Note: this one takes several minutes

       DATA DIVISION.

       WORKING-STORAGE SECTION.
         77 X1 PIC S9(6) VALUE 56.
         77 X2 PIC S9(6) VALUE 76.
         77 Y1 PIC S9(6) VALUE -162.
         77 Y2 PIC S9(6) VALUE -134.
         77 X PIC S9(6) VALUE 0.
         77 Y PIC S9(6) VALUE 0.
         77 I PIC S9(6) VALUE 0.
         77 J PIC S9(6) VALUE 0.
         77 K PIC S9(6) VALUE 0.
         77 VX PIC S9(6) VALUE 0.
         77 VY PIC S9(6) VALUE 0.
         77 MY PIC S9(6) VALUE 0.
         77 RESULT PIC S9(6) VALUE 0.
         77 T PIC 9 VALUE 0.

       PROCEDURE DIVISION.
       001-MAIN.
           PERFORM VARYING I FROM -400 BY 1 UNTIL I > 400
             PERFORM VARYING J FROM -400 BY 1 UNTIL J > 400
               MOVE 0 TO T
               MOVE 0 TO K
               MOVE I TO VX
               MOVE J TO VY
               MOVE 0 TO X
               MOVE 0 TO Y
               MOVE 0 TO MY
               PERFORM 002-STEP UNTIL T = 1 OR K = 1000
               IF T = 1 THEN
                 ADD 1 TO RESULT
               END-IF
             END-PERFORM
           END-PERFORM
           DISPLAY RESULT.
           STOP RUN.
          
      * On each step, these changes occur in the following order:
      * the probe's x position increases by vx   
      * the probe's y position increases by vy
      * the probe's x velocity changes by 1 toward the value 0
      * the probe's y velocity decreases by 1
       002-STEP.
           ADD 1 TO K.
           ADD VX TO X.
           ADD VY TO Y.
           IF VX > 0 THEN
             SUBTRACT 1 FROM VX
           ELSE IF VX < 0 THEN
               ADD 1 TO VX
             END-IF
           END-IF.
           SUBTRACT 1 FROM VY.
           IF Y > MY THEN
             MOVE Y TO MY
           END-IF
           IF X >= X1 AND X <= X2 AND Y >= Y1 AND Y <= Y2 THEN
             MOVE 1 TO T
           END-I",This COBOL program simulates the movement of a probe within a defined area. The probe's position and velocity are updated in each step according to specified rules. The program iterates over all possible positions within the area and determines how many times the probe intersects with a specific region. The final count of intersections is displayed as the result.,Legacy COBOL logic requiring documentation.,Omission,True,The documentation fails to mention the defined area for the probe and the specific region where the probe intersects.,0.005277645918110919,0.8616024851799011
py_8021,Python,"def _get_course_content_from_ecommerce(course_id, site_code=None):
    """"""
    Get course information using the Ecommerce course api.

    In case of error returns empty response.
    Arguments:
        course_id (str): course key of the course
        site_code (str): site code

    Returns:
        course information from Ecommerce
    """"""
    api = get_ecommerce_client(site_code=site_code)
    try:
        api_response = api.courses(course_id).get()
    except Exception:  # pylint: disable=broad-except
        logger.exception(
            'An error occurred while retrieving data for course run [%s] from the Catalog API.',
            course_id,
            exc_info=True
        )
        return {}

    return {
        'title': api_response.get('name'),
        'verification_deadline': api_response.get('verification_deadline')
    }","Get course information using the Ecommerce course api.

In case of error returns empty response.
Arguments:
    course_id (str): course key of the course
    site_code (str): site code

Returns:
    course information from Ecommerce","Get course information using the Ecommerce course api.

    In case of error returns empty response.
    Arguments:
        course_id (str): course key of the course
        site_code (str): site code

    Returns:
        course information from Ecommerce",No Error,False,The generated documentation perfectly matches the source code.,1.0,0.9630066752433777
py_5354,Python,"def _shrink_update(self, rmstart: int, rmstop: int) -> None:
        """"""Update self._type_to_spans according to the removed span.

        Warning: If an operation involves both _shrink_update and
        _insert_update, you might wanna consider doing the
        _insert_update before the _shrink_update as this function
        can cause data loss in self._type_to_spans.
        """"""
        # Note: The following algorithm won't work correctly if spans
        # are not sorted.
        # Note: No span should be removed from _type_to_spans.
        for spans in self._type_to_spans.values():
            i = len(spans) - 1
            while i >= 0:
                s, e = span = spans[i]
                if rmstop <= s:
                    # rmstart <= rmstop <= s <= e
                    rmlength = rmstop - rmstart
                    span[:] = s - rmlength, e - rmlength
                    i -= 1
                    continue
                break
            else:
                continue
            while True:
                if rmstart <= s:
                    if rmstop < e:
                        # rmstart < s <= rmstop < e
                        span[:] = rmstart, e + rmstart - rmstop
                        i -= 1
                        if i < 0:
                            break
                        s, e = span = spans[i]
                        continue
                    # rmstart <= s <= e < rmstop
                    spans.pop(i)[:] = -1, -1
                    i -= 1
                    if i < 0:
                        break
                    s, e = span = spans[i]
                    continue
                break
            while i >= 0:
                if e <= rmstart:
                    # s <= e <= rmstart <= rmstop
                    i -= 1
                    if i < 0:
                        break
                    s, e = span = spans[i]
                    continue
                # s <= rmstart <= rmstop <= e
                span[1] -= rmstop - rmstart
                i -= 1
                if i < 0:
                    break
                s, e = span = spans[i]
                continue","""""""Update self._type_to_spans according to the removed span.

Warning: If an operation involves both _shrink_update and
_insert_update, you might wanna consider doing the
_insert_update before the _shrink_update as this function
can cause data loss in self._type_to_spans.
""""""","Update self._type_to_spans according to the removed span.

        Warning: If an operation involves both _shrink_update and
        _insert_update, you might wanna consider doing the
        _insert_update before the _shrink_update as this function
        can cause data loss in self._type_to_spans.",No Error,False,"The documentation accurately describes the function's behavior, provides a warning about potential data loss, and does not include hallucinated or omitted information.",0.9419661180380056,0.9026119112968445
cob_real_229,COBOL,"       identification division.
       program-id. table_processing_03.

       data division.
       working-storage section.
       01 ws-table.
       05 ws-a occurs 3 times.
       10 ws-b pic a(2).
       10 ws-c occurs 2 times.
       15 ws-d pic x(3).

       procedure division.
           move '12abcdef34ghijkl56mnopqr' to ws-table.
           display 'ws-table  : ' ws-table.
           display 'ws-a(1)   : ' ws-a(1).
           display 'ws-c(1,1) : ' ws-c(1,1).
           display 'ws-c(1,2) : ' ws-c(1,2).
           display 'ws-a(2)   : ' ws-a(2).
           display 'ws-c(2,1) : ' ws-c(2,1).
           display 'ws-c(2,2) : ' ws-c(2,2).
           display 'ws-a(3)   : ' ws-a(3).
           display 'ws-c(3,1) : ' ws-c(3,1).
           display 'ws-c(3,2) : ' ws-c(3,2).

           stop run.
","This COBOL program declares a working storage table `ws-table` with nested arrays `ws-a` and `ws-c`. It then assigns a string value to `ws-table` and displays specific elements of `ws-a` and `ws-c` arrays. Finally, it stops the program execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly summarizes the functionality of the code.,0.007633935801913548,0.8457863926887512
py_12433,Python,"def _delete_local(self, filename):
        """"""Deletes the specified file from the local filesystem.""""""

        if os.path.exists(filename):
            os.remove(filename)",Deletes the specified file from the local filesystem.,Deletes the specified file from the local filesystem.,No Error,False,The documentation accurately describes what the code does.,1.0,0.9999999403953552
py_8845,Python,"def fit_predict(self, features, class_labels):
        """"""Convenience function that fits the provided data then constructs predictions from the provided features.

        Parameters
        ----------
        features: array-like {n_samples, n_features}
            Feature matrix
        class_labels: array-like {n_samples}
            List of true class labels

        Returns
        ----------
        array-like: {n_samples}
            Constructed features from the provided feature matrix

        """"""
        self.fit(features, class_labels)
        return self.predict(features)",Convenience function that fits the provided data then constructs predictions from the provided features. It takes in a feature matrix and a list of true class labels. Returns the constructed features from the provided feature matrix.,"Convenience function that fits the provided data then constructs predictions from the provided features.

        Parameters
        ----------
        features: array-like {n_samples, n_features}
            Feature matrix
        class_labels: array-like {n_samples}
            List of true class labels

        Returns
        ----------
        array-like: {n_samples}
            Constructed features from the provided feature matrix",Omission,True,The documentation does not mention the necessity of the method calls to 'fit' and 'predict' for the function to work correctly.,0.44865923813193587,0.8085164427757263
cob_syn_2089,COBOL,"      * REFACTOR CANDIDATE BATCH_2089
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID.    TPROG01.
000300 AUTHOR.        COMPUWARE ISPW TRAINING.
000400 DATE-WRITTEN.  JANUARY 24TH, 1996.
000500 DATE-COMPILED.
000600
000700********************************************************
000800* THIS PROGRAM IS A TRAINING PROGRAM 95
000900*      WITH A LINK TO TSUBR01
001000*
001100*      AND COPYLIBS   TCPYA01   (HEADER)
001200*                     TCPYB01   (LINK AREA)
001300* ======================================================
001400*  ISPW (TM)
001500*  COPYRIGHT (C) 1986-2016 COMPUWARE CORPORATION.
001600*  UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT
001700*  LAWS OF THE UNITED STATES.
001800*
001900* ======================================================
002000*                   MODIFICATION  LOG
002100*
002200*  DD/MM/YY  PROGRAMMER  CHANGES
002300*  ********  **********  *******
002400*  96/01/24  ISPW        NEW PROGRAM
002500* ======================================================
002600 ENVIRONMENT DIVISION.
002700 CONFIGURATION SECTION.
002800 SOURCE-COMPUTER. IBM-370.
002900 OBJECT-COMPUTER. IBM-370.
003000
003100 INPUT-OUTPUT SECTION.
003200 FILE-CONTROL.
003300
003400*****************************************************
003500*  FILES USED:
003600*   INPUT   JUST SOME DUMMY DATA TO READ IN
003700*   OUTPUT  A COPY OF THE DUMMY DATA WRITTEN OUT
003800*****************************************************
003900     SELECT INFILE  ASSIGN UT-S-INPUT
004000       ORGANIZATION IS SEQUENTIAL
004100       ACCESS IS SEQUENTIAL.
004200
004300     SELECT OUTFILE ASSIGN UT-S-OUTPUT
004400       ORGANIZATION IS SEQUENTIAL
004500       ACCESS IS SEQUENTIAL.
004600
004700 DATA DIVISION.
004800
004900 FILE SECTION.
005000
005100 FD  INFILE
005200     LABEL RECORDS OMITTED
005300     BLOCK CONTAINS 0 RECORDS
005400     RECORDING MODE IS F
005500     DATA RECORD IS INPUT-REC.
005600
005700 01  INPUT-REC         PIC X(80).
005800
005900 FD  OUTFILE
006000     LABEL RECORDS OMITTED
006100     BLOCK CONTAINS","This COBOL program is a training program with a link to another program (TSUBR01) and uses two copybooks (TCPYA01 for header and TCPYB01 for link area). It defines two files, INFILE for reading dummy data and OUTFILE for writing a copy of the dummy data. The program is designed for an IBM-370 system. The input record is defined as a fixed-length character string of 80 characters.",Legacy COBOL logic requiring documentation.,No Error,False,The description provided in the documentation corresponds accurately to the source code.,0.004801387150967651,0.8487345576286316
cob_syn_3667,COBOL,"      * REFACTOR CANDIDATE BATCH_3667
      * SYSTEM GENERATED
      *         COBOL reference format (Figure 1., page 32)
      *Columns:
      *  1         2         3         4         5         6         7
      *89012345678901234567890123456789012345678901234567890123456789012
      *<A-><--------------------------B-------------------------------->
      *Area                          Area
      *<---Sequence Number Area                 Identification Area---->
      *-----------------------
       IDENTIFICATION DIVISION.
      *-----------------------
       PROGRAM-ID. PAYROL00.
      *-------------
       DATA DIVISION.
      *-------------
       WORKING-STORAGE SECTION.
      ****** Variables for the report
      * level number
      * |  variable name
      * |  |          picture clause
      * |  |          |
      * V  V          V
       77  WHO        PIC X(15).
       77  WHERE      PIC X(20).
       77  WHY        PIC X(30).
       77  RATE       PIC 9(3).
       77  HOURS      PIC 9(3).
       77  GROSS-PAY  PIC 9(5).

      * PIC X(15) -- fiftheen alphanumeric characters
      * PIC 9(3)  -- three-digit value
      *------------------
       PROCEDURE DIVISION.
      *------------------
      ****** COBOL MOVE statements - Literal Text to Variables
           MOVE  ""Captain COBOL"" TO WHO.
           MOVE ""San Jose, California"" TO WHERE.
           MOVE ""Learn to be a COBOL expert"" TO WHY.
           MOVE 19 TO HOURS.
           MOVE 23 TO RATE.
      * The string ""Captain COBOL"" only contains 13 characters,
      * the remaining positions of variable WHO are filled with spaces
      * The value 19 only needs 2 digits,
      * the leftmost position of variable HOURS is filled with zero
      ****** Calculation using COMPUTE reserved word verb
           COMPUTE GROSS-PAY = HOURS * RATE.
      * The result of the multiplication only needs 3 digits,
      * the remaining leftmost positions are filled with zeroes
      ****** DISPLAY statements
           DISPLAY ""Name: "" WHO.
           DISPLAY ""Location: "" WH","This COBOL code defines variables for a payroll report and assigns values to them. It then calculates the gross pay based on hours and rate using the COMPUTE statement. Finally, it displays the name and location of an individual.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation did not include that it also displays the reasoning (WHY variable) and the multiplication process of calculating gross pay is not described. It also abruptly ends with mentioning only ""Location: "" and doesn't include the location variable 'WHERE'.",0.007469938459592591,0.87119460105896
cob_real_3332,COBOL,"000010 @OPTIONS MAIN,TEST
000020 Identification Division.
000030 Program-Id.  Chapt14d.
000031* Dealer Data Entry
000041 Environment Division.
000050 Configuration Section.
000051 Special-Names.
000052       Crt Status Is Keyboard-Status
000053       Cursor Is Cursor-Position.
000054 Source-Computer.  IBM-PC.
000055 Object-Computer.  IBM-PC.
000056 Input-Output Section.
000057 File-Control.
000058     Select Dealer-File Assign To ""Dealer.Dat""
000059            Organization Indexed
000060            Access Random
000061            Record Key Dealer-Number Of Dealer-Record
000062            Alternate Record Key Dealer-Name Of Dealer-Record
000063            File Status Dealer-Status.
000065 Data Division.
000066 File Section.
000067 Fd  Dealer-File.
000068 01  Dealer-Record.
000069     03  Dealer-Number         Pic X(8).
000070     03  Dealer-Name.
000071         05  Last-Name   Pic X(25).
000072         05  First-Name  Pic X(15).
000073         05  Middle-Name Pic X(10).
000083     03  Address-Line-1      Pic X(50).
000085     03  Address-Line-2      Pic X(50).
000086     03  City                Pic X(40).
000087     03  State-Or-Country    Pic X(20).
000088     03  Postal-Code         Pic X(15).
000089     03  Home-Phone          Pic X(20).
000090     03  Work-Phone          Pic X(20).
000091     03  Other-Phone         Pic X(20).
000092     03  Start-Date          Pic 9(8).
000093     03  Last-Rent-Paid-Date Pic 9(8).
000094     03  Next-Rent-Due-Date  Pic 9(8).
000095     03  Rent-Amount         Pic 9(4)v99.
000096     03  Consignment-Percent Pic 9(3).
000097     03  Filler              Pic X(50).
000098 Working-Storage Section.
000099 01  Keyboard-Status.
000100     03  Accept-Status Pic 9.
000101     03  Function-Key  Pic X.
000102         88  F1-Pressed Value X""01"".
000103         88  F2-Pressed Value X""02"".
000104     03  System-Use    Pic X.
000105 01  Cursor-Position.
000106     03  Cursor-Row    Pic 9(2) Value 1.
000107     03  Cursor-Column Pic 9(2) Value ","This COBOL code defines a program for dealer data entry. It sets up file handling for reading and writing dealer information to a file. The data structure includes fields for dealer details such as name, address, phone numbers, dates, and financial information. It also defines working storage for managing keyboard input status and cursor position.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the functions and purpose of the COBOL source code.,0.005598996258250374,0.8651938438415527
py_7196,Python,"def set(self, node_ids, variable=None, name=""tmp""):
        """"""
        Characterize urban space with a variable that is related to nodes in
        the network.

        Parameters
        ----------
        node_ids : Pandas Series, int
            A series of node_ids which are usually computed using
            get_node_ids on this object.
        variable : Pandas Series, numeric, optional
            A series which represents some variable defined in urban space.
            It could be the location of buildings, or the income of all
            households - just about anything can be aggregated using the
            network queries provided here and this provides the api to set
            the variable at its disaggregate locations.  Note that node_id
            and variable should have the same index (although the index is
            not actually used).  If variable is not set, then it is assumed
            that the variable is all ""ones"" at the location specified by
            node_ids.  This could be, for instance, the location of all
            coffee shops which don't really have a variable to aggregate. The
            variable is connected to the closest node in the Pandana network
            which assumes no impedance between the location of the variable
            and the location of the closest network node.
        name : string, optional
            Name the variable.  This is optional in the sense that if you don't
            specify it, the default name will be used.  Since the same
            default name is used by aggregate on this object, you can
            alternate between characterize and aggregate calls without
            setting names.

        Returns
        -------
        Nothing
        """"""

        if variable is None:
            variable = pd.Series(np.ones(len(node_ids)), index=node_ids.index)

        df = pd.DataFrame({name: variable,
                           ""node_idx"": self._node_indexes(node_ids)})

        length = len(df)
        df = df.dropna(how=""any"")
        newl = len(df)
        if length-newl > 0:
            print(
                ""Removed %d rows because they contain missing values"" %
                (length-newl))

        self.variable_names.add(name)

        self.net.initialize_access_var(name.encode('utf-8'),
                                       df.node_idx.values.astype('int'),
                                       df[name].values.astype('double'))",Characterize urban space with a variable related to nodes in the network using provided node IDs and optional variable data.,"Characterize urban space with a variable that is related to nodes in
        the network.

        Parameters
        ----------
        node_ids : Pandas Series, int
            A series of node_ids which are usually computed using
            get_node_ids on this object.
        variable : Pandas Series, numeric, optional
            A series which represents some variable defined in urban space.
            It could be the location of buildings, or the income of all
            households - just about anything can be aggregated using the
            network queries provided here and this provides the api to set
            the variable at its disaggregate locations.  Note that node_id
            and variable should have the same index (although the index is
            not actually used).  If variable is not set, then it is assumed
            that the variable is all ""ones"" at the location specified by
            node_ids.  This could be, for instance, the location of all
            coffee shops which don't really have a variable to aggregate. The
            variable is connected to the closest node in the Pandana network
            which assumes no impedance between the location of the variable
            and the location of the closest network node.
        name : string, optional
            Name the variable.  This is optional in the sense that if you don't
            specify it, the default name will be used.  Since the same
            default name is used by aggregate on this object, you can
            alternate between characterize and aggregate calls without
            setting names.

        Returns
        -------
        Nothing",No Error,False,"The provided generated documentation gives a general overview of what the function does, which aligns with the source code.",1.5435154959485704e-05,0.7711604237556458
cob_syn_3551,COBOL,"      * REFACTOR CANDIDATE BATCH_3551
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID.    TSUBR08.
000300 AUTHOR.        COMPUWARE ISPW TRAINING.
000400 DATE-WRITTEN.  JANUARY 24TH, 1996.
000500 DATE-COMPILED.
000600
000700********************************************************
000800* THIS PROGRAM IS A TRAINING PROGRAM
000900*      CALLED FROM    TPROG08
001000*      WITH COPYLIB   TCPYB08 (LINKAGE AREA)
001100* ======================================================
001200*  ISPW (TM)
001300*  COPYRIGHT (C) 1986-2016 COMPUWARE CORPORATION.
001400*  UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT
001500*  LAWS OF THE UNITED STATES.
001600*
001700* ======================================================
001800*                   MODIFICATION  LOG
001900*
002000*  DD/MM/YY  PROGRAMMER  CHANGES
002100*  ********  **********  *******
002200*  96/01/24  ISPW        NEW PROGRAM
002300* ======================================================
002400 ENVIRONMENT DIVISION.
002500 CONFIGURATION SECTION.
002600 SOURCE-COMPUTER. IBM-370.
002700 OBJECT-COMPUTER. IBM-370.
002800
002900 INPUT-OUTPUT SECTION.
003000 FILE-CONTROL.
003100
003200********************************************************
003300*  FILES USED:
003400*   INPUT   JUST SOME DUMMY DATA TO READ IN
003500********************************************************
003600     SELECT INFILE  ASSIGN UT-S-INPUT
003700       ORGANIZATION IS SEQUENTIAL
003800       ACCESS IS SEQUENTIAL.
003900
004000
004100 DATA DIVISION.
004200
004300 FILE SECTION.
004400
004500 FD  INFILE
004600     LABEL RECORDS OMITTED
004700     BLOCK CONTAINS 0 RECORDS
004800     RECORDING MODE IS F
004900     DATA RECORD IS INPUT-REC.
005000
005100 01  INPUT-REC         PIC X(80).
005200
005300 WORKING-STORAGE SECTION.
005400
005500 01   INFILE-OPEN-FLAG     PIC X(1) VALUE 'N'.
005600      88 INFILE-OPEN       VALUE 'Y'.
005700
005800 LINKAGE SECTION.
005900********************************************************
006000**** A C","This COBOL program is a training program named TSUBR08, meant to be called from another program named TPROG08. It includes a file named INFILE for reading dummy data sequentially. The program has a working storage variable to flag if the file is open or closed. It was written by Compuware ISPW Training on January 24th, 1996, and contains information about its purpose, copyright, and modification log.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.004801387150967651,0.854778528213501
py_10626,Python,"def gatk_variant_filtration(job, vcf_id, filter_name, filter_expression, ref_fasta, ref_fai, ref_dict):
    """"""
    Filters VCF file using GATK VariantFiltration. Fixes extra pair of quotation marks in VCF header that
    may interfere with other VCF tools.

    :param JobFunctionWrappingJob job: passed automatically by Toil
    :param str vcf_id: FileStoreID for input VCF file
    :param str filter_name: Name of filter for VCF header
    :param str filter_expression: JEXL filter expression
    :param str ref_fasta: FileStoreID for reference genome fasta
    :param str ref_fai: FileStoreID for reference genome index file
    :param str ref_dict: FileStoreID for reference genome sequence dictionary file
    :return: FileStoreID for filtered VCF file
    :rtype: str
    """"""
    inputs = {'genome.fa': ref_fasta,
              'genome.fa.fai': ref_fai,
              'genome.dict': ref_dict,
              'input.vcf': vcf_id}

    work_dir = job.fileStore.getLocalTempDir()
    for name, file_store_id in inputs.iteritems():
        job.fileStore.readGlobalFile(file_store_id, os.path.join(work_dir, name))

    command = ['-T', 'VariantFiltration',
               '-R', 'genome.fa',
               '-V', 'input.vcf',
               '--filterName', filter_name,   # Documents filter name in header
               '--filterExpression', filter_expression,
               '-o', 'filtered_variants.vcf']

    job.fileStore.logToMaster('Running GATK VariantFiltration using {name}: '
                              '{expression}'.format(name=filter_name, expression=filter_expression))

    docker_parameters = ['--rm', 'log-driver', 'none',
                         '-e', 'JAVA_OPTS=-Djava.io.tmpdir=/data/ -Xmx{}'.format(job.memory)]
    dockerCall(job=job, workDir=work_dir,
               parameters=command,
               tool='quay.io/ucsc_cgl/gatk:3.5--dba6dae49156168a909c43330350c6161dc7ecc2',
               dockerParameters=docker_parameters)

    # Remove extra quotation marks around filter expression.
    malformed_header = os.path.join(work_dir, 'filtered_variants.vcf')
    fixed_header = os.path.join(work_dir, 'fixed_header.vcf')
    filter_regex = re.escape('""%s""' % filter_expression)
    with open(malformed_header, 'r') as f, open(fixed_header, 'w') as g:
        for line in f:
            g.write(re.sub(filter_regex, filter_expression, line))

    return job.fileStore.writeGlobalFile(fixed_header)","Filters VCF file using GATK VariantFiltration, while fixing any extra pair of quotation marks in the VCF header that may interfere with other VCF tools.","Filters VCF file using GATK VariantFiltration. Fixes extra pair of quotation marks in VCF header that
    may interfere with other VCF tools.

    :param JobFunctionWrappingJob job: passed automatically by Toil
    :param str vcf_id: FileStoreID for input VCF file
    :param str filter_name: Name of filter for VCF header
    :param str filter_expression: JEXL filter expression
    :param str ref_fasta: FileStoreID for reference genome fasta
    :param str ref_fai: FileStoreID for reference genome index file
    :param str ref_dict: FileStoreID for reference genome sequence dictionary file
    :return: FileStoreID for filtered VCF file
    :rtype: str",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.05396648754332491,0.8517055511474609
cob_syn_8736,COBOL,"      * REFACTOR CANDIDATE BATCH_8736
      * SYSTEM GENERATED
      * Author: Dennis Decker Jensen
      * Date: 5 July 2015
      * Purpose: The digit sum of 2 ** 1000
      * Tectonics: cobc -x euler016.cob
       identification division.
       program-id. euler016.
       environment division.
       configuration section.
       input-output section.
       file-control.
           select digit-input
               assign to ""power-digits.txt""
               organization is sequential.
      ******************************************************************
       data division.
       file section.
       FD  digit-input.
       01  input-rec   pic X(32768).

       working-storage section.
       01  digit-sum   pic 999999 value is zero usage is computational.
       01  digit       pic 9      usage is computational.
       01  i           pic 9999   comp.
       01  command-status pic s9(9).
      ******************************************************************
       procedure division.
       main-procedure.
           perform calculate-digits through clean-up.
           stop run.

       calculate-digits.
           call ""SYSTEM""
               using ""dc -e '2 1000 ^ p' "" &
                     ""| sed -e 's/[^0-9]//g' "" &
                     ""| tr -d '\n' > power-digits.txt""
               returning command-status.
           if command-status not equal zero
               display ""Failed to run calculation of power digits.""
               stop run.

       read-digits.
           open input digit-input
           read digit-input
           close digit-input.

       digit-summation.
      *    display ""Power digits:"".
      *    display input-rec.
           perform varying i from 1 by 1
                   until input-rec(i:1) = space or i > 9000
               move input-rec(i:1) to digit
               add digit to digit-sum
           end-perform.

       show-result.
           display ""Digit sum: "" digit-sum.

       clean-up.
           call ""CBL_DELETE_FILE"" using ""power-digits.txt"".
       end program ","Calculates the digit sum of 2 raised to the power of 1000. The code reads the result of 2 ** 1000 from a file, extracts the digits, calculates the sum of those digits, and displays the final digit sum.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the operations done by the code.,0.0,0.8317216634750366
cob_syn_6294,COBOL,"      * REFACTOR CANDIDATE BATCH_6294
      * SYSTEM GENERATED
      ******************************************************************
      **  P R O G R A M M E  DEBUT  ------------  DEBUT  S O U R C E  **
      **  ecrit en COBOL-85 sous OpenCobol                            **
      **  format-number.cob                           Version 1.1 PC  **
      ******************************************************************
      **  Formatter un nombre dcimal                                 **
      **  ----------------------------------------------------------  **
      **  Objet :                                                     **
      **  - Avoir un affichage plus humain d'un nombre dcimal        **
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID.                                        format-number.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
      * ++============================================================++
      * ++===                                donnees de traitement ===++
      * ++============================================================++
        01 NUMBER-CUTTED PIC ZZ.99.
        
        77 DIVIDER PIC X VALUE "","".
        
        01 NUMBER-CUTTED-FORMAT.
           05 ENTIER PIC ZZ.
           05 PIC X.
           05 DECIMAL PIC 99.



       LINKAGE SECTION.
        01 RAW-NUMBER PIC 99V99.
        01 FORMATTED-NUMBER PIC X(5).

       PROCEDURE DIVISION using RAW-NUMBER,FORMATTED-NUMBER.
      * ****************************************************************
      * *****      PROGRAMME                                       *****
      * ****************************************************************



      * Dans un premier temps on retire les zros inutiles du nombre
          MOVE RAW-NUMBER TO NUMBER-CUTTED
      * puis on dcoupe celui-ci en un entier et un dcimal    
          MOVE NUMBER-CUTTED TO NUMBER-CUTTED-FORMAT
      
      * Si le nombre enti","This COBOL program `format-number` formats a decimal number for more human-readable display. It takes a decimal number as input, removes unnecessary zeros, and separates it into integer and decimal parts. The formatted number is then returned for display.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the function and process of the provided COBOL code without any unsupported claims or omissions.,0.007633935801913548,0.8644111156463623
cob_syn_6545,COBOL,"      * REFACTOR CANDIDATE BATCH_6545
      * SYSTEM GENERATED
      *> Generate random numbers to demonstrate bug with random function
      *> https://sourceforge.net/p/open-cobol/bugs/72/
      *> Ubuntu Xenial ships an OpenCobol package with this bug which 
      *> results in random numbers being skewed towards low end instead 
      *> of uniform.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. genrand.
       AUTHOR. Owain Kenway.

       DATA DIVISION.
           WORKING-STORAGE SECTION.
           01 samples USAGE IS BINARY-LONG UNSIGNED VALUE 10000000.
           01 r       USAGE IS FLOAT-LONG.
          
       PROCEDURE DIVISION.

      *> Print a heading for our table (makes life in R better).
           DISPLAY ""r""
           PERFORM samples TIMES
               COMPUTE r = FUNCTION RANDOM
               DISPLAY r
           END-PERFORM

           GOBACK. 
","Generates a large number of random floating-point values to demonstrate a bug in the random number generation function in OpenCobol. The bug causes the randomly generated numbers to be skewed towards the low end instead of being distributed uniformly. The code outputs these random values to showcase this issue, where the number of samples generated is set to 10,000,000.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation aligns correctly with the functions and operations described in the source code.,0.0,0.8342776298522949
py_1832,Python,"def create_subscription(
            self, topic_name, subscription_name,
            lock_duration=30, requires_session=None,
            default_message_time_to_live=None,
            dead_lettering_on_message_expiration=None,
            dead_lettering_on_filter_evaluation_exceptions=None,
            enable_batched_operations=None, max_delivery_count=None):
        """"""Create a subscription entity.

        :param topic_name: The name of the topic under which to create the subscription.
        :param subscription_name: The name of the new subscription.
        :type subscription_name: str
        :param lock_duration: The lock durection in seconds for each message in the subscription.
        :type lock_duration: int
        :param requires_session: Whether the subscription will be sessionful, and therefore require all
         message to have a Session ID and be received by a sessionful receiver.
         Default value is False.
        :type requires_session: bool
        :param default_message_time_to_live: The length of time a message will remain in the subscription
         before it is either discarded or moved to the dead letter queue.
        :type default_message_time_to_live: ~datetime.timedelta
        :param dead_lettering_on_message_expiration: Whether to move expired messages to the
         dead letter queue. Default value is False.
        :type dead_lettering_on_message_expiration: bool
        :param dead_lettering_on_filter_evaluation_exceptions: Whether to move messages that error on
         filtering into the dead letter queue. Default is False, and the messages will be discarded.
        :type dead_lettering_on_filter_evaluation_exceptions: bool
        :param max_delivery_count: The maximum number of times a message will attempt to be delivered
         before it is moved to the dead letter queue.
        :type max_delivery_count: int
        :param enable_batched_operations:
        :type: enable_batched_operations: bool
        :raises: ~azure.servicebus.common.errors.ServiceBusConnectionError if the namespace is not found.
        :raises: ~azure.common.AzureConflictHttpError if a queue of the same name already exists.
        """"""
        sub_properties = Subscription(
            lock_duration=""PT{}S"".format(int(lock_duration)),
            requires_session=requires_session,
            default_message_time_to_live=default_message_time_to_live,
            dead_lettering_on_message_expiration=dead_lettering_on_message_expiration,
            dead_lettering_on_filter_evaluation_exceptions=dead_lettering_on_filter_evaluation_exceptions,
            max_delivery_count=max_delivery_count,
            enable_batched_operations=enable_batched_operations)
        try:
            return self.mgmt_client.create_subscription(
                topic_name, subscription_name,
                subscription=sub_properties, fail_on_exist=True)
        except requests.exceptions.ConnectionError as e:
            raise ServiceBusConnectionError(""Namespace: {} not found"".format(self.service_namespace), e)",Create a subscription entity with specified properties for a given topic.,"Create a subscription entity.

        :param topic_name: The name of the topic under which to create the subscription.
        :param subscription_name: The name of the new subscription.
        :type subscription_name: str
        :param lock_duration: The lock durection in seconds for each message in the subscription.
        :type lock_duration: int
        :param requires_session: Whether the subscription will be sessionful, and therefore require all
         message to have a Session ID and be received by a sessionful receiver.
         Default value is False.
        :type requires_session: bool
        :param default_message_time_to_live: The length of time a message will remain in the subscription
         before it is either discarded or moved to the dead letter queue.
        :type default_message_time_to_live: ~datetime.timedelta
        :param dead_lettering_on_message_expiration: Whether to move expired messages to the
         dead letter queue. Default value is False.
        :type dead_lettering_on_message_expiration: bool
        :param dead_lettering_on_filter_evaluation_exceptions: Whether to move messages that error on
         filtering into the dead letter queue. Default is False, and the messages will be discarded.
        :type dead_lettering_on_filter_evaluation_exceptions: bool
        :param max_delivery_count: The maximum number of times a message will attempt to be delivered
         before it is moved to the dead letter queue.
        :type max_delivery_count: int
        :param enable_batched_operations:
        :type: enable_batched_operations: bool
        :raises: ~azure.servicebus.common.errors.ServiceBusConnectionError if the namespace is not found.
        :raises: ~azure.common.AzureConflictHttpError if a queue of the same name already exists.",Omission,True,The description and type of the parameter 'enable_batched_operations' are missing in the documentation.,4.55310254975975e-09,0.7680087685585022
py_7505,Python,"def parse_individual(sample):
    """"""Parse individual information

        Args:
            sample (dict)

        Returns:
            {
                'individual_id': str,
                'father': str,
                'mother': str,
                'display_name': str,
                'sex': str,
                'phenotype': str,
                'bam_file': str,
                'vcf2cytosure': str,
                'analysis_type': str,
                'capture_kits': list(str),
            }

    """"""
    ind_info = {}
    if 'sample_id' not in sample:
        raise PedigreeError(""One sample is missing 'sample_id'"")
    sample_id = sample['sample_id']
    # Check the sex
    if 'sex' not in sample:
        raise PedigreeError(""Sample %s is missing 'sex'"" % sample_id)
    sex = sample['sex']
    if sex not in REV_SEX_MAP:
        log.warning(""'sex' is only allowed to have values from {}""
                    .format(', '.join(list(REV_SEX_MAP.keys()))))
        raise PedigreeError(""Individual %s has wrong formated sex"" % sample_id)

    # Check the phenotype
    if 'phenotype' not in sample:
        raise PedigreeError(""Sample %s is missing 'phenotype'""
                            % sample_id)
    phenotype = sample['phenotype']
    if phenotype not in REV_PHENOTYPE_MAP:
        log.warning(""'phenotype' is only allowed to have values from {}""
                    .format(', '.join(list(REV_PHENOTYPE_MAP.keys()))))
        raise PedigreeError(""Individual %s has wrong formated phenotype"" % sample_id)

    ind_info['individual_id'] = sample_id
    ind_info['display_name'] = sample.get('sample_name', sample['sample_id'])

    ind_info['sex'] = sex
    ind_info['phenotype'] = phenotype

    ind_info['father'] = sample.get('father')
    ind_info['mother'] = sample.get('mother')

    ind_info['confirmed_parent'] = sample.get('confirmed_parent')
    ind_info['confirmed_sex'] = sample.get('confirmed_sex')
    ind_info['predicted_ancestry'] = sample.get('predicted_ancestry')

    bam_file = sample.get('bam_path')
    if bam_file:
        ind_info['bam_file'] = bam_file

    mt_bam = sample.get('mt_bam')
    if mt_bam:
        ind_info['mt_bam'] = mt_bam

    analysis_type = sample.get('analysis_type')
    if analysis_type:
        ind_info['analysis_type'] = analysis_type

    ind_info['capture_kits'] = ([sample.get('capture_kit')]
                                if 'capture_kit' in sample else [])

    # Path to downloadable vcf2cytosure file
    vcf2cytosure = sample.get('vcf2cytosure')
    if vcf2cytosure:
        ind_info['vcf2cytosure'] = vcf2cytosure

    # Cancer specific values
    tumor_type = sample.get('tumor_type')
    if tumor_type:
        ind_info['tumor_type'] = tumor_type

    tumor_mutational_burden = sample.get('tmb')
    if tumor_mutational_burden:
        ind_info['tmb'] = tumor_mutational_burden

    msi = sample.get('msi')
    if msi:
        ind_info['msi'] = msi

    tumor_purity = sample.get('tumor_purity')
    if tumor_purity:
        ind_info['tumor_purity'] = tumor_purity

    return ind_info","""""""Parse individual information from a dictionary containing sample data. 

Args:
    sample (dict): A dictionary containing information about an individual sample.

Returns:
    dict: A dictionary with keys representing individual attributes including 'individual_id', 'father', 'mother', 'display_name', 'sex', 'phenotype', 'bam_file', 'vcf2cytosure', 'analysis_type', and 'capture_kits'.""""""","Parse individual information

        Args:
            sample (dict)

        Returns:
            {
                'individual_id': str,
                'father': str,
                'mother': str,
                'display_name': str,
                'sex': str,
                'phenotype': str,
                'bam_file': str,
                'vcf2cytosure': str,
                'analysis_type': str,
                'capture_kits': list(str),
            }",Omission,True,"The documentation does not include all return keys in the source code, such as 'confirmed_parent', 'confirmed_sex', 'predicted_ancestry', 'mt_bam', 'tumor_type', 'tmb', 'msi', 'tumor_purity'.",0.0230789165254704,0.8350021839141846
cob_syn_8046,COBOL,"      * REFACTOR CANDIDATE BATCH_8046
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. array-sum-and-product.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       78  Array-Size              VALUE 10.
       01  array-area              VALUE ""01020304050607080910"".
           03  array               PIC 99 OCCURS Array-Size TIMES.

       01  array-sum               PIC 9(8).
       01  array-product           PIC 9(10) VALUE 1.

       01  i                       PIC 99.

       PROCEDURE DIVISION.
           PERFORM VARYING i FROM 1 BY 1 UNTIL Array-Size < i
               ADD array (i) TO array-sum
               MULTIPLY array (i) BY array-product
           END-PERFORM

           DISPLAY ""Sum:     "" array-sum
           DISPLAY ""Product: "" array-product

           GOBACK
           .
","This COBOL program defines an array of size 10 with predefined values. It then calculates the sum and product of the elements in the array using a loop. Finally, it displays the sum and product values before ending the program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes what the code does.,0.007313425995364251,0.86495041847229
py_1051,Python,"def modified_gan(logu, self_normalized=False, name=None):
  """"""The Modified-GAN Csiszar-function in log-space.

  A Csiszar-function is a member of,

  ```none
  F = { f:R_+ to R : f convex }.
  ```

  When `self_normalized = True` the modified-GAN (Generative/Adversarial
  Network) Csiszar-function is:

  ```none
  f(u) = log(1 + u) - log(u) + 0.5 (u - 1)
  ```

  When `self_normalized = False` the `0.5 (u - 1)` is omitted.

  The unmodified GAN Csiszar-function is identical to Jensen-Shannon (with
  `self_normalized = False`).

  Warning: this function makes non-log-space calculations and may therefore be
  numerically unstable for `|logu| >> 0`.

  Args:
    logu: `float`-like `Tensor` representing `log(u)` from above.
    self_normalized: Python `bool` indicating whether `f'(u=1)=0`. When
      `f'(u=1)=0` the implied Csiszar f-Divergence remains non-negative even
      when `p, q` are unnormalized measures.
    name: Python `str` name prefixed to Ops created by this function.

  Returns:
    chi_square_of_u: `float`-like `Tensor` of the Csiszar-function evaluated
      at `u = exp(logu)`.
  """"""

  with tf.compat.v1.name_scope(name, ""chi_square"", [logu]):
    logu = tf.convert_to_tensor(value=logu, name=""logu"")
    y = tf.nn.softplus(logu) - logu
    if self_normalized:
      y += 0.5 * tf.math.expm1(logu)
    return y","The Modified-GAN Csiszar-function in log-space.

A Csiszar-function is a member of,

```none
F = { f:R_+ to R : f convex }.
```

When `self_normalized = True` the modified-GAN (Generative/Adversarial
Network) Csiszar-function is:

```none
f(u) = log(1 + u) - log(u) + 0.5 (u - 1)
```

When `self_normalized = False` the `0.5 (u - 1)` is omitted.

The unmodified GAN Csiszar-function is identical to Jensen-Shannon (with
`self_normalized = False`).

Warning: this function makes non-log-space calculations and may therefore be
numerically unstable for `|logu| >> 0`.

Args:
  logu: `float`-like `Tensor` representing `log(u)` from above.
  self_normalized: Python `bool` indicating whether `f'(u=1)=0`. When
    `f'(u=1)=0` the implied Csiszar f-Divergence remains non-negative even
    when `p, q` are unnormalized measures.
  name: Python `str` name prefixed to Ops created by this function.

Returns:
  chi_square_of_u: `float`-like `Tensor` of the Csiszar-function evaluated
    at `u = exp(logu)`.","The Modified-GAN Csiszar-function in log-space.

  A Csiszar-function is a member of,

  ```none
  F = { f:R_+ to R : f convex }.
  ```

  When `self_normalized = True` the modified-GAN (Generative/Adversarial
  Network) Csiszar-function is:

  ```none
  f(u) = log(1 + u) - log(u) + 0.5 (u - 1)
  ```

  When `self_normalized = False` the `0.5 (u - 1)` is omitted.

  The unmodified GAN Csiszar-function is identical to Jensen-Shannon (with
  `self_normalized = False`).

  Warning: this function makes non-log-space calculations and may therefore be
  numerically unstable for `|logu| >> 0`.

  Args:
    logu: `float`-like `Tensor` representing `log(u)` from above.
    self_normalized: Python `bool` indicating whether `f'(u=1)=0`. When
      `f'(u=1)=0` the implied Csiszar f-Divergence remains non-negative even
      when `p, q` are unnormalized measures.
    name: Python `str` name prefixed to Ops created by this function.

  Returns:
    chi_square_of_u: `float`-like `Tensor` of the Csiszar-function evaluated
      at `u = exp(logu)`.",No Error,False,The documentation accurately reflects the source code details without any hallucinations or omissions.,1.0,0.9673386216163635
cob_syn_7497,COBOL,"      * REFACTOR CANDIDATE BATCH_7497
      * SYSTEM GENERATED
000001 Identification Division.
000002 Program-ID. testantlr141.
000003 Data Division.
000004 Working-Storage Section.
000005
000006 01  CONSTANTS.
000007     05  MYNAME               PIC X(012) VALUE 'testantlr141'.
000008     >>EVALUATE TRUE
000009     >>WHEN X = 3
000010     05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.
000011     >>WHEN OTHER
000012     05  PGM-0001             PIC X(008) VALUE 'PGMA0002'.
000013     >>END-EVALUATE
000014
000015*
000016
000017 Procedure Division.
000018     DISPLAY MYNAME ' Begin'
000019     CALL PGM-0001
000020
000021     DISPLAY MYNAME ' End'
000022     
000023     GOBACK
000024     .
000025
000026
",This COBOL program defines constants `MYNAME` and `PGM-0001` based on a condition and displays the value of `MYNAME` before and after calling a program based on the condition.,Legacy COBOL logic requiring documentation.,Omission,True,"The documentation fails to mention about the evaluate statement which as per a certain condition (`X=3`), assigns a different value to `PGM-0001`.",0.009849574084214482,0.8659238815307617
py_10336,Python,"def rep(parser: Union[Parser, Sequence[Input]]) -> RepeatedParser:
    """"""Match a parser zero or more times repeatedly.

    This matches ``parser`` multiple times in a row. A list is returned
    containing the value from each match. If there are no matches, an empty list
    is returned.

    Args:
        parser: Parser or literal
    """"""
    if isinstance(parser, str):
        parser = lit(parser)
    return RepeatedParser(parser)","""""""Match a parser zero or more times repeatedly.

    This function takes a parser or literal as input and matches the provided parser zero or more times in a row. It returns a list containing the value from each match. If there are no matches, an empty list is returned.

    Args:
        parser (Union[Parser, Sequence[Input]]): The parser or literal to be matched zero or more times.
    
    Returns:
        RepeatedParser: A parser that matches the provided input zero or more times.
""""""","Match a parser zero or more times repeatedly.

    This matches ``parser`` multiple times in a row. A list is returned
    containing the value from each match. If there are no matches, an empty list
    is returned.

    Args:
        parser: Parser or literal",No Error,False,The generated documentation accurately represents the source code.,0.33326145211899055,0.916671097278595
py_13145,Python,"def check_build_status(self, build_id):
        """"""Checks the status of an app-setups build.

        :param build_id: ID of the build to check.
        :returns: ``True`` if succeeded, ``False`` if pending.
        """"""
        data = self.api_request('GET', '/app-setups/%s' % build_id)

        status = data.get('status')

        if status == 'pending':
            return False
        elif status == 'succeeded':
            return True
        else:
            raise BuildError(str(data))","Checks the status of an app-setups build. 

:param build_id: ID of the build to check. 
:returns: ``True`` if succeeded, ``False`` if pending.","Checks the status of an app-setups build.

        :param build_id: ID of the build to check.
        :returns: ``True`` if succeeded, ``False`` if pending.",Omission,True,The documentation does not mention the potential for a BuildError exception to be raised.,1.0,0.9459629058837891
py_8773,Python,"def _delete_resource(self, url):
        """"""
        Canvas DELETE method.
        """"""
        params = {}
        self._set_as_user(params)
        headers = {'Accept': 'application/json',
                   'Connection': 'keep-alive'}
        url = url + self._params(params)
        response = DAO.deleteURL(url, headers)

        if not (response.status == 200 or response.status == 204):
            raise DataFailureException(url, response.status, response.data)

        return response","Deletes a resource by sending a DELETE request to the specified URL using Canvas API. It sets the necessary parameters for the request, including headers for JSON and connection keep-alive. It then sends the request using the DAO.deleteURL method and checks if the response status is either 200 or 204. If the status is different, it raises a DataFailureException. Finally, it returns the response.",Canvas DELETE method.,No Error,False,The provided documentation correctly describes the workings of the given source code without any hallucinations or omissions.,0.005860126941340088,0.8515052199363708
py_2168,Python,"def samples_like(X, hop_length=512, n_fft=None, axis=-1):
    """"""Return an array of sample indices to match the time axis from a feature matrix.

    Parameters
    ----------
    X : np.ndarray or scalar
        - If ndarray, X is a feature matrix, e.g. STFT, chromagram, or mel spectrogram.
        - If scalar, X represents the number of frames.

    hop_length : int > 0 [scalar]
        number of samples between successive frames

    n_fft : None or int > 0 [scalar]
        Optional: length of the FFT window.
        If given, time conversion will include an offset of `n_fft / 2`
        to counteract windowing effects when using a non-centered STFT.

    axis : int [scalar]
        The axis representing the time axis of X.
        By default, the last axis (-1) is taken.

    Returns
    -------
    samples : np.ndarray [shape=(n,)]
        ndarray of sample indices corresponding to each frame of X.

    See Also
    --------
    times_like : Return an array of time values to match the time axis from a feature matrix.

    Examples
    --------
    Provide a feature matrix input:

    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> X = librosa.stft(y)
    >>> samples = librosa.samples_like(X)
    >>> samples
    array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])

    Provide a scalar input:

    >>> n_frames = 2647
    >>> samples = librosa.samples_like(n_frames)
    >>> samples
    array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])
    """"""
    if np.isscalar(X):
        frames = np.arange(X)
    else:
        frames = np.arange(X.shape[axis])
    return frames_to_samples(frames, hop_length=hop_length, n_fft=n_fft)",Return an array of sample indices to match the time axis from a feature matrix.,"Return an array of sample indices to match the time axis from a feature matrix.

    Parameters
    ----------
    X : np.ndarray or scalar
        - If ndarray, X is a feature matrix, e.g. STFT, chromagram, or mel spectrogram.
        - If scalar, X represents the number of frames.

    hop_length : int > 0 [scalar]
        number of samples between successive frames

    n_fft : None or int > 0 [scalar]
        Optional: length of the FFT window.
        If given, time conversion will include an offset of `n_fft / 2`
        to counteract windowing effects when using a non-centered STFT.

    axis : int [scalar]
        The axis representing the time axis of X.
        By default, the last axis (-1) is taken.

    Returns
    -------
    samples : np.ndarray [shape=(n,)]
        ndarray of sample indices corresponding to each frame of X.

    See Also
    --------
    times_like : Return an array of time values to match the time axis from a feature matrix.

    Examples
    --------
    Provide a feature matrix input:

    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> X = librosa.stft(y)
    >>> samples = librosa.samples_like(X)
    >>> samples
    array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])

    Provide a scalar input:

    >>> n_frames = 2647
    >>> samples = librosa.samples_like(n_frames)
    >>> samples
    array([      0,     512,    1024, ..., 1353728, 1354240, 1354752])",No Error,False,"The documentation accurately describes the functionality of the function, its parameters, return, as well as providing clear examples.",4.402520529973925e-06,0.7973582744598389
py_6913,Python,"def mean_rate(self):
        """"""
        Returns the mean rate of the events since the start of the process.
        """"""
        if self.counter.value == 0:
            return 0.0
        else:
            elapsed = time() - self.start_time
            return self.counter.value / elapsed",Returns the mean rate of the events since the start of the process.,Returns the mean rate of the events since the start of the process.,No Error,False,The documentation accurately reflects what the function is doing.,1.0,1.0
cob_real_3667,COBOL,"000010 @OPTIONS MAIN,TEST
000020 Identification Division.
000030 Program-Id.  Chapt15x.
000031* Chapter 15 Exercise Solution
000041 Environment Division.
000050 Configuration Section.
000051 Special-Names.
000052       Crt Status Is Keyboard-Status
000053       Cursor Is Cursor-Position.
000055 Source-Computer.  IBM-PC.
000056 Object-Computer.  IBM-PC.
000057 Input-Output Section.
000058 File-Control.
000059     Select Dealer-File Assign To ""Dealer.Dat""
000060            Organization Indexed
000061            Access Sequential
000062            Record Key Dealer-Number Of Dealer-Record
000063            Alternate Record Key Dealer-Name Of Dealer-Record
000064            File Status Dealer-Status.
000065 Data Division.
000066 File Section.
000067 Fd  Dealer-File.
000068 01  Dealer-Record.
000069     03  Dealer-Number         Pic X(8).
000070     03  Dealer-Name.
000071         05  Last-Name   Pic X(25).
000074         05  First-Name  Pic X(15).
000075         05  Middle-Name Pic X(10).
000083     03  Address-Line-1      Pic X(50).
000085     03  Address-Line-2      Pic X(50).
000086     03  City                Pic X(40).
000087     03  State-Or-Country    Pic X(20).
000088     03  Postal-Code         Pic X(15).
000089     03  Home-Phone          Pic X(20).
000090     03  Work-Phone          Pic X(20).
000091     03  Other-Phone         Pic X(20).
000092     03  Start-Date          Pic 9(8).
000093     03  Last-Rent-Paid-Date Pic 9(8).
000094     03  Next-Rent-Due-Date  Pic 9(8).
000095     03  Rent-Amount         Pic 9(4)v99.
000096     03  Consignment-Percent Pic 9(3).
000097     03  Filler              Pic X(50).
000098 Working-Storage Section.
000108 01  Match-Flag        Pic X Value Spaces.
000109     88  Match-Found   Value ""M"".
000110     88  End-Of-File   Value ""E"".
000111* The Initialization Of Match-Name To Spaces Is Important In Case They
000112* Press The Find Next, Without Ever Entering Any Match Criteria.
000113 01  Match-Name        Value Spaces.
000114","This COBOL program defines a file structure for storing dealer information with various fields such as dealer number, name, contact details, dates, and financial information. The program includes sections for File Control, Data, and Working Storage. Additionally, it initializes flags for matching records and variables for storing search criteria in the working storage section.",Legacy COBOL logic requiring documentation.,No Error,False,The provided documentation accurately describes the given COBOL program's structure and functionality without any unsupported claims or omissions.,0.0056860862169080505,0.8614744544029236
cob_syn_9834,COBOL,"      * REFACTOR CANDIDATE BATCH_9834
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2014 ALL RIGHTS RESERVED               *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    Inquire Visit                               *
      *                                                                *
      * Select visit details from DB2 table                            *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HCIVDB01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *----------------------------------------------------------------*
      * Common defintions                                              *
      *----------------------------------------------------------------*
      * Run time (debug) infomation for this invocation
        01  WS-HEADER.
           03 WS-EYECATCHER            PIC X(16)
                                        VALUE 'H","This COBOL program, identified as HCIVDB01, retrieves visit details from a DB2 table. The code contains common definitions and debug information within the working-storage section.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation correctly summarises the purpose and key points of the source code.,0.010825057921671676,0.8716306090354919
cob_syn_4642,COBOL,"      * REFACTOR CANDIDATE BATCH_4642
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. SUM35.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  THREE-COUNTER   USAGE BINARY-CHAR value 1.
           88 IS-THREE VALUE 3.
       01  FIVE-COUNTER    USAGE BINARY-CHAR value 1.
           88 IS-FIVE VALUE 5.
       01  SUMMER          USAGE BINARY-DOUBLE value zero.
       01  I               USAGE BINARY-LONG.
       01  N               USAGE BINARY-LONG.

       PROCEDURE DIVISION.
       10-MAIN-PROCEDURE.
           MOVE 1000000000 TO N.
           MOVE 1 TO I.
           PERFORM 20-INNER-LOOP WITH TEST AFTER UNTIL I >= N.
           DISPLAY SUMMER.
           STOP RUN.
       20-INNER-LOOP.
           IF IS-THREE OR IS-FIVE
               ADD I TO SUMMER END-ADD
               IF IS-THREE
                   MOVE 1 TO THREE-COUNTER
               ELSE
                   ADD 1 TO THREE-COUNTER
               END-IF
               IF IS-FIVE
                   MOVE 1 TO FIVE-COUNTER
               ELSE
                   ADD 1 TO FIVE-COUNTER
               END-IF
           ELSE
               ADD 1 TO FIVE-COUNTER END-ADD
               ADD 1 TO THREE-COUNTER END-ADD
           END-IF.
           ADD 1 TO I.
           EXIT.
       END PROGRAM SUM35.
","This COBOL program calculates the sum of numbers up to a specified limit (1 billion in this case) that are multiples of either 3 or 5. It uses working storage variables to keep track of counts for multiples of 3 and 5, and adds the appropriate numbers to the total sum. The final sum is displayed before the program stops execution.",Legacy COBOL logic requiring documentation.,Wrong Logic / Omission,True,"The documentation claims that the program checks for multiples of 3 or 5, which isn't reflected in the code as it doesn't apply any logic to check if a number is a multiple of 3 or 5. Furthermore, it fails to mention that the counters increment irrespective of whether the number is multiple of 3 or 5, which is a critical omission.",0.005131423326712104,0.8516879677772522
py_10311,Python,"def call(results):
    """"""Call results.func on the attributes of results

    :params result: dictionary-like object
    :returns: None
    """"""
    results = vars(results)
    places = Places(config=results.pop('config'),
                    messages=results.pop('messages'))
    func = results.pop('func')
    func(places, **results)",Call results.func on the attributes of results,"Call results.func on the attributes of results

    :params result: dictionary-like object
    :returns: None",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.42437284567694994,0.8789147138595581
py_6967,Python,"def template_str(self):
        """"""Class property that returns a populated template string

        This property allows the template of a particular process to be
        dynamically generated and returned when doing ``Process.template_str``.

        Returns
        -------
        x : str
            String with the complete and populated process template

        """"""

        if not self._context:
            raise eh.ProcessError(""Channels must be setup first using the ""
                                  ""set_channels method"")

        logger.debug(""Setting context for template {}: {}"".format(
            self.template, self._context
        ))

        x = self.render(self._template_path, self._context)
        return x","Class property that returns a populated template string

This property allows the template of a particular process to be dynamically generated and returned when accessing `Process.template_str`.

Returns:
    x : str
        String with the complete and populated process template","Class property that returns a populated template string

        This property allows the template of a particular process to be
        dynamically generated and returned when doing ``Process.template_str``.

        Returns
        -------
        x : str
            String with the complete and populated process template",No Error,False,The generated documentation accurately reflects the functionality of the source code without any hallucinations or omissions.,0.852251256872198,0.9353123903274536
cob_syn_2595,COBOL,"      * REFACTOR CANDIDATE BATCH_2595
      * SYSTEM GENERATED
Caligari V00.01ALH             
PolH V0.06 Id 211536116 Parent 0 Size 00092450
Name NoName,1
center 0 0 0
x axis 1 0 0
y axis 0 1 0
z axis 0 0 1
Transform
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
World Vertices 762
0.766146 0.680483 0.284519
1.655401 1.111567 0.520398
0.907128 0.646165 0.795193
1.313948 0.554956 1.458532
1.856645 0.887426 1.218116
2.339231 0.936288 0.769292
0.451615 0.391451 0.543683
0.382212 -0.020684 0.746682
0.681458 0.234029 1.066846
0.681458 -0.275398 1.066846
1.313948 -0.679062 1.458532
1.253999 -0.062053 1.623241
1.981021 0.300615 1.649329
1.981021 -0.424722 1.649329
2.550832 -0.062053 1.502915
2.583668 0.524757 1.244204
3.114895 -0.062053 1.350339
2.972891 -0.062053 0.343318
2.831748 0.524757 0.562609
2.583668 -0.648863 1.244204
2.339231 -1.060395 0.769292
2.831748 -0.648863 0.562609
1.856645 -1.011532 1.218116
0.907128 -0.687534 0.795193
0.766146 -0.721851 0.284519
1.655401 -1.235674 0.520398
1.042427 -0.687534 -0.167513
1.996854 -0.679062 -0.417736
2.258047 -1.011532 0.115273
2.630503 -0.424722 -0.135108
2.056803 -0.062053 -0.582445
1.996854 0.554956 -0.417736
2.630503 0.300615 -0.135108
0.900377 -0.275398 -0.490845
0.524475 -0.020684 -0.265567
0.900377 0.234029 -0.490845
0.535235 0.391451 -0.051302
1.042427 0.646165 -0.167513
2.258047 0.887426 0.115273
0.309564 -0.020684 0.220351
0.451615 -0.432820 0.543683
0.535235 -0.432820 -0.051302
-1.013416 0.803828 0.066608
-0.438125 0.541163 0.151739
-0.631551 0.764486 0.547108
-0.291320 0.284506 0.603558
-0.060684 0.437810 0.322711
0.253932 0.460341 -0.073124
-1.138573 0.472478 0.589594
-1.137030 0.000000 0.727819
-0.753356 0.292008 0.784499
-0.753356 -0.292008 0.784499
-0.291320 -0.284506 0.603558
-0.265545 0.000000 0.682884
0.369308 0.167229 0.364459
0.369308 -0.167229 0.364459
0.662828 0.000000 0.143676
0.581242 0.389086 0.026050
0.700781 0.000000 -0.218314
0.457304 0.000000 -0.488862
0.460438 0.389086 -0.345746
0.581242 -0.389086 0.026050
0.253932 -0.460341 -0.073124
0.460438 -0.389086 -0.345746
-0.060","This COBOL code appears to be a comment block with metadata related to a system-generated file or program. It contains information such as version numbers, identifiers, transformation matrices, and world vertices. The purpose of this code snippet seems to be for documentation or informational purposes rather than actual program logic.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,The source code provided is not written in COBOL as claimed in the generated documentation.,0.006065997938636506,0.8690049052238464
cob_real_1440,COBOL,"       01 DataRec.
          88 EndOf-:tag: value high-values.
          02 DistrictId-:tag:.
             03 StateId-:tag: pic 99.
             03 FILLER pic 999.
          02 Date-:tag:.
             03 Year-:tag: pic 9999.
             03 Month-:tag: pic 99.
             03 Day-:tag: pic 99.
          02 Cases-:tag: pic 9(6).
","Defines a data record structure with fields for District ID (composed of State ID), Date (with Year, Month, and Day parts), and number of cases. The structure includes a flag for the end of the data.",Legacy COBOL logic requiring documentation.,Omission,True,The generated documentation fails to mention the FILLER field in the software code.,0.0,0.8371434807777405
py_12964,Python,"def activate_pdb_hook():
    ''' Catch exceptions with a prompt for post-mortem analyzis'''
    def debug_exception(type_exception, value, tb):
        import pdb
        pdb.post_mortem(tb)

    import sys
    sys.excepthook = debug_exception",Catch exceptions with a prompt for post-mortem analysis using the Python debugger (pdb) when an exception occurs.,Catch exceptions with a prompt for post-mortem analyzis,No Error,False,"The documentation accurately describes what the code does, without any hallucinations or omissions.",0.34823528327578535,0.910352885723114
cob_syn_10107,COBOL,"      * REFACTOR CANDIDATE BATCH_10107
      * SYSTEM GENERATED
        identification division.
        program-id. func1.
        data division.
        working-storage section.

        linkage section.

        01 ctxt                 usage pointer.
        01 idata                usage pointer.
        01 ilen                 usage binary-long.
        01 odata                usage pointer.
        01 olen                 usage binary-long.


        procedure division using ctxt, idata, ilen, odata, olen.

        display idata(1:ilen).

        end program func1.
","This COBOL code defines a program named `func1` that takes in several parameters: `ctxt`, `idata`, `ilen`, `odata`, and `olen`. It displays a portion of the data pointed to by `idata` based on the length specified in `ilen`. The program does not perform any further processing and simply outputs the specified data.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation correctly summarizes the provided source code.,0.005965939103175657,0.8448951840400696
cob_syn_2182,COBOL,"      * REFACTOR CANDIDATE BATCH_2182
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. get-expiry-date.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT F-USERS-FILE ASSIGN TO 'users.dat'
             ORGANIZATION IS SEQUENTIAL.
       
       DATA DIVISION.
       FILE SECTION.
           FD F-USERS-FILE.
           01 USERS.
              05 USERNAME PIC X(16).
              05 USER-PASSWORD PIC X(20).
              05 USER-CREDITS PIC 9(3).
              05 USER-LEVEL PIC X(3).
              05 CARD-NO PIC 9(16).
              05 CARD-EXPIRY PIC 9(4).
              05 CARD-CVV PIC 9(3).
              05 FILLER PIC X VALUE X'0A'.

       WORKING-STORAGE SECTION.
           01 FINISHED PIC X VALUE ""N"".

           01 WS-USERS.
              05 WS-USERNAME PIC X(16).
              05 WS-USER-PASSWORD PIC X(20).
              05 WS-USER-CREDITS PIC 9(3).
              05 WS-USER-LEVEL PIC X(3).
              05 WS-CARD-NO PIC 9(16).
              05 WS-CARD-EXPIRY PIC 9(4).
              05 WS-CARD-CVV PIC 9(3).
              05 FILLER PIC X VALUE X'0A'.
    
       LINKAGE SECTION.
           01 LS-USERNAME PIC X(16).
           01 LS-CARD-EXP PIC 9(4). 
       
       PROCEDURE DIVISION USING LS-USERNAME, LS-CARD-EXP.

           MOVE ""N"" TO FINISHED.
           OPEN INPUT F-USERS-FILE.
           PERFORM UNTIL FINISHED = ""Y""
               READ F-USERS-FILE INTO WS-USERS
                 AT END MOVE ""Y"" TO FINISHED
                 NOT AT END PERFORM GET-CARD-EXP-PROCESS
               END-READ        
           END-PERFORM.    
           CLOSE F-USERS-FILE.
         
           GOBACK.  

       GET-CARD-EXP-PROCESS.
           IF WS-USERNAME = LS-USERNAME THEN
               MOVE WS-CARD-EXPIRY TO LS-CARD-EXP
           END-IF.
","This COBOL program defines a subroutine called ""get-expiry-date"" that reads user data from a file called ""users.dat"" and retrieves the expiration date of a user's card based on the provided username. The subroutine takes input parameters for the username and a variable to store the card expiration date. It reads user records from the file, compares the username, and if a match is found, it retrieves the card expiration date and stores it in the provided variable.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.004214353393030252,0.8462985157966614
cob_real_117,COBOL,"      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2014 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *               COPYBOOK for COMMAREA structure                  *
      *                                                                *
      *   This commarea can be used for Inq Medications                *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************
           03 CA-REQUEST-ID            PIC X(6).
           03 CA-RETURN-CODE           PIC 9(2).
           03 CA-PATIENT-ID            PIC 9(10).
      *    Fields used in Inquire Medications
           03 CA-LIST-MEDICATION-REQUEST.
              05 CA-NUM-MEDICATIONS    PIC 99 COMP-3.
              05 CA-MEDICATIONS OCCURS 0 to 50 times
                 depending on CA-NUM-MEDICATIONS.
                 10 CA-MEDICATION-ID      PIC 9(10).
                 10 CA-DRUG-NAME          PIC X(50).
           ","This COBOL code defines a copybook structure for a COMMAREA used for inquiring about medications. It includes fields such as CA-REQUEST-ID, CA-RETURN-CODE, CA-PATIENT-ID, CA-LIST-MEDICATION-REQUEST with subfields like CA-NUM-MEDICATIONS, CA-MEDICATIONS that can occur up to 50 times with fields like CA-MEDICATION-ID and CA-DRUG-NAME.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the source code without any hallucinations or omissions.,0.00702083472657119,0.8370402455329895
py_4681,Python,"def is_in_database(self):
        """"""
        Check if the element is into the database.
        """"""

        if (
            self._authorization()
            and PyFunceble.INTERN[""file_to_test""] in PyFunceble.INTERN[""whois_db""]
            and PyFunceble.INTERN[""to_test""]
            in PyFunceble.INTERN[""whois_db""][PyFunceble.INTERN[""file_to_test""]]
        ):
            # * We are authorized to work.
            # and
            # * The given file path exist in the database.
            # and
            # * The element we are testing is in the database related to the
            # given file path.

            # We return True, the element we are testing is into the database.
            return True

        # * We are not authorized to work.
        # or
        # * The given file path does not exist in the database.
        # or
        # * The element we are testing is not in the database related to the
        # given file path.

        # We return False,the element we are testing is not into the database.
        return False",Check if the element is in the database.,Check if the element is into the database.,No Error,False,The code and its corresponding documentation align properly without any unsupported claims or missing critical information.,0.5946035575013605,0.9826974868774414
py_8679,Python,"def create_route_long_name(relation, short_name):
    """"""Create a meaningful route name.""""""
    if relation.tags.get('from') and relation.tags.get('to'):
        return ""{0}-to-{1}"".format(relation.tags.get('from'),
                                   relation.tags.get('to'))
    name = relation.tags.get('name') or\
        relation.tags.get('alt_name') or\
        ""OSM Route No. {}"".format(relation.id)

    # Drop route_short_name from this one if it contains it
    if short_name and name.startswith(short_name):
        # Drop it
        return name[len(short_name):]
    return name","Create a meaningful route name. The function takes a relation and a short name as input. It first checks if 'from' and 'to' tags exist in the relation. If they do, it constructs a route name in the format ""{from}-to-{to}"". If 'from' and 'to' tags do not exist, it looks for 'name' or 'alt_name' in the relation tags. If neither 'name' nor 'alt_name' exist, it generates a default route name using the relation ID. Finally, if a short name is provided and it matches the beginning of the constructed route name, it removes the short name from the beginning of the route name before returning it.",Create a meaningful route name.,No Error,False,The documentation accurately represents the function's logic and the variable usage.,0.03167407052850985,0.862263560295105
py_4575,Python,"def syntax_check(domain):  # pragma: no cover
    """"""
    Check the syntax of the given domain.

    :param domain: The domain to check the syntax for.
    :type domain: str

    :return: The syntax validity.
    :rtype: bool

    .. warning::
        If an empty or a non-string :code:`domain` is given, we return :code:`None`.
    """"""

    if domain and isinstance(domain, str):
        # * The given domain is not empty nor None.
        # and
        # * The given domain is a string.

        # We silently load the configuration.
        load_config(True)

        return Check(domain).is_domain_valid()

    # We return None, there is nothing to check.
    return None","Check the syntax of the given domain. If an empty or a non-string domain is provided, return None. Return the syntax validity as a boolean value.","Check the syntax of the given domain.

    :param domain: The domain to check the syntax for.
    :type domain: str

    :return: The syntax validity.
    :rtype: bool

    .. warning::
        If an empty or a non-string :code:`domain` is given, we return :code:`None`.",No Error,False,The provided documentation accurately reflects the source code.,0.26766292870922187,0.8598794937133789
py_8081,Python,"def get_config_params(properties):
    '''Extract the set of configuration parameters from the properties attached
    to the schedule
    '''
    param = []
    wdef = ''
    for prop in properties.split('\n'):
        if prop.startswith('org.opencastproject.workflow.config'):
            key, val = prop.split('=', 1)
            key = key.split('.')[-1]
            param.append((key, val))
        elif prop.startswith('org.opencastproject.workflow.definition'):
            wdef = prop.split('=', 1)[-1]
    return wdef, param",Extract the set of configuration parameters from the properties attached to the schedule,"Extract the set of configuration parameters from the properties attached
    to the schedule",Omission,True,"The documentation has omitted the functionality of the function splitting and comparing the properties, the return of the workflow definition and the parameters, as well as how it deals with multiple 'org.opencastproject.workflow.config' and single 'org.opencastproject.workflow.definition' properties.",1.0,0.9409591555595398
cob_syn_5529,COBOL,"      * REFACTOR CANDIDATE BATCH_5529
      * SYSTEM GENERATED
       PROCESS NODYNAM,RENT,APOST,CICS,TRUNC(OPT)
      
      *****************************************************************
      * Licensed Materials - Property of IBM
      *
      * SAMPLE
      *
      * Copyright IBM Corp. 2017 All Rights Reserved
      *
      * Government Users Restricted Rights - Use, duplication or
      * disclosure restricted by GSA ADP Schedule Contract with
      * IBM Corp.
      *
      *****************************************************************
      *
      * Very simple program to take no commarea and write a message
      * using the COBOL DISPLAY command.
      *
      *****************************************************************
      
       IDENTIFICATION DIVISION.
       PROGRAM-ID.              PROG1.
       DATE-WRITTEN.            May 2017.
      *
       ENVIRONMENT DIVISION.
      *
       DATA DIVISION.
      *
       WORKING-STORAGE SECTION.
      *
       LINKAGE SECTION.
      *
       PROCEDURE DIVISION USING DFHEIBLK DFHCOMMAREA.
      *
       MAIN-PROCESSING SECTION.
      *
      *    No data in, no data out. Use DISPLAY to indicate success
           DISPLAY 'Task ' EIBTASKN ' in PROG1'.
      *
      *    Back to CICS
           EXEC CICS RETURN END-EXEC.
      *
           GOBACK.
",This COBOL program is a simple batch program that takes no communication area input and writes a message using the COBOL DISPLAY command. It displays a message indicating the task number within the program and then returns control back to CICS (Customer Information Control System).,Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the function and operation of the source code.,0.006626589205134352,0.8592337965965271
cob_real_3476,COBOL,"       >>SOURCE FREE
program-id. helloat.
procedure division.
    display ""Hello, world! "" line 5 column 5 end-display
    call ""C$SLEEP"" using 1 end-call
    stop run.
","This COBOL program is a simple ""Hello, world!"" program that displays the message ""Hello, world!"" on the screen at line 5, column 5. It then calls a function to sleep for 1 second before terminating the program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly summaries the functionality of the code.,0.007805988703535686,0.8608660101890564
cob_real_2743,COBOL,"      ******************************************************************
      *       SQLCA: SQL Communications Area for Ocesql                *
      ******************************************************************
       01  SQLCA GLOBAL.
           05  SQLCAID               PIC X(8).
           05  SQLCABC               PIC S9(9) COMP-5.
           05  SQLCODE               PIC S9(9) COMP-5.
           05  SQLERRM.
           49  SQLERRML              PIC S9(4) COMP-5.
           49  SQLERRMC              PIC X(70).
           05  SQLERRP               PIC X(8).                          *> not used
           05  SQLERRD OCCURS 6 TIMES                                   *> used only ERRD(3)
                                     PIC S9(9) COMP-5.
           05  SQLWARN.                                                 *> not used
               10 SQLWARN0           PIC X(1).
               10 SQLWARN1           PIC X(1).
               10 SQLWARN2           PIC X(1).
               10 SQLWARN3           PIC X(1).
               10 SQLWARN4           PIC X(1).
               10 SQLWARN5           PIC X(1).
               10 SQLWARN6           PIC X(1).
               10 SQLWARN7           PIC X(1).
           05  SQLSTATE              PIC X(5).
      ******************************************************************
","This COBOL code defines the structure of the SQL Communications Area (SQLCA) for Ocesql. It includes fields for SQLCAID, SQLCABC, SQLCODE, SQLERRM (consisting of SQLERRML and SQLERRMC), SQLERRP (not used), SQLERRD (a group of 6 elements but only ERRD(3) is used), SQLWARN (not used), and SQLSTATE. These fields are used for storing SQL communication information during program execution.",Legacy COBOL logic requiring documentation.,No Error,False,The provided documentation accurately describes what the COBOL code defines without hallucinations or omissions.,0.005354194904142114,0.838403582572937
py_8609,Python,"def ERROR(self):
        """"""ERROR state.""""""
        logger.debug('In state: ERROR')
        self.current_state = STATE_ERROR
        if self.script is not None:
            self.script.script_init(self.client.lease, self.current_state)
            self.script.script_go()
        set_net(self.client.lease)
        raise self.INIT()","Set the current state to ERROR, initializes the script with the current lease and state, executes the script, sets the network, and raises an INIT exception.",ERROR state.,Omission,True,The documentation does not mention the logging of 'In state: ERROR' function.,0.0,0.8534849286079407
cob_syn_5596,COBOL,"      * REFACTOR CANDIDATE BATCH_5596
      * SYSTEM GENERATED
        identification division.
            program-id. test-program.
        environment division.
        data division.
        working-storage section.
        01 various-numbers.
            05 entry-one   pic is 9,999.99 value is 12345.
            05 filler      pic is X value is space.
            05 entry-two   pic is 9,999.ZZ value is 12345.
            05 filler      pic is X value is space.
            05 entry-three pic is 9999.99 value is 12345.
            05 filler      pic is X value is space.
            05 entry-four  pic is 9,999.99 value is 12.3.
            05 filler      pic is X value is space.
            05 entry-five  pic is $9,999,999.99 value is 239847.
        01 other-numbers.
            05 other-one   pic is 9,999V99 value is 12345.
            05 filler      pic is X value is space.
            05 other-two   pic is 9,999V00 value is 12345.
            05 filler      pic is X value is space.
            05 other-three pic is 9999V99 value is 12345.
            05 filler      pic is X value is space.
            05 other-four  pic is 9,999V99 value is 12.3.
            05 filler      pic is X value is space.
            05 other-five  pic is $9,999,999V99 value is 239847.

        procedure division.
            display "" ,123.45  ,123.00  123.45  ,   .12 $ ,  2,398.47"".
            display ""------------------------------------------------"".
            display various-numbers.
            display "" "".
            display ""2,345.00 2,345.00 2345.00  , 12.30 $ ,239,847.00"".
            display ""------------------------------------------------"".
            display other-numbers.
",This COBOL program defines variables to hold various numbers with different formatting specifications and values. It then displays these numbers in a specific format using the DISPLAY statement in the PROCEDURE DIVISION. The program outputs the formatted numbers for 'various-numbers' and 'other-numbers' along with a separator line.,Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention about the purpose and role of 'filler' variables in the code.,0.006389329974674238,0.8592323064804077
cob_syn_273,COBOL,"      * REFACTOR CANDIDATE BATCH_273
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    House Policy Menu                           *
      *                                                                *
      * Menu for House Policy Transactions                             *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGTESTP3.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       77 MSGEND                       PIC X(24) VALUE
                                        'Transaction ended      '.

       COPY SSMAP.
       01 COMM-AREA.
       COPY LGCMAREA.

      *------------------","This COBOL program defines a menu for House Policy Transactions. It includes licensing information, a message variable, and copies external map and communication area files. The program is identified as LGTESTP3 and contains working storage variables for managing transactions.",Legacy COBOL logic requiring documentation.,No Error,False,"The generated documentation accurately describes the key features of the provided source code, including licensing, program identification, and copied files.",0.007469938459592591,0.865529477596283
py_14038,Python,"def _upload_file_to_gdoc(
            self, file_path,
            content_type='application/x-vnd.oasis.opendocument.spreadsheet'):
        """"""
        Uploads file to GDocs spreadsheet.
        Content type can be provided as argument, default is ods.
        """"""
        try:
            entry = self.gd_client.GetResourceById(self.key)
            media = gdata.data.MediaSource(
                file_path=file_path, content_type=content_type)
            self.gd_client.UpdateResource(
                entry, media=media, update_metadata=True)
        except (RequestError, IOError) as e:
            raise PODocsError(e)","Uploads file to Google Docs spreadsheet with the provided file path and content type. Default content type is 'application/x-vnd.oasis.opendocument.spreadsheet'. If there is an error during the upload process, a PODocsError is raised.","Uploads file to GDocs spreadsheet.
        Content type can be provided as argument, default is ods.",No Error,False,The documentation matches the function logic and includes all the important details.,0.04685289671850757,0.856989324092865
cob_syn_10537,COBOL,"      * REFACTOR CANDIDATE BATCH_10537
      * SYSTEM GENERATED
*> Hello, world
identification division.
program-id. helloworld.

procedure division.
display ""Hello, world""
goback.
end program hello.
","This COBOL code defines a program called ""helloworld"" that simply displays the text ""Hello, world"" on the screen and then exits. This program serves as a basic example of a COBOL program that prints a greeting message.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.007805988703535686,0.868965208530426
cob_syn_239,COBOL,"      * REFACTOR CANDIDATE BATCH_239
      * SYSTEM GENERATED
       PROGRAM-ID. Perform-Example.

       PROCEDURE DIVISION.
       Main.
           PERFORM Moo
           PERFORM Display-Stuff
           PERFORM Boo THRU Moo

           GOBACK
           .

       Display-Stuff SECTION.
       Foo.
           DISPLAY ""Foo "" WITH NO ADVANCING
           .

       Boo.
           DISPLAY ""Boo "" WITH NO ADVANCING
           .

       Moo.
           DISPLAY ""Moo""
           .
","This COBOL program defines a `Perform-Example` program with three procedures named `Display-Stuff`, `Foo`, `Boo`, and `Moo`. In the `Main` procedure, it calls the `Moo` procedure, then the `Display-Stuff` procedure, and finally performs a range from `Boo` to `Moo`. The program displays ""Moo"" in the `Moo` procedure and prefixes ""Foo "" and ""Boo "" without advancing to a new line in the `Foo` and `Boo` procedures, respectively.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,The sequence of the procedure calls as documented doesn't match with the sequence coded in the `Main` procedure.,0.004801387150967651,0.8236851096153259
py_13087,Python,"def assign_force_field(ampal_obj, ff):
    """"""Assigns force field parameters to Atoms in the AMPAL object.

    Parameters
    ----------
    ampal_obj : AMPAL Object
        Any AMPAL object with a `get_atoms` method.
    ff: BuffForceField
        The force field to be used for scoring.
    """"""
    if hasattr(ampal_obj, 'ligands'):
        atoms = ampal_obj.get_atoms(ligands=True, inc_alt_states=True)
    else:
        atoms = ampal_obj.get_atoms(inc_alt_states=True)
    for atom in atoms:
        w_str = None
        a_ff_id = None
        if atom.element == 'H':
            continue
        elif atom.parent.mol_code.upper() in ff:
            if atom.res_label.upper() in ff[atom.parent.mol_code]:
                a_ff_id = (atom.parent.mol_code.upper(),
                           atom.res_label.upper())
            elif atom.res_label.upper() in ff['WLD']:
                a_ff_id = ('WLD', atom.res_label.upper())
            else:
                w_str = ('{} atom is not parameterised in the selected '
                         'force field for {} residues, this will be '
                         'ignored.').format(
                             atom.res_label, atom.parent.mol_code)
        elif atom.res_label.upper() in ff['WLD']:
            a_ff_id = ('WLD', atom.res_label.upper())
        else:
            w_str = ('{} ({}) atom is not parameterised in the selected'
                     ' residue force field.').format(
                         atom.res_label, atom.parent.mol_code)
        if w_str:
            warnings.warn(w_str, NotParameterisedWarning)
        atom.tags['_buff_ff_id'] = a_ff_id
    return",Assigns force field parameters to Atoms in the AMPAL object.,"Assigns force field parameters to Atoms in the AMPAL object.

    Parameters
    ----------
    ampal_obj : AMPAL Object
        Any AMPAL object with a `get_atoms` method.
    ff: BuffForceField
        The force field to be used for scoring.",No Error,False,The documentation accurately describes the purpose and functionality of the provided function.,0.10025884372280375,0.8592913150787354
py_11861,Python,"def with_ignored_exceptions(self, *ignored_exceptions):
        """"""
        Set a list of exceptions that should be ignored inside the wait loop.
        """"""
        for exception in ignored_exceptions:
            self._ignored_exceptions = self._ignored_exceptions + (exception,)
        return self",Set a list of exceptions that should be ignored inside the wait loop.,Set a list of exceptions that should be ignored inside the wait loop.,Omission,True,The documentation does not explain that the method takes as arguments any number of exceptions to be ignored and adds them to an existing list of ignored exceptions.,1.0,1.0000001192092896
py_7186,Python,"def set_task(translator, translit=False):
    """"""
    Task Setter Coroutine

    End point destination coroutine of a purely consumer type.
    Delegates Text IO to the `write_stream` function.

    :param translation_function: Translator
    :type translation_function: Function

    :param translit: Transliteration Switch
    :type translit: Boolean
    """"""
    # Initialize Task Queue
    task    = str()
    queue   = list()

    # Function Partial
    output  = ('translit' if translit else 'trans')
    stream  = partial(write_stream, output=output)
    workers = ThreadPoolExecutor(max_workers=8)

    try:
        while True:

            task = yield
            queue.append(task)

    except GeneratorExit:
        list(map(stream, workers.map(translator, queue)))","Task Setter Coroutine

End point destination coroutine of a purely consumer type. Delegates Text IO to the `write_stream` function.

:param Translator: translation_function
:type Translator: Function

:param translit: Transliteration Switch
:type translit: Boolean","Task Setter Coroutine

    End point destination coroutine of a purely consumer type.
    Delegates Text IO to the `write_stream` function.

    :param translation_function: Translator
    :type translation_function: Function

    :param translit: Transliteration Switch
    :type translit: Boolean",Fabricated Variable,True,The parameter name 'translation_function' in the documentation does not match with the parameter 'translator' in the source code.,0.8241259434125672,0.9029000401496887
py_4532,Python,"async def currently_playing(self) -> Tuple[Context, Track]:
        """"""Get the users currently playing track.

        Returns
        -------
        context, track : Tuple[Context, Track]
            A tuple of the context and track.
        """"""
        data = await self.http.currently_playing()

        if data.get('item'):
            data['Context'] = Context(data.get('context'))
            data['item'] = Track(self.__client, data.get('item'))

        return data","""""""A method to get the users currently playing track. It sends a request to the music API to retrieve information about the current track being played. If the response includes a track item, it creates instances of the Context and Track classes with the retrieved data. Returns a tuple containing the Context and Track instances.""""""","Get the users currently playing track.

        Returns
        -------
        context, track : Tuple[Context, Track]
            A tuple of the context and track.",Omission,True,The documentation doesn't mention what happens if the response does not include a track item.,0.07968371423736574,0.7953206896781921
cob_real_1778,COBOL,"***********************************************************************
*
*  Copyright (c) 2020 NuWave Technologies, Inc. All rights reserved.
*
************************************************************************
*?env common
 IDENTIFICATION DIVISION.
 PROGRAM-ID. SERVCOB.
 ENVIRONMENT DIVISION.
 CONFIGURATION SECTION.
 SOURCE-COMPUTER.  T16.
 OBJECT-COMPUTER.  T16.
 INPUT-OUTPUT SECTION.
 FILE-CONTROL.

 SELECT RECV-MSG
    ASSIGN TO $RECEIVE.

 RECEIVE-CONTROL.
    TABLE OCCURS 5 TIMES
    SYNCDEPTH IS 2
    REPLY CONTAINS RECV-MSG RECORD.
 
 DATA DIVISION.
 FILE SECTION.

    FD  RECV-MSG
        RECORD IS VARYING IN SIZE
        DEPENDING ON RECV-MSG-LEN.


   COPY LW-ML-MSG-LOG-RQ  IN LWMLCOPY.
   COPY LW-ML-MSG-LOG-RP  IN LWMLCOPY.

   01 RECV-MSG-BUFFER.
      05 RECV-MSG-BYTES   PIC X(1) OCCURS 32000.


 WORKING-STORAGE SECTION.

    01  SET-SWITCH      PIC 9 VALUE 1.
    01  CLEAR-SWITCH    PIC 9 VALUE 0.
    01  EOF-SWITCH      PIC 9 VALUE 0.
        88  EOF         VALUE 1.

    01  FILE-STATUS     PIC XX.
    01  RECV-MSG-LEN PIC 9(5) COMP.
    01  STRING-OFFSET   PIC 9(5) COMP.
    01  STRING-VALUE    PIC X(256).
    01  IDX             PIC 9(5) COMP.
    01  NV-COUNT        PIC 9(5) COMP.
    01  NV-OFFSET       PIC 9(5) COMP.
    01  NV-PAIRS.
        05 NV-PAIR      OCCURS 50 TIMES.
          10 NAME       PIC X(32).
          10 VAL        PIC X(32).
    01 WS-ARRAY.
        05 BYTE         OCCURS 2048 TIMES PIC X(1).
/
 PROCEDURE DIVISION.
 MAIN SECTION.

    OPEN I-O RECV-MSG SHARED SYNCDEPTH 1

    PERFORM RECEIVE-LOOP THRU RECEIVE-LOOP-EXIT
        UNTIL EOF.

    CLOSE RECV-MSG.

    STOP RUN.

 RECEIVE-LOOP.

    READ RECV-MSG
        AT END
            MOVE SET-SWITCH TO EOF-SWITCH
            GO TO RECEIVE-LOOP-EXIT.

    IF LW-ML-RQ-MSG-LOG OF HEADER OF LW-ML-MSG-LOG-RQ
        PERFORM LOG-REQUEST THRU LOG-REQUEST-EXIT
        GO TO RECEIVE-LOOP-EXIT.

    SET LW-ML-RP-ERROR OF HEADER OF LW-ML-MSG-LOG-RP TO TRUE.
    WRITE LW-ML-MSG-LO","This COBOL program defines a procedure to handle incoming messages received in a loop. It reads a message, logs the request, and checks for errors. The program runs until the end of file is reached. It uses working storage sections to manage switches, file status, message lengths, offsets, and arrays. It opens and closes the message file and includes error handling logic throughout the process.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.005783931791426253,0.8674386739730835
cob_real_1253,COBOL,"       IDENTIFICATION DIVISION.
       PROGRAM-ID. SAMPLE.

       DATA DIVISION.
       WORKING-STORAGE SECTION.

         01 binary_number   pic X(21).
         01 str             pic X(21).
         01 binary_digit    pic X.
         01 digit           pic 9.
         01 n               pic 9(7).
         01 nstr            pic X(7).

       PROCEDURE DIVISION.
         accept nstr
         move nstr to n
         perform until n equal 0
           divide n by 2 giving n remainder digit
           move digit to binary_digit
           string binary_digit  DELIMITED BY SIZE
                  binary_number DELIMITED BY SPACE
                  into str
           move str to binary_number
         end-perform.
         display binary_number
         stop run.
","This COBOL program converts a given decimal number into its binary equivalent. It accepts a numerical string input, converts it to a number, and iteratively divides by 2 to find the binary digits. The binary representation is stored in the `binary_number` variable and displayed at the end.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes what the COBOL program is designed to do and no critical information is missing.,0.006389329974674238,0.8561968803405762
py_2978,Python,"def skipped(self):
        '''Whether the solid execution was skipped'''
        return all(
            [
                step_event.event_type == DagsterEventType.STEP_SKIPPED
                for step_event in itertools.chain(
                    self.input_expectations, self.output_expectations, self.transforms
                )
            ]
        )",Whether the solid execution was skipped,Whether the solid execution was skipped,No Error,False,The documentation accurately describes the function of the code.,1.0,1.0
cob_syn_5883,COBOL,"      * REFACTOR CANDIDATE BATCH_5883
      * SYSTEM GENERATED
         05  CHECKLISTE.
           10 VSNR             PIC S9(13)V PACKED-DECIMAL.
           10 SDNR             PIC S9(07)V PACKED-DECIMAL.
           10 TEILAKTE-LFDNR   PIC S9(09)  BINARY.
           10 HERSTELLER       PIC  X(60).
           10 FAHRZEUGTYP      PIC  X(60).
           10 LEISTUNG-KW      PIC S9(04)  BINARY.
           10 ERSTZULASSUNG    PIC  X(10).
           10 MASSNAHME1-SCHL  PIC S9(04)  BINARY.
           10 MASSNAHME2-SCHL  PIC S9(04)  BINARY.
           10 MASSNAHME3-SCHL  PIC S9(04)  BINARY.
           10 MASSNAHME4-SCHL  PIC S9(04)  BINARY.
           10 ABR-WUNSCH-SCHL  PIC S9(04)  BINARY.
           10 AUTOZAHLUNG-JN   PIC S9(01)V PACKED-DECIMAL.
           10 ZAHL-ADR-CODE    PIC  X(06).
           10 HERGANG-SCHL     PIC S9(04)  BINARY.

","Defines a data structure `CHECKLISTE` with various fields such as vehicle number (`VSNR`), serial number (`SDNR`), manufacturer (`HERSTELLER`), vehicle type (`FAHRZEUGTYP`), power in kilowatts (`LEISTUNG-KW`), and other related information. The fields are specified with different data types including packed decimal, binary, and alphanumeric.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately and comprehensively describes the source code without any fabrications or omissions.,0.0,0.8101387023925781
py_1543,Python,"def save_model_details(self, path="""", force=False):
        """"""
        Save Model Details of an H2O Model in JSON Format to disk.

        :param model: The model object to save.
        :param path: a path to save the model details at (hdfs, s3, local)
        :param force: if True overwrite destination directory in case it exists, or throw exception if set to False.

        :returns str: the path of the saved model details
        """"""
        assert_is_type(path, str)
        assert_is_type(force, bool)
        path = os.path.join(os.getcwd() if path == """" else path, self.model_id + "".json"")
        return h2o.api(""GET /99/Models/%s/json"" % self.model_id, data={""dir"": path, ""force"": force})[""dir""]",Save Model Details of an H2O Model in JSON Format to disk.,"Save Model Details of an H2O Model in JSON Format to disk.

        :param model: The model object to save.
        :param path: a path to save the model details at (hdfs, s3, local)
        :param force: if True overwrite destination directory in case it exists, or throw exception if set to False.

        :returns str: the path of the saved model details",Fabricated Variable / Omission,True,"The generated documentation refers to a 'model' parameter which does not exist in the source code, and fails to document the 'self' parameter.",0.019907342077733675,0.8585357069969177
cob_syn_9334,COBOL,"      * REFACTOR CANDIDATE BATCH_9334
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. SPCLNAMES.
 ENVIRONMENT DIVISION.
    SPECIAL-NAMES.
        CHANNEL 2 IS SOMEMNEMONIC
        ODT SOMEMNEMONIC
        CLASS SOMECLASSNAME FOR NATIONAL SOMEFROM THRU SOMETO SOMEFROM2 THROUGH SOMETO2
        CURRENCY SIGN 'E' PICTURE SYMBOL '-'
        DECIMAL-POINT IS COMMA
        RESERVE WORDS NETWORK
        SYMBOLIC CHARACTERS NATIONAL ABC IS 1 IN SOMEALPHABET
        DEFAULT-DISPLAY TRAILING
        ALPHABET SOMEALPHABET1 FOR NATIONAL IS NATIVE
        ALPHABET SOMEALPHABET2 FOR NATIONAL IS CCSVERSION 123
        ALPHABET SOMEALPHABET3 FOR ALPHANUMERIC IS EBCDIC
        ALPHABET SOMEALPHABET4 FOR ALPHANUMERIC IS SOMECOBOLWORD
        ALPHABET SOMEALPHABET5 FOR ALPHANUMERIC IS 1 ALSO 7 8 ALSO 11
        .","Defines special configurations and naming conventions for the Cobol program `SPCLNAMES`. This includes defining special channel, mnemonic names, class names, currency sign, decimal point, reserved words, symbolic characters, display format, alphabets, and other settings for the program environment.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.0,0.8312976956367493
py_3592,Python,"def collect_string_fields(format_string) -> Iterable[Optional[str]]:
    """""" Given a format string, return an iterator
    of all the valid format fields. It handles nested fields
    as well.
    """"""
    formatter = string.Formatter()
    try:
        parseiterator = formatter.parse(format_string)
        for result in parseiterator:
            if all(item is None for item in result[1:]):
                # not a replacement format
                continue
            name = result[1]
            nested = result[2]
            yield name
            if nested:
                for field in collect_string_fields(nested):
                    yield field
    except ValueError as exc:
        # Probably the format string is invalid.
        if exc.args[0].startswith(""cannot switch from manual""):
            # On Jython, parsing a string with both manual
            # and automatic positions will fail with a ValueError,
            # while on CPython it will simply return the fields,
            # the validation being done in the interpreter (?).
            # We're just returning two mixed fields in order
            # to trigger the format-combined-specification check.
            yield """"
            yield ""1""
            return
        raise IncompleteFormatString(format_string)","Given a format string, return an iterator of all the valid format fields. It handles nested fields as well.","Given a format string, return an iterator
    of all the valid format fields. It handles nested fields
    as well.",Omission,True,The documentation does not explain the function's exception handling behavior or describe its input and output.,1.0,0.9407117962837219
py_5008,Python,"def item_move(self, request, tree_id, item_id, direction):
        """"""Moves item up or down by swapping 'sort_order' field values of neighboring items.""""""
        current_item = MODEL_TREE_ITEM_CLASS._default_manager.get(pk=item_id)
        if direction == 'up':
            sort_order = 'sort_order'
        else:
            sort_order = '-sort_order'

        siblings = MODEL_TREE_ITEM_CLASS._default_manager.filter(
            parent=current_item.parent,
            tree=current_item.tree
        ).order_by(sort_order)

        previous_item = None
        for item in siblings:
            if item != current_item:
                previous_item = item
            else:
                break

        if previous_item is not None:
            current_item_sort_order = current_item.sort_order
            previous_item_sort_order = previous_item.sort_order

            current_item.sort_order = previous_item_sort_order
            previous_item.sort_order = current_item_sort_order

            current_item.save()
            previous_item.save()

        return HttpResponseRedirect('../../')",Moves an item up or down by swapping the 'sort_order' field values of neighboring items in the database.,Moves item up or down by swapping 'sort_order' field values of neighboring items.,Omission,True,"The documentation did not specify the logic for determining the direction of the move ('up' or 'down'), and it doesn't explain the usage of the parameters in the function.",0.47631009147745074,0.9757673740386963
cob_syn_1678,COBOL,"      * REFACTOR CANDIDATE BATCH_1678
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
      *
       PROGRAM-ID.  CUSTMNT2.
      *
       ENVIRONMENT DIVISION.
      *
       DATA DIVISION.
      *
       WORKING-STORAGE SECTION.
      *
       01  SWITCHES.
      *
           05  VALID-DATA-SW                 PIC X(01) VALUE 'Y'.
               88  VALID-DATA                          VALUE 'Y'.
      *
       01  FLAGS.
      *
           05  SEND-FLAG                     PIC X(01).
               88  SEND-ERASE                       VALUE '1'.
               88  SEND-ERASE-ALARM                 VALUE '2'.
               88  SEND-DATAONLY                    VALUE '3'.
               88  SEND-DATAONLY-ALARM              VALUE '4'.
      *
       01  WORK-FIELDS.
      *
           05  RESPONSE-CODE                 PIC S9(08) COMP.
      *
       01  USER-INSTRUCTIONS.
      *
           05  ADD-INSTRUCTION               PIC X(79) VALUE
               'Type information for new customer.  Then Press Enter.'.
           05  CHANGE-INSTRUCTION            PIC X(79) VALUE
               'Type changes.  Then press Enter.'.
           05  DELETE-INSTRUCTION            PIC X(79) VALUE
               'Press Enter to delete this customer or press F12 to canc
      -        'el.'.
      *
       01  COMMUNICATION-AREA.
      *
           05  CA-CONTEXT-FLAG               PIC X(01).
               88  PROCESS-KEY-MAP                  VALUE '1'.
               88  PROCESS-ADD-CUSTOMER             VALUE '2'.
               88  PROCESS-CHANGE-CUSTOMER          VALUE '3'.
               88  PROCESS-DELETE-CUSTOMER          VALUE '4'.
           05  CA-CUSTOMER-RECORD.
               10  CA-CUSTOMER-NUMBER        PIC X(06).
               10  FILLER                    PIC X(112).
      *
       COPY CUSTMAS.
      *
       COPY MNTSET2.
      *
       COPY DFHAID.
      *
       COPY ATTR.
      *
       COPY ERRPARM.
      *
       LINKAGE SECTION.
      *
       01  DFHCOMMAREA                       PIC X(119).
      *
       PROCEDU","This COBOL program defines various data structures and flags related to customer management operations. It includes switches for valid data, flags for sending different types of messages, working fields for response codes, user instructions for adding, changing, and deleting customer information, communication area details for context flags and customer records, and copies various external files for additional functionalities.",Legacy COBOL logic requiring documentation.,No Error,False,"The generated documentation accurately reflects the provided source code, without any hallucinations or omissions.",0.005354194904142114,0.8605577945709229
py_5242,Python,"def drain_node_with_spec(self, id, drain_spec, mark_eligible=None):
        """""" This endpoint toggles the drain mode of the node. When draining is enabled,
            no further allocations will be assigned to this node, and existing allocations
            will be migrated to new nodes.

            If an empty dictionary is given as drain_spec this will disable/toggle the drain.

            https://www.nomadproject.io/docs/http/node.html

            arguments:
              - id (str uuid): node id
              - drain_spec (dict): https://www.nomadproject.io/api/nodes.html#drainspec
              - mark_eligible (bool): https://www.nomadproject.io/api/nodes.html#markeligible
            returns: dict
            raises:
              - nomad.api.exceptions.BaseNomadException
              - nomad.api.exceptions.URLNotFoundNomadException
        """"""
        payload = {}

        if drain_spec and mark_eligible is not None:
            payload = {
                ""NodeID"": id,
                ""DrainSpec"": drain_spec,
                ""MarkEligible"": mark_eligible
            }
        elif drain_spec and mark_eligible is None:
            payload = {
                ""NodeID"": id,
                ""DrainSpec"": drain_spec
            }
        elif not drain_spec and mark_eligible is not None:
            payload = {
                ""NodeID"": id,
                ""DrainSpec"": None,
                ""MarkEligible"": mark_eligible
            }
        elif not drain_spec and mark_eligible is None:
            payload = {
                ""NodeID"": id,
                ""DrainSpec"": None,
            }

        return self.request(id, ""drain"", json=payload, method=""post"").json()",""""""" This endpoint toggles the drain mode of the node. When draining is enabled,
            no further allocations will be assigned to this node, and existing allocations
            will be migrated to new nodes.

            If an empty dictionary is given as drain_spec this will disable/toggle the drain.

            https://www.nomadproject.io/docs/http/node.html

            arguments:
              - id (str uuid): node id
              - drain_spec (dict): https://www.nomadproject.io/api/nodes.html#drainspec
              - mark_eligible (bool): https://www.nomadproject.io/api/nodes.html#markeligible
            returns: dict
            raises:
              - nomad.api.exceptions.BaseNomadException
              - nomad.api.exceptions.URLNotFoundNomadException
        """"""","This endpoint toggles the drain mode of the node. When draining is enabled,
            no further allocations will be assigned to this node, and existing allocations
            will be migrated to new nodes.

            If an empty dictionary is given as drain_spec this will disable/toggle the drain.

            https://www.nomadproject.io/docs/http/node.html

            arguments:
              - id (str uuid): node id
              - drain_spec (dict): https://www.nomadproject.io/api/nodes.html#drainspec
              - mark_eligible (bool): https://www.nomadproject.io/api/nodes.html#markeligible
            returns: dict
            raises:
              - nomad.api.exceptions.BaseNomadException
              - nomad.api.exceptions.URLNotFoundNomadException",No Error,False,"The generated documentation accurately represents the source code, with no hallucinations or omissions identified.",0.9703621136285875,0.9947821497917175
cob_syn_7072,COBOL,"      * REFACTOR CANDIDATE BATCH_7072
      * SYSTEM GENERATED
       Identification Division.                                         00000001
       Program-ID. testantlr206.                                        00000002
       Data Division.                                                   00000003
       Working-Storage Section.                                         00000004
                                                                        00000005
       01  CONSTANTS.                                                   00000006
           05  MYNAME               PIC X(012) VALUE 'testantlr206'.    00000007
                                                                        00000008
       Procedure Division.                                              00000009
           DISPLAY MYNAME ' Begin'                                      00000010
                                                                        00000011
           EXEC CICS LINK PROGRAM('PGMA0001') END-EXEC                  00000012
                                                                        00000013
           GOBACK                                                       00000014
           .                                                            00000015
                                                                        00000016
       1000-para.                                                       00000017
                                                                        00000018
           .                                                            00000019
                                                                        00000020
","This COBOL program defines a constant variable `MYNAME` with a value of 'testantlr206'. It then displays a message indicating the beginning of the program. Following this, it uses an EXEC CICS statement to link to another program named 'PGMA0001'. Finally, the program terminates execution using the GOBACK statement.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.006277466950757328,0.8508199453353882
cob_syn_3416,COBOL,"      * REFACTOR CANDIDATE BATCH_3416
      * SYSTEM GENERATED
000100 Identification Division.
000200 Program-ID. 
000300  HELLOWORLD.
000400 Procedure Division.
055000 ADD COPY CopyInAddBook. TO Var1.
055200 IF Var1 EQUAL TO 12345
009000 GO TO JMP-1.","This COBOL code defines a program with the Program-ID ""HELLOWORLD."" It includes a COPY statement to add the contents of CopyInAddBook to Var1. If Var1 is equal to 12345, the program will branch to the label JMP-1.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the source code.,0.007805988703535686,0.8539717793464661
py_13833,Python,"def task_with_callable(the_callable, label=None, schedule=DEFAULT_SCHEDULE, userdata=None, pk_override=None):
    """"""Factory function to create a properly initialized task.""""""
    task = Task()
    if isinstance(the_callable, str):
        if pk_override is not None:
            components = the_callable.split('.')
            info = dict(
                func_type='instancemethod',
                module_name='.'.join(components[:-2]),
                class_name=components[-2],
                class_path='.'.join(components[:-1]),
                model_pk=pk_override,
                func_name=components[-1],
                func_path=the_callable,
            )
            task.funcinfo = info
        else:
            task.funcinfo = get_func_info(func_from_string(the_callable))
    else:
        task.funcinfo = get_func_info(the_callable)

    if label is None:
        task.label = task.funcinfo['func_path']
    else:
        task.label = label

    task.schedule = schedule
    if not croniter.is_valid(task.schedule):
        raise ValueError(f""Cron schedule {task.schedule} is not valid"")
    
    if userdata is None:
        task.userdata = dict()
    else:
        if isinstance(userdata, dict):
            task.userdata = userdata
        else:
            raise ValueError(""Userdata must be a dictionary of JSON-serializable data"")

    return task","Factory function to create a properly initialized task with a specified callable, label, schedule, userdata, and pk_override. The function initializes a Task object and assigns the callable information to the task's funcinfo attribute. The label is set to the callable's path by default or the specified label. It validates the schedule using croniter. It initializes the userdata as an empty dictionary or the provided dictionary, ensuring it is JSON-serializable. Returns the initialized task object.",Factory function to create a properly initialized task.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.07426487685814917,0.8806869983673096
cob_syn_661,COBOL,"      * REFACTOR CANDIDATE BATCH_661
      * SYSTEM GENERATED
      * Add two vectors into a new one
      *    TOPIC:
      *    VECTORS AND OPERATIONS
      *****************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  MAIN. 
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 I PIC 9(1) COMP.
       01 VEC1.
           02 A PIC S9(2)V9(1) OCCURS 3 TIMES.
       01 VEC2.
           02 B PIC S9(2)V9(1) OCCURS 3 TIMES.
       01 VEC3.
           02 AB PIC S9(2)V9(1) OCCURS 5 TIMES.
       PROCEDURE DIVISION.
           COMPUTE A(1) = 1.1.
           COMPUTE A(2) = 2.2.
           COMPUTE A(3) = 3.3.
           DISPLAY VEC1.
           COMPUTE B(1) = -0.1.
           COMPUTE B(2) = 0.2.
           COMPUTE B(3) = 0.3.
           DISPLAY VEC2.
           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 4
              DISPLAY ""ITERATION "" I
              COMPUTE AB(I) = A(I) + B(I)
              DISPLAY A(I) "" + "" B(I) "" = "" AB(I) 
           END-PERFORM.
           DISPLAY VEC3.
           STOP RUN.
","This COBOL program takes two vectors (VEC1 and VEC2), each containing 3 decimal numbers, and adds corresponding elements from both vectors to create a new vector (VEC3) with 5 elements. The program then displays the original vectors, each element of the new vector along with the addition operation, and the final resulting vector.",Legacy COBOL logic requiring documentation.,Fabricated Variable / Wrong Logic,True,"The new vector VEC3 is claimed to have 5 elements in the documentation but the code creates only as many elements as VEC1 and VEC2, which is 3.",0.005776163584689931,0.8517950177192688
py_2081,Python,"def sample(self, n=None, frac=None, replace=False, weights=None, random_state=None):
        '''Returns a DataFrame with a random set of rows

        {note_copy}

        Provide either n or frac.

        Example:

        >>> import vaex, numpy as np
        >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5))
        >>> df
          #  s      x
          0  a      1
          1  b      2
          2  c      3
          3  d      4
        >>> df.sample(n=2, random_state=42) # 2 random rows, fixed seed
          #  s      x
          0  b      2
          1  d      4
        >>> df.sample(frac=1, random_state=42) # 'shuffling'
          #  s      x
          0  c      3
          1  a      1
          2  d      4
          3  b      2
        >>> df.sample(frac=1, replace=True, random_state=42) # useful for bootstrap (may contain repeated samples)
          #  s      x
          0  d      4
          1  a      1
          2  a      1
          3  d      4

        :param int n: number of samples to take (default 1 if frac is None)
        :param float frac: fractional number of takes to take
        :param bool replace: If true, a row may be drawn multiple times
        :param str or expression weights: (unnormalized) probability that a row can be drawn
        :param int or RandomState: seed or RandomState for reproducability, when None a random seed it chosen
        :return: {return_shallow_copy}
        :rtype: DataFrame
        '''
        self = self.extract()
        if type(random_state) == int or random_state is None:
            random_state = np.random.RandomState(seed=random_state)
        if n is None and frac is None:
            n = 1
        elif frac is not None:
            n = int(round(frac * len(self)))
        weights_values = None
        if weights is not None:
            weights_values = self.evaluate(weights)
            weights_values = weights_values / self.sum(weights)
        indices = random_state.choice(len(self), n, replace=replace, p=weights_values)
        return self.take(indices)","'''Returns a DataFrame with a random set of rows based on given parameters like number of samples, fraction, replacement, weights, and random seed.

        Provide either n or frac.

        Example:

        >>> import vaex, numpy as np
        >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5))
        >>> df
          #  s      x
          0  a      1
          1  b      2
          2  c      3
          3  d      4
        >>> df.sample(n=2, random_state=42) # 2 random rows, fixed seed
          #  s      x
          0  b      2
          1  d      4
        >>> df.sample(frac=1, random_state=42) # 'shuffling'
          #  s      x
          0  c      3
          1  a      1
          2  d      4
          3  b      2
        >>> df.sample(frac=1, replace=True, random_state=42) # useful for bootstrap (may contain repeated samples)
          #  s      x
          0  d      4
          1  a      1
          2  a      1
          3  d      4

        :param int n: number of samples to take (default 1 if frac is None)
        :param float frac: fractional number of takes to take
        :param bool replace: If true, a row may be drawn multiple times
        :param str or expression weights: (unnormalized) probability that a row can be drawn
        :param int or RandomState: seed or RandomState for reproducability, when None a random seed it chosen
        :return: {return_shallow_copy}
        :rtype: DataFrame
        '''","Returns a DataFrame with a random set of rows

        {note_copy}

        Provide either n or frac.

        Example:

        >>> import vaex, numpy as np
        >>> df = vaex.from_arrays(s=np.array(['a', 'b', 'c', 'd']), x=np.arange(1,5))
        >>> df
          #  s      x
          0  a      1
          1  b      2
          2  c      3
          3  d      4
        >>> df.sample(n=2, random_state=42) # 2 random rows, fixed seed
          #  s      x
          0  b      2
          1  d      4
        >>> df.sample(frac=1, random_state=42) # 'shuffling'
          #  s      x
          0  c      3
          1  a      1
          2  d      4
          3  b      2
        >>> df.sample(frac=1, replace=True, random_state=42) # useful for bootstrap (may contain repeated samples)
          #  s      x
          0  d      4
          1  a      1
          2  a      1
          3  d      4

        :param int n: number of samples to take (default 1 if frac is None)
        :param float frac: fractional number of takes to take
        :param bool replace: If true, a row may be drawn multiple times
        :param str or expression weights: (unnormalized) probability that a row can be drawn
        :param int or RandomState: seed or RandomState for reproducability, when None a random seed it chosen
        :return: {return_shallow_copy}
        :rtype: DataFrame",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.9090320229374539,0.9808248281478882
py_12608,Python,"def setParent(self,parent):
        """"""
        Sets the parent of this bone for all entities.
        
        Note that this method must be called before many other methods to ensure internal state has been initialized.
        
        This method also registers this bone as a child of its parent.
        """"""
        self.parent = parent
        self.parent.child_bones[self.name]=self","Sets the parent of this bone for all entities. 

Note that this method must be called before many other methods to ensure internal state has been initialized. 

This method also registers this bone as a child of its parent.","Sets the parent of this bone for all entities.
        
        Note that this method must be called before many other methods to ensure internal state has been initialized.
        
        This method also registers this bone as a child of its parent.",No Error,False,The documentation accurately describes the behavior of the provided source code.,1.0,0.9290226101875305
py_12504,Python,"def visit_Hook(self, node: parsing.Hook) -> ast.expr:
        """"""Generates python code calling a hook.

        self.evalHook('hookname', self.ruleNodes[-1])
        """"""
        return ast.Call(
            ast.Attribute(
                ast.Name('self', ast.Load()), 'evalHook', ast.Load()),
            [
                ast.Str(node.name),
                ast.Subscript(
                    ast.Attribute(
                        ast.Name('self', ast.Load()), 'ruleNodes', ast.Load()),
                    ast.Index(ast.UnaryOp(ast.USub(), ast.Num(1))),
                    ast.Load())],
            [],
            None,
            None)",Generates python code calling a hook by evaluating the hook with the specified name and passing the last node from `self.ruleNodes` as an argument.,"Generates python code calling a hook.

        self.evalHook('hookname', self.ruleNodes[-1])",No Error,False,The documentation accurately represents the functionality of the code.,0.1472821272412462,0.8683612942695618
cob_syn_644,COBOL,"      * REFACTOR CANDIDATE BATCH_644
      * SYSTEM GENERATED
Caligari V00.01ALH             
BitM V0.01 Id 0 Parent 0 Size 00006337
ThumbNailHdrSize 40
ThumbHeader:28 00 00 00 5e 00 00 00 5e 00 00 00 01 00 18 00 00 00 00 00 48 68 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
ColorBufSize 26696
ColorBufZipSize 2042
ZippedThumbnail:78 9c ed 9b b1 6b 1b 49 14 c6 b7 d8 c2 c5 15 2e 5c a8 b8 e2 0c 29 4e e0 e2 0c 29 ce 70 4d 04 29 ce 90 e2 0c 57 9c c0 85 11 2e 0e 91 c2 88 14 41 a4 31 e2 8a 43 b8 30 22 45 10 29 02 4a 71 a0 14 01 b9 30 ac 1b 83 52 04 94 22 e0 eb f2 b7 dc f7 e6 ed 8e 66 67 67 67 56 d6 4a ab e4 e6 31 88 8d 34 d6 ce fc f6 cd f7 de 9b 51 a2 9b 28 f2 cd d4 82 a0 f2 21 6c 6c f3 6c 3c 1b cf c6 b3 f1 6c aa 6f 9e 8d 67 e3 d9 78 36 9e 4d f5 cd b3 f1 6c 3c 1b cf c6 b3 a9 be 79 36 9e 8d 67 e3 d9 78 36 d5 b7 cd 61 73 1d b5 4e 5a fb 3f ed 8f de 8c aa 1f cc 06 b1 01 8f fa 8f f5 80 2d 0c ba cf bb 95 0f 69 13 d8 5c 47 87 bf 1e 06 19 03 aa ca 1d a8 52 36 83 97 83 da f7 b5 2c 98 0d 71 a0 8a d8 4c 6f a7 46 77 31 3a d0 f0 f5 f0 7f c3 06 de b0 f5 dd d6 f8 dd b8 be 57 b7 83 d9 fd 61 77 f8 6a d8 bf 18 4c 3f cc 80 f3 9b 66 83 f9 61 96 72 ea b3 4f b3 ee 79 0f 9c ec 84 66 9f ee f0 8a d5 87 35 f8 8d b2 61 77 99 cf f8 63 0c 29 ba 99 1e 3e 49 ad 2f 44 f2 f1 bb 89 c6 86 2f d6 e9 40 6b 61 a3 b9 8b c6 26 bb 88 8c 7e 23 6d 6d 0e b4 6a 36 22 a3 6b 1e 37 ed ab 06 16 c3 0b c9 8d ec 6c 60 ad d3 76 f3 8f e6 e4 fd e4 ab 65 a3 66 74 58 4d ad d3 16 1c c8 09 29 e1 61 f0 2a cd 56 ed 40 2b 62 23 dc 05 4e 90 99 cd ee e0 e5 70 2a 56 d3 f8 3d 29 ca f8 9f 31 d4 65 19 48 c8 05 56 e4 40 2b 60 e3 c8 e8 84 d4 22 65 41 73 f8 45 88 b5 d3 72 f4 11 b6 22 07 2a 97 cd ed b4 fd b4 6d f7 03 69 ce d0 cd 7d d0 0a 7e 21 42 5b b9 21 ac 3c 36 5a 88 b6 4c b7 fb a2 9b 0d 5b 79 76 f0 4b a3 60 4f 48 36 7d 79 79 65 46 39 6c a6 14 a5 0b eb ac 66 23 ab e4 c8 d4 07 38 11 9e b2 1a 26 c1 70 38 a3 1c e8 63 39 39 d0 d2 6c 0a b9 4b 28 34 26 93 b8 68 86 ef 61 b1 56 df 44 ac 56 ff 99 57 69 68 71 be 14 07 5a 82 0d 42 f4 fe c3 fd e6 49 6b 72 35 c9 0e 56 b5 c3 df 8e ec 1d 60 08 6d f1 c5 4d a","This code appears to be a comment block containing metadata information about a batch processing job. The information includes version numbers, IDs, sizes, and hexadecimal data related to thumbnail images.",Legacy COBOL logic requiring documentation.,No Error,False,The audit reveals that the documentation correctly describes the provided source code with no unsupported claims or critical omissions.,0.0,0.8459855914115906
cob_real_419,COBOL,"      * This program is the child program for asynch parent
       IDENTIFICATION DIVISION.
      *ID DIVISION.
       Program-id. ASYNCCH2.
       Environment division.
       Data division.

       Working-storage section.
       01 INCONTAINER    PIC X(16) value 'INCONT'.
       01 OUTCONTAINER   PIC X(16) VALUE 'OUTCONT'.

       01 MSG            PIC X(60) value spaces.

       Procedure division.

           EXEC CICS GET CONTAINER (INCONTAINER)
                     INTO    ( MSG )
                     NOHANDLE
           END-EXEC.

           EXEC CICS DELAY FOR SECONDS(5)
           END-EXEC

           EXEC CICS PUT CONTAINER ( OUTCONTAINER )
                     FROM   ( 'child 2 finished' )
                     NOHANDLE
           END-EXEC

           EXEC CICS RETURN END-EXEC.
           Goback.

       End program ASYNCCH2.","This COBOL program ASYNCCH2 is a child program that is designed to work with an asynchronous parent program. It reads a message from a container named INCONT, delays the execution for 5 seconds, writes a message 'child 2 finished' to a container named OUTCONT, and then returns control to the parent program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the function and behavior of the provided COBOL program.,0.005869389976559867,0.8529606461524963
cob_real_2420,COBOL," IDENTIFICATION DIVISION.
 SKIP2.
 PROGRAM-ID. SKP2.
 PROCEDURE DIVISION.
    STOP RUN.","This COBOL program consists of the IDENTIFICATION DIVISION, which typically includes information about the program, such as its name. In this case, it includes a custom section named ""SKIP2"" and a program identifier ""SKP2"". The PROCEDURE DIVISION is empty in this code except for a STOP RUN statement, which halts the program execution. Thus, this program will simply define the program and immediately stop without executing any further instructions.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately explains the provided COBOL source code.,0.004624392108240828,0.8490674495697021
py_8238,Python,"def show_progress(self, n, total_runs):
        """"""Displays a progressbar""""""
        if self.report_progress:
            percentage, logger_name, log_level = self.report_progress
            if logger_name == 'print':
                logger = 'print'
            else:
                logger = logging.getLogger(logger_name)

            if n == -1:
                # Compute the number of digits and avoid log10(0)
                digits = int(math.log10(total_runs + 0.1)) + 1
                self._format_string = 'PROGRESS: Finished %' + '%d' % digits + 'd/%d runs '

            fmt_string = self._format_string % (n + 1, total_runs) + '%s'
            reprint = log_level == 0
            progressbar(n, total_runs, percentage_step=percentage,
                        logger=logger, log_level=log_level,
                        fmt_string=fmt_string, reprint=reprint)","Displays a progressbar based on the current progress made by completing ""n"" runs out of ""total_runs"". The progress bar is formatted based on the report configuration provided.",Displays a progressbar,Omission,True,The documentation does not mention about the logging functionality and the condition based on logger_name and log_level.,0.04654865628746293,0.892912745475769
cob_real_3210,COBOL,"       IDENTIFICATION DIVISION.
       PROGRAM-ID. MAINHRMS.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
           CRT STATUS IS CRT-STATUS.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77 CHOICE PIC 9.
       77 CRT-STATUS PIC 9(4).

       PROCEDURE DIVISION.
       MAIN-PARA.
           COPY CLEAR-SCREEN.
   *>>D    DISPLAY ""DEBUG MODE"" AT 0101.
           DISPLAY ""*******************************************""
                AT 0315.
           DISPLAY ""     HUMAN RESOURCE MANAGEMENT SYSTEM      ""
                AT 0515.
           DISPLAY ""*******************************************""
                AT 0715.
           DISPLAY ""1. HRMS WRITE"" AT 1025.
           DISPLAY ""2. HRMS READ"" AT 1225.
           DISPLAY ""3. LIST BRANCH FILE"" AT 1425.
           DISPLAY ""4. EXIT"" AT 1625.
           DISPLAY ""ENTER YOUR CHOICE:"" AT 1825.
           ACCEPT CHOICE AT 1844.
           IF CHOICE = 1 OR CRT-STATUS = 1001
               CALL ""EMPWRITE""
               CANCEL ""EMPWRITE""
               GO TO MAIN-PARA
           ELSE
               IF CHOICE = 2 OR CRT-STATUS = 1002
                   CALL ""EMPREAD""
                   CANCEL ""EMPREAD""
                   GO TO MAIN-PARA
               ELSE
                   IF CHOICE = 3 OR CRT-STATUS = 1003
                       CALL ""BRANCHLIST""
                       CANCEL ""BRANCHLIST""
                       GO TO MAIN-PARA
                   ELSE
                       IF  CHOICE = 9 OR CRT-STATUS = 1009
                           CALL ""TESTS""
                           CANCEL ""TESTS""
                           GO TO MAIN-PARA
                       ELSE
                           STOP RUN.
","This COBOL program defines a Human Resource Management System (HRMS) menu where the user can choose to perform various operations such as writing to HRMS, reading from HRMS, listing branch files, or exiting the program. The program uses a `CHOICE` variable to capture the user's selection and then calls different subprograms based on the user's choice or a predefined `CRT-STATUS` value. The program repeats the menu display and user input process until the user chooses to exit.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention the ""TESTS"" subprogram that is being called when the CHOICE or CRT-STATUS is equal to 9.",0.004214353393030252,0.8505304455757141
cob_syn_9324,COBOL,"      * REFACTOR CANDIDATE BATCH_9324
      * SYSTEM GENERATED
import thread, re, time, socket;
import getopt, shlex;
import datetime;
import ssdb_cli.*;

try{
	import readline;
}catch(Exception e){
}

escape_data = false;

function welcome(){
	sys.stderr.write('ssdb (cli) - ssdb command line tool.\n');
	sys.stderr.write('Copyright (c) 2012-2014 ssdb.io\n');
	sys.stderr.write('\n');
	sys.stderr.write(""'h' or 'help' for help, 'q' to quit.\n"");
	sys.stderr.write('\n');
}

function show_command_help(){
	print '';
	print '# display ssdb-server status';
	print '    info';
	print '# escape/do not escape response data';
	print '    : escape yes|no';
	print '# export/import';
	print '    export [-i] out_file';
	print '        -i    interactive mode';
	print '    import in_file';
	print '';
	print 'see http://ssdb.io/docs/php/ for commands details';
	print '';
	print 'press \'q\' and Enter to quit.';
	print '';
}

function usage(){
	print '';
	print 'Usage:';
	print '	ssdb-cli [-h] [HOST] [-p] [PORT]';
	print '';
	print 'Options:';
	print '	-h 127.0.0.1';
	print '		ssdb server hostname/ip address';
	print '	-p 8888';
	print '		ssdb server port';
	print '';
	print 'Examples:';
	print '	ssdb-cli';
	print '	ssdb-cli 8888';
	print '	ssdb-cli 127.0.0.1 8888';
	print '	ssdb-cli -h 127.0.0.1 -p 8888';
}

function repr_data(s){
	gs = globals();
	if(gs['escape_data'] == false){
		return s;
	}
	ret = str(s).encode('string-escape');
	return ret;
}

function timespan(stime){
	etime = datetime.datetime.now();
	ts = etime - stime;
	time_consume = ts.seconds + ts.microseconds/1000000.;
	return time_consume;
}

function show_version(){
	try{
		resp = link.request('info', []);
		sys.stderr.write('server version: ' + resp.data[2] + '\n\n');
	}catch(Exception e){
	}
}


host = '';
port = '';
opt = '';
args = [];
foreach(sys.argv[1 ..] as arg){
	if(opt == '' && arg.startswith('-')){
		opt = arg;
	}else{
		switch(opt){
			case '-h':
				host = arg;
				opt = '';
				break;
			case '-p':
				port = arg;
				opt = '';
				break;
			default:
				args.append(ar","This COBOL code appears to be a snippet of a Python script that implements a command-line interface (CLI) for interacting with an SSDB (SSDB - A NoSQL database) server. It defines functions for displaying help messages, usage instructions, handling data representation, calculating time span, and showing server version information. The script also reads command-line arguments to determine the host and port of the SSDB server to connect to. It sets up options for exporting/importing data and escaping response data. The code structure suggests it is part of a larger application that provides functionalities to interact with an SSDB server through a command-line interface.",Legacy COBOL logic requiring documentation.,Fabricated Variable,True,The document states the code is written in COBOL while it is actually in Python.,0.0032908347061516414,0.846770167350769
py_376,Python,"def to_csv(
            self,
            hql,
            csv_filepath,
            schema='default',
            delimiter=',',
            lineterminator='\r\n',
            output_header=True,
            fetch_size=1000,
            hive_conf=None):
        """"""
        Execute hql in target schema and write results to a csv file.

        :param hql: hql to be executed.
        :type hql: str or list
        :param csv_filepath: filepath of csv to write results into.
        :type csv_filepath: str
        :param schema: target schema, default to 'default'.
        :type schema: str
        :param delimiter: delimiter of the csv file, default to ','.
        :type delimiter: str
        :param lineterminator: lineterminator of the csv file.
        :type lineterminator: str
        :param output_header: header of the csv file, default to True.
        :type output_header: bool
        :param fetch_size: number of result rows to write into the csv file, default to 1000.
        :type fetch_size: int
        :param hive_conf: hive_conf to execute alone with the hql.
        :type hive_conf: dict

        """"""

        results_iter = self._get_results(hql, schema,
                                         fetch_size=fetch_size, hive_conf=hive_conf)
        header = next(results_iter)
        message = None

        i = 0
        with open(csv_filepath, 'wb') as f:
            writer = csv.writer(f,
                                delimiter=delimiter,
                                lineterminator=lineterminator,
                                encoding='utf-8')
            try:
                if output_header:
                    self.log.debug('Cursor description is %s', header)
                    writer.writerow([c[0] for c in header])

                for i, row in enumerate(results_iter, 1):
                    writer.writerow(row)
                    if i % fetch_size == 0:
                        self.log.info(""Written %s rows so far."", i)
            except ValueError as exception:
                message = str(exception)

        if message:
            # need to clean up the file first
            os.remove(csv_filepath)
            raise ValueError(message)

        self.log.info(""Done. Loaded a total of %s rows."", i)",Execute hql in target schema and write results to a csv file.,"Execute hql in target schema and write results to a csv file.

        :param hql: hql to be executed.
        :type hql: str or list
        :param csv_filepath: filepath of csv to write results into.
        :type csv_filepath: str
        :param schema: target schema, default to 'default'.
        :type schema: str
        :param delimiter: delimiter of the csv file, default to ','.
        :type delimiter: str
        :param lineterminator: lineterminator of the csv file.
        :type lineterminator: str
        :param output_header: header of the csv file, default to True.
        :type output_header: bool
        :param fetch_size: number of result rows to write into the csv file, default to 1000.
        :type fetch_size: int
        :param hive_conf: hive_conf to execute alone with the hql.
        :type hive_conf: dict",No Error,False,The documentation accurately describes the function of the code without any unsupported claims or omissions.,0.00026125855730166754,0.8044438362121582
cob_syn_3409,COBOL,"      * REFACTOR CANDIDATE BATCH_3409
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  GERANDORELATORIO.
      *********************************
      * OBJETIVO:  GERANDORELATORIO
      * AUTHOR  :  LRM
      *********************************
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT CLIENTES ASSIGN TO 'E:\COBOL\CLIENTES.DAT'
             ORGANIZATION IS INDEXED
             ACCESS MODE IS DYNAMIC
             FILE STATUS IS CLIENTES-STATUS
             RECORD KEY IS  CLIENTES-CHAVE.
       DATA DIVISION.
       FILE SECTION.
       FD CLIENTES.
       01 CLIENTES-REG.
            05 CLIENTES-CHAVE.
                10 CLIENTES-FONE PIC 9(09).
            05 CLIENTES-NOME     PIC X(30).
            05 CLIENTES-EMAIL    PIC X(40).

       WORKING-STORAGE SECTION.
       77 WRK-OPCAO       PIC X(1).
       77 WRK-MODULO      PIC X(25).
       77 WRK-TECLA       PIC X(1).
       77 CLIENTES-STATUS PIC 9(02).
       77 WRK-MSGERRO     PIC X(30).

       SCREEN SECTION.
       01 TELA.
            05 LIMPA-TELA.
                10 BLANK SCREEN.
                10 LINE 01 COLUMN 01 PIC X(20) ERASE EOL
                   BACKGROUND-COLOR 3.
                10 LINE 01 COLUMN 25 PIC X(20)
                   BACKGROUND-COLOR 3  FOREGROUND-COLOR 0
                              FROM 'SISTEMA DE CLIENTES '.
                10 LINE 02 COLUMN 01 PIC X(25) ERASE EOL
                   BACKGROUND-COLOR 1 FROM WRK-MODULO.
       01 MENU.
            05 LINE 07 COLUMN 15 VALUE '1 - INCLUIR'.
            05 LINE 08 COLUMN 15 VALUE '2 - CONSULTAR'.
            05 LINE 09 COLUMN 15 VALUE '3 - ALTERAR'.
            05 LINE 10 COLUMN 15 VALUE '4 - EXCLUIR'.
            05 LINE 11 COLUMN 15 VALUE '5 - RELATORIO'.
            05 LINE 12 COLUMN 15 VALUE 'X - SAIDA'.
            05 LINE 13 COLUMN 15 VALUE 'OPCAO......: ' .
            05 LINE 13 COLUMN 28 USING WRK-OPCAO.

       01 TELA-REGISTRO.
            05 CHAVE FOREGROUND-COLOR 2.
               10 LINE 10 COLUMN 10 ","This COBOL program defines a file structure for handling client data stored in an indexed file. It includes definitions for client fields such as telephone number, name, and email address. The program provides a menu for operations like including, querying, updating, deleting client records, and generating a report. The program also defines screen layouts for displaying information and handling user input.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation is a correct representation of the source code.,0.005131423326712104,0.8619073033332825
cob_syn_4734,COBOL,"      * REFACTOR CANDIDATE BATCH_4734
      * SYSTEM GENERATED
       identification division.
       program-id. environment_setup_01.

       procedure division.
           display ""Hello World!"".
           stop run.

","This COBOL program displays the message ""Hello World!"" on the screen and then stops the program execution.",Legacy COBOL logic requiring documentation.,No Error,False,All the details in the documentation match with the source code provided.,0.014936192853457254,0.8865888714790344
py_3753,Python,"def Run(argv=None):
    """"""standalone command line access point""""""
    if argv is None:
        argv = sys.argv[1:]
    from getopt import getopt

    s_opts = ""hdi""
    l_opts = (
        ""help"",
        ""duplicates="",
        ""ignore-comments"",
        ""ignore-imports"",
        ""ignore-docstrings"",
    )
    min_lines = 4
    ignore_comments = False
    ignore_docstrings = False
    ignore_imports = False
    opts, args = getopt(argv, s_opts, l_opts)
    for opt, val in opts:
        if opt in (""-d"", ""--duplicates""):
            min_lines = int(val)
        elif opt in (""-h"", ""--help""):
            usage()
        elif opt in (""-i"", ""--ignore-comments""):
            ignore_comments = True
        elif opt in (""--ignore-docstrings"",):
            ignore_docstrings = True
        elif opt in (""--ignore-imports"",):
            ignore_imports = True
    if not args:
        usage(1)
    sim = Similar(min_lines, ignore_comments, ignore_docstrings, ignore_imports)
    for filename in args:
        with open(filename) as stream:
            sim.append_stream(filename, stream)
    sim.run()
    sys.exit(0)","The code defines a function `Run` which serves as a standalone command line access point. It parses command line arguments, sets various options based on the arguments provided, reads files specified in the arguments, and runs a process to find similarities between them.",standalone command line access point,No Error,False,The documentation accurately describes the functionality of the source code without making any unsupported claims or omitting critical information.,0.053353438258077264,0.8663473129272461
cob_syn_3456,COBOL,"      * REFACTOR CANDIDATE BATCH_3456
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.                                         00022700
      *-----------------------                                          00022800
       PROGRAM-ID.    CBLDB22                                           00022900
                                                                        00026000
       ENVIRONMENT DIVISION.                                            00027000
      *--------------------                                             00028000
       CONFIGURATION SECTION.                                           00029000
       INPUT-OUTPUT SECTION.                                            00030000
       FILE-CONTROL.                                                    00040000
           SELECT REPOUT ASSIGN TO UT-S-REPORT.                         00060000
           SELECT RECIN  ASSIGN TO DA-S-RECIN.                          00062000
                                                                        00070000
       DATA DIVISION.                                                   00080000
      *-------------                                                    00090000
       FILE SECTION.                                                    00100000
      *-------------                                                    00101000
       FD  REPOUT                                                       00110000
           RECORD CONTAINS 120 CHARACTERS                               00120000
           LABEL RECORDS ARE OMITTED                                    00130000
           RECORDING MODE F                                             00131000
           DATA RECORD IS REPREC.                                       00140000
      *                                                                 00140100
       01  REPREC.                                                      00141000
           05  ACCT-NO-O      PIC X(8).                                 00141100
           05  ACCT-LIMIT-O   PIC $$,$$$,$$9.99.        ","This COBOL program defines a report output file (REPOUT) and an input record file (RECIN). The REPOUT file has records of 120 characters each with a data structure containing two fields: ACCT-NO-O of type X(8) and ACCT-LIMIT-O of type $$,$$$,$$9.99.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the source code.,0.007313425995364251,0.8437052965164185
cob_syn_10110,COBOL,"      * REFACTOR CANDIDATE BATCH_10110
      * SYSTEM GENERATED
IDENTIFICATION DIVISION.
PROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.
DATA DIVISION.
WORKING-STORAGE SECTION.
01  AGM-VARS.
    05 A       PIC 9V9(16).
    05 A-ZERO  PIC 9V9(16).
    05 G       PIC 9V9(16).
    05 DIFF    PIC 9V9(16) VALUE 1.
* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH
* is never performed at all.
PROCEDURE DIVISION.
TEST-PARAGRAPH.
    MOVE    1 TO A.
    COMPUTE G = 1 / FUNCTION SQRT(2).
* The program will run with the test values. If you would rather
* calculate the AGM of numbers input at the console, comment out
* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.
* INPUT-A-AND-G-PARAGRAPH.
*     DISPLAY 'Enter two numbers.'
*     ACCEPT  A.
*     ACCEPT  G.
CONTROL-PARAGRAPH.
    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.
    DISPLAY A.
    STOP RUN.
AGM-PARAGRAPH.
    MOVE     A TO A-ZERO.
    COMPUTE  A = (A-ZERO + G) / 2.
    MULTIPLY A-ZERO BY G GIVING G.
    COMPUTE  G = FUNCTION SQRT(G).
    SUBTRACT A FROM G GIVING DIFF.
    COMPUTE  DIFF = FUNCTION ABS(DIFF).
","This COBOL program calculates the Arithmetic-Geometric Mean (AGM) of two numbers using the AGM algorithm. It initializes variables for the two numbers (A and G), as well as a variable for the difference between iterations (DIFF). The program first runs a test scenario with predefined values, then it iterates the AGM algorithm until the difference between iterations is less than a predefined threshold. The calculated AGM is displayed as the output.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation failed to mention the methods used to initialize the variables A and G for the test scenario.,0.00451399365518933,0.8500753045082092
cob_real_2677,COBOL,"       IDENTIFICATION DIVISION.                                         00010001
       PROGRAM-ID. HELLO.                                               00020002
      / * simple hello world program                                    00030003
       PROCEDURE DIVISION.                                              00040001
           DISPLAY 'Hello world!'.
           STOP RUN.                                                    00060001","This COBOL program prints ""Hello world!"" to the console and then stops the execution of the program. The code serves as a simple hello world program in COBOL.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes what the code does.,0.009849574084214482,0.8737756013870239
cob_syn_5722,COBOL,"      * REFACTOR CANDIDATE BATCH_5722
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HELLO-WORLD.
       PROCEDURE DIVISION.
           DISPLAY 'Hello world!'.
           STOP RUN.
","This COBOL program defines a main procedure that displays the text ""Hello world!"" on the output device and then terminates.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the code's function and does not make unsupported claims or omissions.,0.013038525962482981,0.8776059746742249
py_8743,Python,"def get_published_courses_in_account_by_sis_id(self, sis_account_id,
                                                   params={}):
        """"""
        Return a list of published courses for the passed account SIS ID.
        """"""

        return self.get_published_courses_in_account(
            self._sis_id(sis_account_id, sis_field=""account""), params)",Return a list of published courses for the passed account SIS ID.,Return a list of published courses for the passed account SIS ID.,No Error,False,The provided documentation accurately represents the function's behavior.,1.0,1.0000001192092896
cob_syn_6303,COBOL,"      * REFACTOR CANDIDATE BATCH_6303
      * SYSTEM GENERATED
       Identification Division.                                         00000001
       Program-ID. testantlr246.                                        00000002
       Data Division.                                                   00000003
       Working-Storage Section.                                         00000004
                                                                        00000005
       >>DEFINE A 2                                                     00000006
       >>DEFINE B 3                                                     00000007
       >>DEFINE C A + B                                                 00000008
       >>DEFINE D A * B                                                 00000009
       >>DEFINE E (D * A) / 3                                           00000010
                                                                        00000011
       01  CONSTANTS.                                                   00000012
           05  MYNAME               PIC X(012) VALUE 'testantlr246'.    00000013
           05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.        00000014
           05  PGM-0002             PIC X(008) VALUE 'PGMA0002'.        00000015
           05  PGM-0003             PIC X(008) VALUE 'PGMA0003'.        00000016
           05  PGM-0009             PIC X(008) VALUE 'PGMA0009'.        00000017
                                                                        00000018
      *                                                                 00000019
                                                                        00000020
       Procedure Division.                                              00000021
           DISPLAY MYNAME ' Begin'                                      00000022
                                                                        00000023
           >>EVALUATE TRUE                                              00000024
           >>WHEN C = 5                                 ","This COBOL code defines constants A, B, C, D, and E with specific values and expressions. It then contains a Procedure Division which displays a message indicating the beginning of the program. The code uses an EVALUATE statement but is incomplete, as further logic is missing after the WHEN condition.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation omits to mention that the EVALUATE statement in the procedure division is incomplete, there is no logic provided for when C equals 5.",0.007213727908218376,0.8665343523025513
cob_syn_2121,COBOL,"      * REFACTOR CANDIDATE BATCH_2121
      * SYSTEM GENERATED
   CBL NUMPROC(MIG),FLAG(I,W),RENT
       ID DIVISION.
       PROGRAM-ID. EPSMPMT.
      *    THIS IS A CALLED PROGRAM EXAMPLE FOR DEMONSTRATION
      *
      *    THIS PROGRAM WILL BE CALLED BY ANOTHER, RECEIVE
      *    THE FOLLOWING INFOMATION AND RETURN A MONTLY PAYMENT AMOUNT
      *    INPUT:
      *       ORIGINAL PRINCIPLE AMOUNT
      *       YEARS OR MONTH INDICATOR
      *       NUMBER OF YEARS
      *       NUMBER OF MONTHS
      *       INTEREST RATE
      *    OUTPUT:
      *       MONTHLY PAYMENT
      *
      *    (C) 2008 IBM - Jim Hildner
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER. FLEX-ES.
       OBJECT-COMPUTER. FLEX-ES.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
      *
       01 WS-STATIC-DATA.
           03 STATIC-MAXIMUM-PRINCIPLE    PIC 9(9)V99
                                VALUE 100000000.01.
           03 STATIC-ERRORS.
              05 FILLER                  PIC 99 VALUE 1.
              05 FILLER                  PIC X(80)
              VALUE 'PRINCIPLE AMOUNT IS NEGATIVE'.
              05 FILLER                  PIC 99 VALUE 2.
              05 FILLER                  PIC X(80)
              VALUE 'PRINCIPLE EXCEEDED MAXIMUM AMOUNT'.
              05 FILLER                  PIC 99 VALUE 3.
              05 FILLER                  PIC X(80)
              VALUE 'NEGATIVE INTEREST RATE'.
              05 FILLER                  PIC 99 VALUE 4.
              05 FILLER                  PIC X(80)
              VALUE 'YEARS INDICATED, BUT YEARS ZERO OR LESS'.
              05 FILLER                  PIC 99 VALUE 5.
              05 FILLER                  PIC X(80)
              VALUE 'ZERO OR LESS MONTHS'.
              05 FILLER                  PIC 99 VALUE 6.
              05 FILLER                  PIC X(80)
              VALUE ' '.
              05 FILLER                  PIC 99 VALUE 7.
              05 FILLER                  PIC X(80)
              VALUE ' '.
              05 FILL","This COBOL program is a subroutine designed to be called by another program. It calculates and returns a monthly payment amount based on the input provided, including the original principal amount, time indicator (in years or months), number of years, number of months, and the interest rate. The program contains static data such as maximum principle amount and error messages for various scenarios like negative amount, exceeding maximum amount, negative interest rate, zero or negative years, and zero or negative months.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the source code's function and behavior.,0.004037212983094038,0.84400475025177
py_11146,Python,"def upload(self, file_name):
        """"""
        Uploads the file associated with the file_name passed to Google Drive in the Music folder.

        :param str file_name: Filename of the file to be uploaded
        :return str: Original filename passed as an argument (in order for the worker to send it to the delete queue)
        """"""

        response = self.connection.files().list(q=""name='Music' and mimeType='application/vnd.google-apps.folder' and trashed=false"").execute()
        folder_id = response.get('files', [])[0]['id']
        file_metadata = {'name': file_name, 'parents': [folder_id]}
        media = MediaFileUpload(file_name, mimetype='audio/mpeg')
        
        log.info(f""Upload for {file_name} has started"")
        start_time = time()
        self.connection.files().create(body=file_metadata, media_body=media, fields='id').execute()
        end_time = time()
        log.info(f""Upload for {file_name} has finished in {end_time - start_time} seconds"")

        return file_name",Uploads the file associated with the file_name passed to Google Drive in the Music folder.,"Uploads the file associated with the file_name passed to Google Drive in the Music folder.

        :param str file_name: Filename of the file to be uploaded
        :return str: Original filename passed as an argument (in order for the worker to send it to the delete queue)",No Error,False,The documentation accurately reflects the actions performed by the source code without any unsupported claims or missing crucial information.,0.1353352832366127,0.8901076912879944
py_3655,Python,"def project_from_files(
    files, func_wrapper=_astroid_wrapper, project_name=""no name"", black_list=(""CVS"",)
):
    """"""return a Project from a list of files or modules""""""
    # build the project representation
    astroid_manager = manager.AstroidManager()
    project = Project(project_name)
    for something in files:
        if not os.path.exists(something):
            fpath = modutils.file_from_modpath(something.split("".""))
        elif os.path.isdir(something):
            fpath = os.path.join(something, ""__init__.py"")
        else:
            fpath = something
        ast = func_wrapper(astroid_manager.ast_from_file, fpath)
        if ast is None:
            continue
        # XXX why is first file defining the project.path ?
        project.path = project.path or ast.file
        project.add_module(ast)
        base_name = ast.name
        # recurse in package except if __init__ was explicitly given
        if ast.package and something.find(""__init__"") == -1:
            # recurse on others packages / modules if this is a package
            for fpath in modutils.get_module_files(
                os.path.dirname(ast.file), black_list
            ):
                ast = func_wrapper(astroid_manager.ast_from_file, fpath)
                if ast is None or ast.name == base_name:
                    continue
                project.add_module(ast)
    return project","""""""Return a Project object generated from a list of files or modules. The function iterates over the input files and, for each one, creates an Abstract Syntax Tree (AST) representation using the provided function wrapper. If the AST is successfully created, it is added to the Project object. The 'project_path' attribute of the Project is set to the file path of the first file or module processed, and additional modules from the same package are recursively added unless '__init__' is explicitly given as a file. The function returns the final Project object.""""""",return a Project from a list of files or modules,Omission,True,The documentation does not mention about the 'project_name' and 'black_list' parameters and their purpose in the function.,0.05575429357445276,0.854511022567749
py_9617,Python,"def to_eaf(self, skipempty=True, pointlength=0.1):
        """"""Convert the object to an pympi.Elan.Eaf object

        :param int pointlength: Length of respective interval from points in
                                seconds
        :param bool skipempty: Skip the empty annotations
        :returns: :class:`pympi.Elan.Eaf` object
        :raises ImportError: If the Eaf module can't be loaded.
        :raises ValueError: If the pointlength is not strictly positive.
        """"""
        from pympi.Elan import Eaf
        eaf_out = Eaf()
        if pointlength <= 0:
            raise ValueError('Pointlength should be strictly positive')
        for tier in self.get_tiers():
            eaf_out.add_tier(tier.name)
            for ann in tier.get_intervals(True):
                if tier.tier_type == 'TextTier':
                    ann = (ann[0], ann[0]+pointlength, ann[1])
                if ann[2].strip() or not skipempty:
                    eaf_out.add_annotation(tier.name, int(round(ann[0]*1000)),
                                           int(round(ann[1]*1000)), ann[2])
        return eaf_out",Converts the current object to a `pympi.Elan.Eaf` object by creating a new `Eaf` object and adding tiers and annotations from the current object. It allows specifying the length of intervals from points in seconds and whether to skip empty annotations. Raises `ImportError` if the Eaf module cannot be loaded and `ValueError` if the point length is not strictly positive.,"Convert the object to an pympi.Elan.Eaf object

        :param int pointlength: Length of respective interval from points in
                                seconds
        :param bool skipempty: Skip the empty annotations
        :returns: :class:`pympi.Elan.Eaf` object
        :raises ImportError: If the Eaf module can't be loaded.
        :raises ValueError: If the pointlength is not strictly positive.",No Error,False,The documentation accurately reflects the source code functions and parameters.,0.11603274742444249,0.8176066279411316
py_14246,Python,"def lines_matching(self, *regexes):
        """"""Find the lines matching one of a list of regexes.

        Returns a set of line numbers, the lines that contain a match for one
        of the regexes in `regexes`.  The entire line needn't match, just a
        part of it.

        """"""
        regex_c = re.compile(join_regex(regexes))
        matches = set()
        for i, ltext in enumerate(self.lines):
            if regex_c.search(ltext):
                matches.add(i+1)
        return matches","Find the lines matching one of a list of regexes.

Returns a set of line numbers, the lines that contain a match for one
of the regexes in `regexes`. The entire line needn't match, just a
part of it.","Find the lines matching one of a list of regexes.

        Returns a set of line numbers, the lines that contain a match for one
        of the regexes in `regexes`.  The entire line needn't match, just a
        part of it.",No Error,False,"The documentation accurately describes what the function does, without any hallucinations or omissions.",1.0,0.9216805696487427
py_5182,Python,"def categories(self):
        """"""
        Lists the categories in the lexicon, except the
        optional categories.

        Returns:
            list: A list of strings of category names.
        """"""
        keys = [k for k in self.__dict__.keys() if k not in SPECIAL]
        return keys","Lists the categories in the lexicon, except the optional categories. Returns a list of strings of category names.","Lists the categories in the lexicon, except the
        optional categories.

        Returns:
            list: A list of strings of category names.",No Error,False,The documentation accurately reflects the source code's function and doesn't contain any unsupported claims or omissions.,0.7357777961658121,0.8462562561035156
py_14867,Python,"def _should_trace_with_reason(self, filename, frame):
        """"""Decide whether to trace execution in `filename`, with a reason.

        This function is called from the trace function.  As each new file name
        is encountered, this function determines whether it is traced or not.

        Returns a pair of values:  the first indicates whether the file should
        be traced: it's a canonicalized filename if it should be traced, None
        if it should not.  The second value is a string, the resason for the
        decision.

        """"""
        if not filename:
            # Empty string is pretty useless
            return None, ""empty string isn't a filename""

        if filename.startswith('<'):
            # Lots of non-file execution is represented with artificial
            # filenames like ""<string>"", ""<doctest readme.txt[0]>"", or
            # ""<exec_function>"".  Don't ever trace these executions, since we
            # can't do anything with the data later anyway.
            return None, ""not a real filename""

        self._check_for_packages()

        # Compiled Python files have two filenames: frame.f_code.co_filename is
        # the filename at the time the .pyc was compiled.  The second name is
        # __file__, which is where the .pyc was actually loaded from.  Since
        # .pyc files can be moved after compilation (for example, by being
        # installed), we look for __file__ in the frame and prefer it to the
        # co_filename value.
        dunder_file = frame.f_globals.get('__file__')
        if dunder_file:
            filename = self._source_for_file(dunder_file)

        # Jython reports the .class file to the tracer, use the source file.
        if filename.endswith(""$py.class""):
            filename = filename[:-9] + "".py""

        canonical = self.file_locator.canonical_filename(filename)

        # If the user specified source or include, then that's authoritative
        # about the outer bound of what to measure and we don't have to apply
        # any canned exclusions. If they didn't, then we have to exclude the
        # stdlib and coverage.py directories.
        if self.source_match:
            if not self.source_match.match(canonical):
                return None, ""falls outside the --source trees""
        elif self.include_match:
            if not self.include_match.match(canonical):
                return None, ""falls outside the --include trees""
        else:
            # If we aren't supposed to trace installed code, then check if this
            # is near the Python standard library and skip it if so.
            if self.pylib_match and self.pylib_match.match(canonical):
                return None, ""is in the stdlib""

            # We exclude the coverage code itself, since a little of it will be
            # measured otherwise.
            if self.cover_match and self.cover_match.match(canonical):
                return None, ""is part of coverage.py""

        # Check the file against the omit pattern.
        if self.omit_match and self.omit_match.match(canonical):
            return None, ""is inside an --omit pattern""

        return canonical, ""because we love you""","Decide whether to trace execution in a given filename and provide a reason for the decision.

This function is called from the trace function to determine whether a file should be traced or not based on various criteria such as empty filename, non-file executions, compiled Python files, user-specified source or include, standard library exclusion, coverage.py exclusion, and omit pattern exclusion.

Returns a tuple containing:
1. Canonicalized filename if it should be traced, or None if it should not be traced.
2. A string indicating the reason behind the decision.","Decide whether to trace execution in `filename`, with a reason.

        This function is called from the trace function.  As each new file name
        is encountered, this function determines whether it is traced or not.

        Returns a pair of values:  the first indicates whether the file should
        be traced: it's a canonicalized filename if it should be traced, None
        if it should not.  The second value is a string, the resason for the
        decision.",No Error,False,The generated documentation accurately reflects the code. It includes all the important aspects of the program logic and does not contain any hallucination or omission.,0.23767735511342464,0.844143271446228
py_106,Python,"def get_conn(self):
        """"""
        Returns verticaql connection object
        """"""
        conn = self.get_connection(self.vertica_conn_id)
        conn_config = {
            ""user"": conn.login,
            ""password"": conn.password or '',
            ""database"": conn.schema,
            ""host"": conn.host or 'localhost'
        }

        if not conn.port:
            conn_config[""port""] = 5433
        else:
            conn_config[""port""] = int(conn.port)

        conn = connect(**conn_config)
        return conn","Returns a Vertica connection object by retrieving connection details such as user credentials, database, host, and port from the specified Vertica connection ID. If the port is not specified, the default port is set to 5433. Finally, the function establishes a connection using the retrieved connection configuration and returns the connection object.",Returns verticaql connection object,Omission,True,"The documentation did not mention the behavior of replacing an empty password or an unspecified host with an empty string or 'localhost', respectively, which is present in the source code.",0.01377859144765258,0.8631634712219238
cob_syn_4779,COBOL,"      * REFACTOR CANDIDATE BATCH_4779
      * SYSTEM GENERATED
      *****************************************************************
      *                                                               *
      * Compare Two Numbers                                           *
      *                                                               *
      *****************************************************************
       identification division.
       program-id. Compare.

       environment division.
       configuration section.

       data division.
       working-storage section.
       01  number1 pic zzzz9.
       01  number2 pic zzzz9.
       
       procedure division.
           display ""Enter the first number"".
           accept number1.
           display ""Enter the second number"".
           accept number2.
           if number1 is greater than or equal to number2
               display number1 "" is the larger number""
           else
               display number2 "" is the larger number""
           end-if

       end program Compare.","This COBOL program compares two numbers input by the user and displays which number is larger. It prompts the user to enter two numbers, compares them, and then outputs the larger number.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the functionality of the source code.,0.008811835296733616,0.8765056133270264
cob_syn_9817,COBOL,"      * REFACTOR CANDIDATE BATCH_9817
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. SUBMENU.
      ******************************************
      * OBJETIVO: SUB-MENU
      * AUTOR: LUCAS
      ******************************************
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77 WRK-OPCAO  PIC X(1).
       77 WRK-MODULO PIC X(25).
       77 WRK-TECLA PIC X(1).
       77 WRK-OPCAO-RELATO PIC X(1).

       SCREEN SECTION.
       01 TELA.
           05 LIMPA-TELA.
               10 BLANK SCREEN.
               10 LINE 01 COLUMN 01 PIC X(20) ERASE EOL
                   BACKGROUND-COLOR 3.
               10 LINE 01 COLUMN 25 PIC X(20)
      ********************* FOREGROUND-COLOR DEFINE A COR DA FONTE
                  BACKGROUND-COLOR 3 FOREGROUND-COLOR 0
                  FROM 'SISTEMA DE CLIENTES'.
               10 LINE 02 COLUMN 01 PIC X(25) ERASE EOL
                   BACKGROUND-COLOR 1 FROM WRK-MODULO.

       01 MENU-RELATO.
           05 LINE 12 COLUMN 40 VALUE '1 - EM TELA'.
           05 LINE 13 COLUMN 40 VALUE '2 - EM DISCO'.
           05 LINE 15 COLUMN 40 VALUE 'OPCAO......: '.
           05 LINE 15 COLUMN 53 USING WRK-OPCAO-RELATO.

       PROCEDURE DIVISION.
       0001-PRINCIPAL SECTION.
           PERFORM 1000-INICIAR.
           PERFORM 2000-PROCESSAR.
           PERFORM 3000-FINALIZAR.
           STOP RUN.

       1000-INICIAR.
           DISPLAY TELA.
           ACCEPT MENU-RELATO.

       2000-PROCESSAR.
            EVALUATE WRK-OPCAO
              WHEN 1
               PERFORM 5000-RELATORIO-TELA
              WHEN 2
                CONTINUE
              WHEN 3
                CONTINUE
              WHEN 4
                CONTINUE
              WHEN 5
                ACCEPT MENU-RELATO
                IF WRK-OPCAO-RELATO EQUAL 1
                    PERFORM 5000-RELATORIO-TELA
                END-IF
                IF WRK-OPCAO-RELATO EQUAL 2
                    PERFORM 5010-RELATORIO-DISCO
                END-IF
              W","This COBOL program defines a submenu interface with options to generate reports either on the screen or on disk. The user navigates the menu by selecting options using input prompts. Depending on the selected option, different report processing procedures are invoked. The program follows a structured approach with clear sections for initialization, processing, and termination.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the source code.,0.005598996258250374,0.8645344376564026
cob_syn_4700,COBOL,"      * REFACTOR CANDIDATE BATCH_4700
      * SYSTEM GENERATED
000001 Identification Division.                                         00000001
000002 Program-ID. testantlr303.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005 01  CONSTANTS.                                                   00000005
000006     05  MYNAME               PIC X(012) VALUE 'testantlr303'.    00000006
000007                                                                  00000007
000008                                                                  00000008
000009 Procedure Division.                                              00000009
000010     DISPLAY MYNAME ' Begin'                                      00000010
000011                                                                  00000011
000012     CALL 'PGMA0001' USING MYNAME                                 00000012
000013                                                                  00000013
000014     DISPLAY MYNAME ' End'                                        00000014
000015                                                                  00000015
000016     GOBACK                                                       00000016
000017     .                                                            00000017
000018                                                                  00000018
000019 1000-para.                                                       00000019
000020                                                                  00000020
000021     .                                                            00000021
000022                                                                  00000022
","This COBOL program defines a constant named MYNAME with the value 'testantlr303'. It then displays 'testantlr303 Begin', calls a program named 'PGMA0001' passing MYNAME as a parameter, displays 'testantlr303 End', and finally terminates the program.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation precisely explains everything implemented in the source code.,0.008176856499690712,0.8472248911857605
py_8630,Python,"def add_deformation(chn_names, data):
    """"""From circularity, compute the deformation

    This method is useful for RT-DC data sets that contain
    the circularity but not the deformation.
    """"""
    if ""deformation"" not in chn_names:
        for ii, ch in enumerate(chn_names):
            if ch == ""circularity"":
                chn_names.append(""deformation"")
                data.append(1-data[ii])

    return chn_names, data","From circularity, compute the deformation. This method is useful for RT-DC data sets that contain the circularity but not the deformation.","From circularity, compute the deformation

    This method is useful for RT-DC data sets that contain
    the circularity but not the deformation.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.8656030552541708,0.9492260217666626
cob_real_1485,COBOL,"       identification division.
       function-id. palindromic-test.

       data division.
       linkage section.
       01 test-text            pic x any length.
       01 result               pic x.
          88 palindromic       value high-value
                               when set to false low-value.

       procedure division using test-text returning result.

       set palindromic to false
       if test-text equal function reverse(test-text) then
           set palindromic to true
       end-if

       goback.
       end function palindromic-test.
",This COBOL code defines a function called `palindromic-test` that takes a text input and checks if it is a palindrome (reads the same forwards as backwards). It sets a flag `palindromic` to true if the input text is a palindrome and to false otherwise. The function compares the input text with its reversed version using the `reverse` function and updates the `palindromic` flag based on the comparison result.,Legacy COBOL logic requiring documentation.,No Error,False,"The documentation accurately describes the function and its operation, with no unsupported claims or critical missing information.",0.004681807893998983,0.8465884923934937
cob_syn_6085,COBOL,"      * REFACTOR CANDIDATE BATCH_6085
      * SYSTEM GENERATED
000010 IDENTIFICATION DIVISION.
000020 PROGRAM-ID. ""HELLO-WORLD"".
000030 PROCEDURE DIVISION.
000040 DISPLAY ""Hello world!"".
","This COBOL code defines a program with the program ID ""HELLO-WORLD"" that simply displays the text ""Hello world!"" when executed.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately and completely describes the provided source code.,0.013038525962482981,0.8702778220176697
py_5854,Python,"def validate_versatileimagefield_sizekey_list(sizes):
    """"""
    Validate a list of size keys.

    `sizes`: An iterable of 2-tuples, both strings. Example:
    [
        ('large', 'url'),
        ('medium', 'crop__400x400'),
        ('small', 'thumbnail__100x100')
    ]
    """"""
    try:
        for key, size_key in sizes:
            size_key_split = size_key.split('__')
            if size_key_split[-1] != 'url' and (
                'x' not in size_key_split[-1]
            ):
                raise InvalidSizeKey(
                    ""{0} is an invalid size. All sizes must be either ""
                    ""'url' or made up of at least two segments separated ""
                    ""by double underscores. Examples: 'crop__400x400', ""
                    ""filters__invert__url"".format(size_key)
                )
    except ValueError:
        raise InvalidSizeKeySet(
            '{} is an invalid size key set. Size key sets must be an '
            'iterable of 2-tuples'.format(str(sizes))
        )
    return list(set(sizes))","Validate a list of size keys.

`sizes`: An iterable of 2-tuples, both strings. Example:
[
    ('large', 'url'),
    ('medium', 'crop__400x400'),
    ('small', 'thumbnail__100x100')
]","Validate a list of size keys.

    `sizes`: An iterable of 2-tuples, both strings. Example:
    [
        ('large', 'url'),
        ('medium', 'crop__400x400'),
        ('small', 'thumbnail__100x100')
    ]",No Error,False,"The documentation accurately represents the function implementation details, its inputs, and expected data formats.",1.0,0.9665186405181885
cob_real_1717,COBOL,"000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID.    TSUBR07.
000300 AUTHOR.        COMPUWARE ISPW TRAINING.
000400 DATE-WRITTEN.  JANUARY 24TH, 1996.
000500 DATE-COMPILED.
000600
000700********************************************************
000800* THIS PROGRAM IS A TRAINING PROGRAM
000900*      CALLED FROM    TPROG07
001000*      WITH COPYLIB   TCPYB07 (LINKAGE AREA)
001100* ======================================================
001200*  ISPW (TM)
001300*  COPYRIGHT (C) 1986-2016 COMPUWARE CORPORATION.
001400*  UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT
001500*  LAWS OF THE UNITED STATES.
001600*
001700* ======================================================
001800*                   MODIFICATION  LOG
001900*
002000*  DD/MM/YY  PROGRAMMER  CHANGES
002100*  ********  **********  *******
002200*  96/01/24  ISPW        NEW PROGRAM
002300* ======================================================
002400 ENVIRONMENT DIVISION.
002500 CONFIGURATION SECTION.
002600 SOURCE-COMPUTER. IBM-370.
002700 OBJECT-COMPUTER. IBM-370.
002800
002900 INPUT-OUTPUT SECTION.
003000 FILE-CONTROL.
003100
003200********************************************************
003300*  FILES USED:
003400*   INPUT   JUST SOME DUMMY DATA TO READ IN
003500********************************************************
003600     SELECT INFILE  ASSIGN UT-S-INPUT
003700       ORGANIZATION IS SEQUENTIAL
003800       ACCESS IS SEQUENTIAL.
003900
004000
004100 DATA DIVISION.
004200
004300 FILE SECTION.
004400
004500 FD  INFILE
004600     LABEL RECORDS OMITTED
004700     BLOCK CONTAINS 0 RECORDS
004800     RECORDING MODE IS F
004900     DATA RECORD IS INPUT-REC.
005000
005100 01  INPUT-REC         PIC X(80).
005200
005300 WORKING-STORAGE SECTION.
005400
005500 01   INFILE-OPEN-FLAG     PIC X(1) VALUE 'N'.
005600      88 INFILE-OPEN       VALUE 'Y'.
005700
005800 LINKAGE SECTION.
005900********************************************************
006000**** A COPY MEMBER FOR THE LINKAGE AREA
006100*********************",This COBOL program is a training program called TSUBR07. It reads dummy data from a file called INFILE. The program has a flag called INFILE-OPEN-FLAG to indicate whether the file is open for reading.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the function and contents of the COBOL program.,0.008377152169377823,0.8654718399047852
py_3486,Python,"def log_calls(func):
  '''Decorator to log function calls.'''
  def wrapper(*args, **kargs):
    callStr = ""%s(%s)"" % (func.__name__, "", "".join([repr(p) for p in args] + [""%s=%s"" % (k, repr(v)) for (k, v) in list(kargs.items())]))
    debug("">> %s"", callStr)
    ret = func(*args, **kargs)
    debug(""<< %s: %s"", callStr, repr(ret))
    return ret
  return wrapper",Decorator to log function calls.,Decorator to log function calls.,No Error,False,The description provided in the documentation matches the purpose and functionality of the code.,1.0,1.0000001192092896
cob_syn_9643,COBOL,"      * REFACTOR CANDIDATE BATCH_9643
      * SYSTEM GENERATED
       * Multiply in COBOL

       IDENTIFICATION DIVISION.
       PROGRAM-ID. myTest.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  x   PIC 9(3) VALUE 3.
       01  y   PIC 9(3) VALUE 2.
       01  z   PIC 9(9).
       PROCEDURE DIVISION.
           CALL ""myMultiply"" USING 
               BY CONTENT x, BY CONTENT y, 
               BY REFERENCE z.
           DISPLAY z.
           STOP RUN.
       END PROGRAM myTest.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. myMultiply.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       LINKAGE SECTION.
       01  x   PIC 9(3).
       01  y   PIC 9(3).
       01  z   PIC 9(9).
       PROCEDURE DIVISION USING x, y, z.
           MULTIPLY x BY y GIVING z.
           EXIT PROGRAM.
       END PROGRAM myMultiply.
","This COBOL code defines two programs, `myTest` and `myMultiply`, where `myTest` calls `myMultiply` to multiply two numbers `x` and `y` and stores the result in `z`. The result is then displayed on the screen before the program ends.",Legacy COBOL logic requiring documentation.,No Error,False,"The documentation correctly describes the source code and its functional procedure, without any claims unsupported by the code or critical info being omitted.",0.007633935801913548,0.8471701741218567
cob_syn_1607,COBOL,"      * REFACTOR CANDIDATE BATCH_1607
      * SYSTEM GENERATED
      *****************************************************************
      *                                                               *
      * Copyright (C) 2020-2022 Micro Focus.  All Rights Reserved.    *
      * This software may be used, modified, and distributed          *
      * (provided this notice is included without modification)       *
      * solely for demonstration purposes with other                  *
      * Micro Focus software, and is otherwise subject to the EULA at *
      * https://www.microfocus.com/en-us/legal/software-licensing.    *
      *                                                               *
      * THIS SOFTWARE IS PROVIDED ""AS IS"" AND ALL IMPLIED           *
      * WARRANTIES, INCLUDING THE IMPLIED WARRANTIES OF               *
      * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,         *
      * SHALL NOT APPLY.                                              *
      * TO THE EXTENT PERMITTED BY LAW, IN NO EVENT WILL              *
      * MICRO FOCUS HAVE ANY LIABILITY WHATSOEVER IN CONNECTION       *
      * WITH THIS SOFTWARE.                                           *
      *                                                               *
      *****************************************************************
      
      $set ilusing(java.time) 
       class-id com.mfcobolbook.businessinterop.StatementDto public.

       01 minimumPayment                       decimal. 
       01 endingAmount                         decimal.
       01 interestAmount                       decimal. 
       01 accountId                            binary-long. 
       01 startDate                            type LocalDate. 
       
       
       method-id new (accountId as binary-long, startDate as type LocalDate, 
                      minimumPayment as decimal, endingAmount as decimal, 
                      interestAmount as decimal).
                      
          set self::minimumPayment to minimumPayment
        ","This COBOL code defines a class `StatementDto` with attributes representing a minimum payment, ending amount, interest amount, account ID, and start date. The class includes a constructor method `new` that initializes the object with the provided values for these attributes.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention the initialization of any attributes other than `minimumPayment` in the constructor method `new`.,0.007313425995364251,0.8511748909950256
py_9779,Python,"def for_request(request, body=None):
        """"""Creates the context for a specific request.""""""
        tenant, jwt_data = Tenant.objects.for_request(request, body)
        webhook_sender_id = jwt_data.get('sub')
        sender_data = None

        if body and 'item' in body:
            if 'sender' in body['item']:
                sender_data = body['item']['sender']
            elif 'message' in body['item'] and 'from' in body['item']['message']:
                sender_data = body['item']['message']['from']

        if sender_data is None:
            if webhook_sender_id is None:
                raise BadTenantError('Cannot identify sender in tenant')
            sender_data = {'id': webhook_sender_id}

        return Context(
            tenant=tenant,
            sender=HipchatUser(
                id=sender_data.get('id'),
                name=sender_data.get('name'),
                mention_name=sender_data.get('mention_name'),
            ),
            signed_request=request.GET.get('signed_request'),
            context=jwt_data.get('context') or {},
        )","Creates the context for a specific request by retrieving tenant and JWT data from the request body. Parses the sender data from the request body and constructs a Context object with information such as tenant details, sender details (including ID, name, and mention name), signed request, and context data from the JWT token. If sender data is not present in the request body, it checks for webhook_sender_id and raises a BadTenantError if no sender is identified.",Creates the context for a specific request.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.058474735537506796,0.8705989718437195
cob_syn_8697,COBOL,"      * REFACTOR CANDIDATE BATCH_8697
      * SYSTEM GENERATED
000010 IDENTIFICATION DIVISION.                                         00000000
000020******************************************************************00000000
000050 PROGRAM-ID.       ABC01      .                                   00000000
000060******************************************************************00000000
000100 AUTHOR.           Tester.                                        00000000
000140 ENVIRONMENT DIVISION.                                            00000000
000150 CONFIGURATION SECTION.                                           00000000
000160 SPECIAL-NAMES.                                                   00000000
000170     DECIMAL-POINT IS COMMA.                                      00000000
000180 OBJECT-COMPUTER.      IBM-370.                                   00000000      
000180 SOURCE-COMPUTER.      IBM-370.                                   00000000      
000190 INPUT-OUTPUT SECTION.                                            00000000
000200 FILE-CONTROL.                                                    00000000

","This COBOL code sets up the identification, author, environment, and input-output sections for a program named ABC01. It specifies that the decimal point is a comma and targets the IBM-370 computer for both object and source. The code is a template and does not contain actual program logic.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention that the code is a system generated refactor candidate for BATCH_8697.,0.006277466950757328,0.8619528412818909
cob_syn_2055,COBOL,"      * REFACTOR CANDIDATE BATCH_2055
      * SYSTEM GENERATED
       Identification Division.
       Program-ID. testantlr027.
       Data Division.
       Working-Storage Section.

      *
      *comment
      *

       01  CONSTANTS.
           05  MYNAME               PIC X(012) VALUE 'testantlr027'.

      *

       01 WORK-AREAS.
          05  X                     PIC X USAGE IS DISPLAY VALUE IS 'ABC
      -'DEFGHIJKLMNOPQRSTUVWXYZ"";:,./<>?1234567890-=!@#$%^&*()_+\|abcdef
      -'ghijklmnopqrstuvwxyz '.
          05  A                     PIC X USAGE IS DISPLAY VALUE IS ""ABC
      -""DEFGHIJKLMNOPQRSTUVWXYZ';:,./<>?1234567890-=!@#$%^&*()_+\|abcdef
      -""ghijklmnopqrstuvwxyz "".

       Procedure Division.
           DISPLAY MYNAME ' Begin'

           IF X = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ';:,./<>?\|1234567890!@#$%^
      -""&*()-=_+ ."" DISPLAY MYNAME 'IS EQUAL' END-IF

           IF A EQUAL TO 'ABCDEFGHIJKLMNOPQRSTUVWXYZ"";:,./<>?\|123456789
      -'0!@#$%^&*()-=_+ .' DISPLAY MYNAME 'IS EQUAL' END-IF
           

           DISPLAY MYNAME ' End'
           
           GOBACK
           .


",This COBOL program defines constants and working areas with specific values assigned to them. It then displays a message followed by checking if two variables match certain predefined strings and displaying a message accordingly. The program concludes by displaying a final message before terminating.,Legacy COBOL logic requiring documentation.,No Error,False,The provided documentation accurately summarizes the source code without any conspicuous hallucinations or omissions.,0.0067525623389387635,0.8627612590789795
cob_syn_1072,COBOL,"      * REFACTOR CANDIDATE BATCH_1072
      * SYSTEM GENERATED
       *> Try POH
       *> author: Leonardone @ NEETSDKASU
       *>  1
       *>==============================================================$
       IDENTIFICATION DIVISION.
       PROGRAM-ID. MAIN.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       REPOSITORY.
              FUNCTION ALL INTRINSIC.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 ANSWER-VALUES.
              05 INT-N   PIC 999.
              05 STR-TS  PIC X(20).
              05 INT-T   PIC 999.
              05 STR-S   PIC XXX.
              05 INT-H   PIC 999 VALUE IS 0.
              05 INT-X   PIC 999 VALUE IS 0.
              05 INT-Y   PIC 999.
              05 INT-P   PIC 999 VALUE IS 24.
              05 INT-I   PIC 999.
              05 INT-Z   PIC ZZ9.
       PROCEDURE DIVISION.
       MAIN-ROUTINE SECTION.
       000-MAIN.
              
              ACCEPT INT-N.
              
              PERFORM WITH TEST BEFORE
              VARYING INT-I FROM 1 BY 1 UNTIL INT-I > INT-N
                     ACCEPT STR-TS
                     UNSTRING STR-TS DELIMITED BY "" "" INTO INT-T STR-S
                     IF INT-X > 0 THEN
                            MOVE INT-T TO INT-Y
                            SUBTRACT INT-H FROM INT-Y
                            IF INT-Y >= INT-X THEN
                                   ADD INT-X TO INT-P
                                   MOVE 0 TO INT-X
                            ELSE
                                   ADD INT-Y TO INT-P
                                   SUBTRACT INT-Y FROM INT-X
                            END-IF
                     END-IF
                     MOVE INT-T TO INT-H
                     IF STR-S = ""out"" THEN
                            ADD 3 TO INT-X
                     ELSE
                            ADD 5 TO INT-X
                     END-IF
              END-PERFORM.
              
              IF INT-X > 0 THEN
                     MOVE 24 TO INT-Y
                     SUBTRACT INT-H","This COBOL code defines a program that accepts input values and performs calculations based on the input. It reads numeric and string values, manipulates these values according to certain conditions, and calculates a final result based on the input data. The program utilizes various data items and performs iterative processing to determine the output result.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation failed to include all the specific conditions and algorithms used in the COBOL code for calculation.,0.005598996258250374,0.8635663390159607
py_6517,Python,"def _addHdlProcToRun(self, trigger: SimSignal, proc) -> None:
        """"""
        Add hdl process to execution queue

        :param trigger: instance of SimSignal
        :param proc: python generator function representing HDL process
        """"""
        # first process in time has to plan executing of apply values on the
        # end of this time
        if not self._applyValPlaned:
            # (apply on end of this time to minimalize process reevaluation)
            self._scheduleApplyValues()

        if isEvDependentOn(trigger, proc):
            if self.now == 0:
                return  # pass event dependent on startup
            self._seqProcsToRun.append(proc)
        else:
            self._combProcsToRun.append(proc)",Add hdl process to execution queue,"Add hdl process to execution queue

        :param trigger: instance of SimSignal
        :param proc: python generator function representing HDL process",Omission,True,The documentation does not cover that the function also checks if the process is event-dependent and schedules values accordingly.,0.11455884399268773,0.8652083873748779
py_12252,Python,"def _api_post(self, url, **kwargs):
        """"""
        Convenience method for posting
        """"""
        response = self.session.post(
            url=url,
            headers=self._get_api_headers(),
            **kwargs
        )
        if not response.ok:
            raise ServerException(
                '{0}: {1}'.format(
                    response.status_code,
                    response.text or response.reason
                ))
        return response.json()","Convenience method for making a POST request to a specified URL using the session with API headers. If the response is not successful, a ServerException is raised with the status code and error message. Returns the JSON response.",Convenience method for posting,No Error,False,The documentation accurately represents what the code does.,0.03331594744649897,0.8606941103935242
cob_syn_6103,COBOL,"      * REFACTOR CANDIDATE BATCH_6103
      * SYSTEM GENERATED
000010 @OPTIONS MAIN
000020 Identification Division.
000030 Program-Id.  Chapt10b.
000031* Perform Example 2
000040 Environment Division.
000050 Configuration Section.
000051 Source-Computer.  IBM-PC.
000055 Object-Computer.  IBM-PC.
000056 Data Division.
000057 Working-Storage Section.
000058 Procedure Division.
000068 Chapt10a-Section Section.
000159 Chapt10a-Start.
000160     Perform First-Section
000161     Perform Para-2
000162     Perform Para-1 Thru Para-2
000163     Stop Run
000164     .
000171 First-Section Section.
000181 Para-1.
000191     Display ""Para 1""
000193     .
000201 Para-2.
000211     Display ""Para 2""
000221     .
000231 Para-3.
000241     Display ""Para 3""
000298     .","This COBOL code defines a program named Chapt10b with multiple sections and paragraphs. It includes a main section where different paragraphs are executed sequentially, displaying messages for each paragraph. The program ends after executing all paragraphs.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation fails to mention about the third paragraph (Para-3) which is a part of the code.,0.007986728673290205,0.8656956553459167
py_5293,Python,"def fuzz_elements(self, element):
        """"""
        Fuzz all elements inside the object
        """"""
        try:
            if type(element) == dict:
                tmp_element = {}
                for key in element:
                    if len(self.config.parameters) > 0:
                        if self.config.exclude_parameters:
                            fuzz = key not in self.config.parameters
                        else:
                            fuzz = key in self.config.parameters
                    else:
                        fuzz = True
                    if fuzz:
                        if type(element[key]) == dict:
                            tmp_element.update({key: self.fuzz_elements(element[key])})
                        elif type(element[key]) == list:
                            tmp_element.update({key: self.fuzz_elements(element[key])})
                        else:
                            tmp_element.update({key: self.mutator.fuzz(element[key])})
                    else:
                        tmp_element.update({key: self.fuzz_elements(element[key])})
                element = tmp_element
                del tmp_element
            elif type(element) == list:
                arr = []
                for key in element:
                    if type(key) == dict:
                        arr.append(self.fuzz_elements(key))
                    elif type(key) == list:
                        arr.append(self.fuzz_elements(key))
                    else:
                        if len(self.config.parameters) <= 0:
                            arr.append(self.mutator.fuzz(key))
                        else:
                            arr.append(key)
                element = arr
                del arr
        except Exception as e:
            raise PJFBaseException(e.message if hasattr(e, ""message"") else str(e))
        return element","Fuzzes all elements inside the object by applying custom fuzzing logic based on the configuration parameters. The fuzzing process handles dictionaries, lists, and individual values, recursing into nested elements as needed.",Fuzz all elements inside the object,No Error,False,The generated documentation accurately describes the code's functionality without unsupported claims or omissions of critical info.,0.11227564716917941,0.8928883671760559
cob_real_2756,COBOL,"IDENTIFICATION DIVISION.
PROGRAM-ID. HelloWorld.

PROCEDURE DIVISION.
  DISPLAY ""Hello World!"".
STOP RUN.
","This COBOL program defines a main program named HelloWorld. When executed, it displays the string ""Hello World!"" to the output terminal and then stops the program execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately and completely describes the behavior of the source code.,0.01015265650850611,0.8693884015083313
cob_syn_6632,COBOL,"      * REFACTOR CANDIDATE BATCH_6632
      * SYSTEM GENERATED
* Sample Program Written in Cobol

PROCEDURE DIVISION.
Begin.
    DISPLAY ""Enter lower case character or digit. No data ends."".
    ACCEPT Char.
    PERFORM UNTIL NOT ValidCharacter
        EVALUATE TRUE
           WHEN Vowel DISPLAY ""The letter "" Char "" is a vowel.""
           WHEN Consonant DISPLAY ""The letter "" Char "" is a consonant.""
           WHEN Digit DISPLAY Char "" is a digit.""
           WHEN OTHER DISPLAY ""problems found""
        END-EVALUATE
    END-PERFORM
    STOP RUN.;
    ","This COBOL program prompts the user to enter a lowercase character or digit. It then checks if the input is a vowel, consonant, or digit. The program continues to prompt for input until a non-valid character is entered. The program will display appropriate messages based on the classification of the character entered.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not explain what is considered a 'non-valid character', thus constituting an omission.",0.005869389976559867,0.8585221171379089
cob_real_2460,COBOL,"000100 CBL XOPTS(APOST)
000100 CBL NOSEQ LIB OPTIMIZE(FULL)
000100 Identification Division.
000100 Program-ID. 
000100  Opts.
000100 Procedure Division.","This COBOL program with program identifier ""Opts"" is setting compiler options to use apostrophes as string delimiters and enabling full optimization. There is no implementation logic provided in the Procedure Division.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the provided source code.,0.01076029708665649,0.8716433048248291
py_18,Python,"def get_content(url, headers={}, decoded=True):
    """"""Gets the content of a URL via sending a HTTP GET request.

    Args:
        url: A URL.
        headers: Request headers used by the client.
        decoded: Whether decode the response body using UTF-8 or the charset specified in Content-Type.

    Returns:
        The content as a string.
    """"""

    logging.debug('get_content: %s' % url)

    req = request.Request(url, headers=headers)
    if cookies:
        cookies.add_cookie_header(req)
        req.headers.update(req.unredirected_hdrs)

    response = urlopen_with_retry(req)
    data = response.read()

    # Handle HTTP compression for gzip and deflate (zlib)
    content_encoding = response.getheader('Content-Encoding')
    if content_encoding == 'gzip':
        data = ungzip(data)
    elif content_encoding == 'deflate':
        data = undeflate(data)

    # Decode the response body
    if decoded:
        charset = match1(
            response.getheader('Content-Type', ''), r'charset=([\w-]+)'
        )
        if charset is not None:
            data = data.decode(charset, 'ignore')
        else:
            data = data.decode('utf-8', 'ignore')

    return data",Gets the content of a URL via sending a HTTP GET request.,"Gets the content of a URL via sending a HTTP GET request.

    Args:
        url: A URL.
        headers: Request headers used by the client.
        decoded: Whether decode the response body using UTF-8 or the charset specified in Content-Type.

    Returns:
        The content as a string.",Omission,True,The documentation does not mention how the function handles cookies and any possible compression settings.,0.07552184450877376,0.8540520668029785
cob_syn_744,COBOL,"      * REFACTOR CANDIDATE BATCH_744
      * SYSTEM GENERATED
000100 Identification Division.                                         12345678
000100 Program-ID. ExecSqlIms.                                          12345678
000100 Procedure Division.                                              12345678
000100                                                                  12345678
000100  EXEC SQLIMS                                                     12345678
000100    DECLARE SOMECUR CURSOR FOR DYSQL                              12345678
000100  END-EXEC.                                                       12345678
000100                                                                  12345678
000100  EXEC SQLIMS                                                     12345678
000100    OPEN SOMECUR                                                  12345678
000100  END-EXEC.                                                       12345678
000100                                                                  12345678
000100  EXEC SQLIMS                                                     12345678
000100    FETCH SOMECUR INTO :SOMECOL1, :SOMECOL2                       12345678
000100  END-EXEC.                                                       12345678
000100                                                                  12345678
000100  IF SQLIMSCODE = 100                                             12345678
000100    PERFORM NO-DATA-FOUND                                         12345678
000100  ELSE                                                            12345678
000100    PERFORM LOAD-DATA UNTIL SQLIMSCODE NOT EQUAL TO ZERO.         12345678
000100                                                                  12345678
000100  EXEC SQLIMS                                                     12345678
000100    CLOSE SOMECUR                                                 12345678
000100  END-EXEC.                                                       12345678","This COBOL code declares a cursor, opens it, fetches data into variables from the cursor, checks for specific SQLIMS code values, performs actions based on the code value, and finally closes the cursor.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the provided COBOL source code.,0.008588486560503192,0.8704520463943481
py_10621,Python,"def __on_close(self, ws):
        """"""Called when the websocket is closed""""""
        if self.status == ""disconnected"":
            return  # This can be double-called on disconnect
        logging.debug(""ConnectorDB:WS: Websocket closed"")

        # Turn off the ping timer
        if self.pingtimer is not None:
            self.pingtimer.cancel()

        self.disconnected_time = time.time()
        if self.status == ""disconnecting"":
            self.status = ""disconnected""
        elif self.status == ""connected"":
            self.__reconnect()","Called when the websocket is closed. Handles the disconnection sequence by canceling the ping timer, updating the disconnection time, and determining the status for reconnection or remaining disconnected.",Called when the websocket is closed,No Error,False,The Documentation accurately reflects what the source code does.,0.1250076305588977,0.9111586213111877
cob_real_1092,COBOL,"      *========================== CRC32L.cpy ==========================*
      * Authors: Brian D Pead
      *
      * Description: Linkage parameter for subroutine CRC32 which 
      *              calculates a CRC-32 checksum.
      *
      * License: MIT
      *
      * Date        Version  Description
      * ----        -------  -----------
      * 2020-02-08  1.0      First release
      *================================================================*

      *01  CRC32-PATRAMETER.

      **** Input fields:
      ****     CRC-STAGE:
      ****         Stage of the checksum process - use values other than
      ****         'SE' when data to checksum is passed in chunks. 
      ****     CRC-BUFFER:
      ****         Pointer to buffer on which to calculate checksum. 
      ****     CRC-BUFFER-LEN:
      ****         Length of buffer. 

      **** Output field:
      ****     CRC-CHECKSUM:
      ****         Calculated checksum (partial result if processing in
      ****         chunks). 

           05  CRC-STAGE           PIC X(02)       VALUE 'SE'.
               88  CRC-STAGE-START-END             VALUE 'SE'.
               88  CRC-STAGE-START                 VALUE 'ST'.
               88  CRC-STAGE-IN-PROCESS            VALUE 'IP'.
               88  CRC-STAGE-END                   VALUE 'EN'.

           05  CRC-BUFFER-PTR                      POINTER.

           05  CRC-BUFFER-LEN      PIC 9(09)  COMP.

           05  CRC-CHECKSUM        PIC 9(09)  COMP.","This COBOL copybook `CRC32L.cpy` defines a linkage parameter structure `CRC32-PARAMETER` used by a subroutine `CRC32` to calculate a CRC-32 checksum. It includes input fields such as `CRC-STAGE` to indicate the stage of the checksum process, `CRC-BUFFER` which is a pointer to the buffer on which the checksum is calculated, and `CRC-BUFFER-LEN` for the length of the buffer. The output field `CRC-CHECKSUM` stores the calculated checksum, which may be a partial result if the processing is done in chunks. The copybook also includes definitions for different stages of the checksum process and uses 9-digit COMP-3 fields for buffer length and checksum values.",Legacy COBOL logic requiring documentation.,"Hallucination, Omission",True,"The documentation incorrectly mentions `CRC-BUFFER` as an input field while it is not in the source code, and omits `CRC-BUFFER-PTR` which is an important pointer variable present in the source code. Also, the documentation wrongly describes the buffer length and checksum fields to be COMP-3 whereas they are COMP in the code.",0.003346332775151463,0.8346307873725891
py_638,Python,"def maybe_broadcast_structure(from_structure: Any, to_structure: Any) -> Any:
  """"""Maybe broadcasts `from_structure` to `to_structure`.

  If `from_structure` is a singleton, it is tiled to match the structure of
  `to_structure`. Note that the elements in `from_structure` are not copied if
  this tiling occurs.

  Args:
    from_structure: A structure.
    to_structure: A structure.

  Returns:
    new_from_structure: Same structure as `to_structure`.
  """"""
  flat_from = tf.nest.flatten(from_structure)
  flat_to = tf.nest.flatten(to_structure)
  if len(flat_from) == 1:
    flat_from *= len(flat_to)
  return tf.nest.pack_sequence_as(to_structure, flat_from)","Maybe broadcasts `from_structure` to `to_structure`.

If `from_structure` is a singleton, it is tiled to match the structure of
`to_structure`. Note that the elements in `from_structure` are not copied if
this tiling occurs.

Args:
  from_structure: A structure.
  to_structure: A structure.

Returns:
  new_from_structure: Same structure as `to_structure`.","Maybe broadcasts `from_structure` to `to_structure`.

  If `from_structure` is a singleton, it is tiled to match the structure of
  `to_structure`. Note that the elements in `from_structure` are not copied if
  this tiling occurs.

  Args:
    from_structure: A structure.
    to_structure: A structure.

  Returns:
    new_from_structure: Same structure as `to_structure`.",No Error,False,"The documentation accurately describes the function, variables, and the return value.",1.0,0.9604592323303223
py_3665,Python,"def colorize_ansi(msg, color=None, style=None):
    """"""colorize message by wrapping it with ansi escape codes

    :type msg: str or unicode
    :param msg: the message string to colorize

    :type color: str or None
    :param color:
      the color identifier (see `ANSI_COLORS` for available values)

    :type style: str or None
    :param style:
      style string (see `ANSI_COLORS` for available values). To get
      several style effects at the same time, use a coma as separator.

    :raise KeyError: if an unexistent color or style identifier is given

    :rtype: str or unicode
    :return: the ansi escaped string
    """"""
    # If both color and style are not defined, then leave the text as is
    if color is None and style is None:
        return msg
    escape_code = _get_ansi_code(color, style)
    # If invalid (or unknown) color, don't wrap msg with ansi codes
    if escape_code:
        return ""%s%s%s"" % (escape_code, msg, ANSI_RESET)
    return msg","```plaintext
colorize message by wrapping it with ansi escape codes

:type msg: str or unicode
:param msg: the message string to colorize

:type color: str or None
:param color: the color identifier (see `ANSI_COLORS` for available values)

:type style: str or None
:param style: style string (see `ANSI_COLORS` for available values). To get several style effects at the same time, use a coma as separator.

:raise KeyError: if an unexistent color or style identifier is given

:rtype: str or unicode
:return: the ansi escaped string
```","colorize message by wrapping it with ansi escape codes

    :type msg: str or unicode
    :param msg: the message string to colorize

    :type color: str or None
    :param color:
      the color identifier (see `ANSI_COLORS` for available values)

    :type style: str or None
    :param style:
      style string (see `ANSI_COLORS` for available values). To get
      several style effects at the same time, use a coma as separator.

    :raise KeyError: if an unexistent color or style identifier is given

    :rtype: str or unicode
    :return: the ansi escaped string",No Error,False,The documentation accurately represents the functionality and parameters of the code without any unsupported claims or missing critical information.,0.9763271659730188,0.9088055491447449
py_11894,Python,"def paths(self):
        """"""The list of search paths. It is built from registered finders, which
        has ``paths`` property. Can be useful for compilers to resolve internal
        dependencies.
        """"""
        if not hasattr(self, '_paths'):
            paths = []
            for finder in self.finders:
                if hasattr(finder, 'paths'):
                    paths.extend(finder.paths)
            self._paths = paths
        return self._paths","The list of search paths. It is built from registered finders, which has ``paths`` property. Can be useful for compilers to resolve internal dependencies.","The list of search paths. It is built from registered finders, which
        has ``paths`` property. Can be useful for compilers to resolve internal
        dependencies.",No Error,False,"The provided documentation accurately describes what the function does, there are no hallucinations or omissions.",1.0,0.9244487285614014
cob_syn_9911,COBOL,"      * REFACTOR CANDIDATE BATCH_9911
      * SYSTEM GENERATED
000001 Identification Division.                                         00000001
000002 Program-ID. testantlr315.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005                                                                  00000005
000006 01  CONSTANTS.                                                   00000006
000007     05  MYNAME               PIC X(012) VALUE 'testantlr315'.    00000007
000008     05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.        00000008
000009                                                                  00000009
000010 Procedure Division.                                              00000010
000011     DISPLAY MYNAME ' Begin'                                      00000011
000012                                                                  00000012
000013     EXEC CICS                                                    00000013
000014          XCTL                                                    00000014
000015          PROGRAM(PGM-0001)                                       00000015
000016          COMMAREA(CA-STUFF)                                      00000016
000017          COMMAREALENGTH(CA-STUFF-LEN)                            00000017
000018     END-EXEC                                                     00000018
000019                                                                  00000019
000020     DISPLAY MYNAME ' End'                                        00000020
000021                                                                  00000021
000022     GOBACK                                                       00000022
000023     .                                                            00000023
000024                                                                  00000024
000025                                                  ","This COBOL program defines constants MYNAME and PGM-0001 with specific values. It then displays ""MYNAME Begin"", calls a CICS program PGM-0001 with specified COMMAREA and length, and displays ""MYNAME End"" before terminating the program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes what the source code does.,0.008377152169377823,0.8556607365608215
cob_syn_8370,COBOL,"      * REFACTOR CANDIDATE BATCH_8370
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. MULTSTMT.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 77 SOMEID1 PIC 9(10).
 77 SOMEID2 PIC 9(10).
 77 SOMEID3 PIC 9(10).
 77 SOMEID4 PIC 9(10).
 PROCEDURE DIVISION.
    MULTIPLY SOMEID1 BY
       SOMEID2 GIVING SOMEID3 SOMEID4 ROUNDED
       ON SIZE ERROR DISPLAY 'on size error'
       NOT ON SIZE ERROR DISPLAY 'not on size error'.","This COBOL code defines four numeric variables (SOMEID1, SOMEID2, SOMEID3, and SOMEID4) each with a length of 10 digits. It then multiplies the value of SOMEID1 by the value of SOMEID2 and stores the result in SOMEID3. If the multiplication causes a size error, it displays 'on size error'; otherwise, it displays 'not on size error'.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention what the code does with SOMEID4 after the multiplication operation.,0.005514743143838301,0.8470832705497742
cob_syn_7554,COBOL,"      * REFACTOR CANDIDATE BATCH_7554
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.                                         12345678
000100 PROGRAM-ID. INLINE-COMMENT.                                      12345678
000100   PROCEDURE DIVISION.                                            12345678
000100       *>DISPLAY SOME-TEXT.                                       12345678
000100       DISPLAY SOME-TEXT-2.                                       12345678","This COBOL code is an example demonstrating the use of inline comments within a program. The program includes a comment stating ""REFACTOR CANDIDATE BATCH_7554"" and a system-generated comment with line numbers. The PROCEDURE DIVISION contains a comment using the ""*>"" syntax followed by a DISPLAY statement.",Legacy COBOL logic requiring documentation.,No Error,False,"The documentation accurately represents the source code, with no hallucinations or omissions.",0.0065056119086392495,0.8572624921798706
py_10076,Python,"def send(self, message):
        """"""Verifies and sends message.

        :param message: Message instance.
        :param envelope_from: Email address to be used in MAIL FROM command.
        """"""
        assert message.send_to, ""No recipients have been added""

        if message.has_bad_headers(self.mail.default_sender):
            raise BadHeaderError

        if message.date is None:
            message.date = time.time()

        sender = message.sender or self.mail.default_sender
        if self.host:
            self.host.sendmail(sanitize_address(sender) if sender is not None else None,
                               message.send_to,
                               message.as_string(self.mail.default_sender),
                               message.mail_options,
                               message.rcpt_options)

        email_dispatched.send(message, mail=self.mail)

        self.num_emails += 1

        if self.num_emails == self.mail.max_emails:
            self.num_emails = 0
            if self.host:
                self.host.quit()
                self.host = self.configure_host()","Verifies and sends a message using an email host. The function takes a message instance as a parameter and checks if there are any recipients added to the message. If the message has bad headers associated with the default sender, a BadHeaderError is raised. If the message has no date, the current timestamp is added as the date. The sender is set to the message sender or the default sender. If there is a host configured, the message is sent using the host's sendmail method with sanitized sender address and other message attributes. An email_dispatched event is triggered, updating the number of emails sent. If the maximum number of emails is reached, the email count is reset, and if a host is available, the connection is closed and reconfigured.","Verifies and sends message.

        :param message: Message instance.
        :param envelope_from: Email address to be used in MAIL FROM command.",Omission,True,The documentation skips over the parameter 'envelope_from' from the source code.,0.012188680730324518,0.8048702478408813
py_7846,Python,"def cmd_tool(args=None):
    """""" Command line tool for plotting and viewing info on guppi raw files """"""

    from argparse import ArgumentParser

    parser = ArgumentParser(description=""Command line utility for creating spectra from GuppiRaw files."")

    parser.add_argument('filename', type=str, help='Name of file to read')
    parser.add_argument('-o', dest='outdir', type=str, default='./', help='output directory for PNG files')
    args = parser.parse_args()

    r = GuppiRaw(args.filename)

    r.print_stats()
    bname = os.path.splitext(os.path.basename(args.filename))[0]
    bname = os.path.join(args.outdir, bname)
    r.plot_histogram(filename=""%s_hist.png"" % bname)
    r.plot_spectrum(filename=""%s_spec.png"" % bname)",Command line tool for plotting and viewing info on guppi raw files.,Command line tool for plotting and viewing info on guppi raw files,No Error,False,The generated documentation accurately represents what the source code does.,0.9036020036098448,0.9957608580589294
py_1898,Python,"def parse_json(data, name=""JSON"", exception=PluginError, schema=None):
    """"""Wrapper around json.loads.

    Wraps errors in custom exception with a snippet of the data in the message.
    """"""
    try:
        json_data = json.loads(data)
    except ValueError as err:
        snippet = repr(data)
        if len(snippet) > 35:
            snippet = snippet[:35] + "" ...""
        else:
            snippet = data

        raise exception(""Unable to parse {0}: {1} ({2})"".format(name, err, snippet))

    if schema:
        json_data = schema.validate(json_data, name=name, exception=exception)

    return json_data","Wrapper around json.loads.

Wraps errors in custom exception with a snippet of the data in the message.","Wrapper around json.loads.

    Wraps errors in custom exception with a snippet of the data in the message.",Omission,True,"The documentation does not explain the purpose and usage of the `name`, `exception`, and `schema` parameters in the `parse_json` function.",1.0,0.9705475568771362
py_7892,Python,"def mr_reader(job, input_stream, loads=core.loads):
    """""" Converts a file object with json serialised pyschema records
        to a stream of pyschema objects

    Can be used as job.reader in luigi.hadoop.JobTask
    """"""
    for line in input_stream:
        yield loads(line),",Converts a file object with json serialised pyschema records to a stream of pyschema objects. Can be used as job.reader in luigi.hadoop.JobTask.,"Converts a file object with json serialised pyschema records
        to a stream of pyschema objects

    Can be used as job.reader in luigi.hadoop.JobTask",No Error,False,"The generated documentation accurately describes the function's purpose, usage, and logic, without making unsupported claims or missing crucial information.",0.8232490471721702,0.9466068744659424
cob_syn_9888,COBOL,"      * REFACTOR CANDIDATE BATCH_9888
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. RETSTMT.
 PROCEDURE DIVISION.
    RETURN SOMEFILE1 RECORD
       INTO SOMEDATA1
       AT END DISPLAY 'at end'
       NOT AT END DISPLAY 'not at end'.","This COBOL program reads a record from the file ""SOMEFILE1"" into the variable ""SOMEDATA1"". It then checks if the end of the file has been reached and displays a message accordingly.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the functionality of the code.,0.009048295247234425,0.8621786832809448
cob_real_3673,COBOL,"      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      ******************************************************************
           03 CA-REQUEST-ID            PIC X(6).
           03 CA-RETURN-CODE           PIC 9(2).
           03 CA-CUSTOMER-NUM          PIC 9(10).
           03 CA-POLICY-NUM            PIC 9(10).
      *       Common policy details
           03 CA-ISSUE-DATE            PIC X(10).
           03 CA-EXPIRY-DATE           PIC X(10).
           03 CA-LASTCHANGED           PIC X(26).
           03 CA-BROKERID              PIC 9(10).
           03 CA-BROKERSREF            PIC X(10).
           03 CA-PAYMENT               PIC 9(6).
      *       House policy description
           03 CA-H-PROPERTY-TYPE       PIC X(15).
           03 CA-H-BEDROOMS            PIC 9(3).
           03 CA-H-VALUE               PIC 9(8).
           03 CA-H-HOUSE-NAME          PIC X(20).
           03 CA-H-HOUSE-NUMBER        PIC X(4).
           03 CA-H-POSTCODE            PIC X(8).
           03 CA-H-FILLER            ","This COBOL code defines a data structure with fields representing various details related to a customer's insurance policy. The structure includes fields for request ID, return code, customer number, policy number, issue date, expiry date, last changed date, broker ID, broker's reference, payment amount, property type, number of bedrooms, property value, house name, house number, postcode, and filler. The structure is likely used in a COBOL program to handle and process insurance policy information.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the functionality and variables represented in the source code.,0.004358632673529301,0.8399108648300171
py_2580,Python,"def publish(self, event, *args, **kwargs):
        """""" Triggers an event, and associates some data to it, so if there are any
        subscribers, their callback will be called synchronously. """"""
        return self._broker.dispatch(event, *args, **kwargs)","Triggers a specified event and associates data with it, allowing synchronous execution of callbacks for any subscribers to that event.","Triggers an event, and associates some data to it, so if there are any
        subscribers, their callback will be called synchronously.",No Error,False,The documentation accurately describes what the function does without adding any unsupported claim or omitting any critical information.,0.0385635965193614,0.8959396481513977
py_2806,Python,"def latex(self, aliases=None):
        """"""Return LaTeX string representation of circuit.

        This method uses the LaTeX Qconfig package to create a graphical
        representation of the circuit.

        Returns:
            string: for writing to a LaTeX file.
        """"""
        self._initialize_latex_array(aliases)
        self._build_latex_array(aliases)
        header_1 = r""""""% \documentclass[preview]{standalone}
% If the image is too large to fit on this documentclass use
\documentclass[draft]{beamer}
""""""
        beamer_line = ""\\usepackage[size=custom,height=%d,width=%d,scale=%.1f]{beamerposter}\n""
        header_2 = r""""""% instead and customize the height and width (in cm) to fit.
% Large images may run out of memory quickly.
% To fix this use the LuaLaTeX compiler, which dynamically
% allocates memory.
\usepackage[braket, qm]{qcircuit}
\usepackage{amsmath}
\pdfmapfile{+sansmathaccent.map}
% \usepackage[landscape]{geometry}
% Comment out the above line if using the beamer documentclass.
\begin{document}
\begin{equation*}""""""
        qcircuit_line = r""""""
    \Qcircuit @C=%.1fem @R=%.1fem @!R {
""""""
        output = io.StringIO()
        output.write(header_1)
        output.write('%% img_width = %d, img_depth = %d\n' % (self.img_width, self.img_depth))
        output.write(beamer_line % self._get_beamer_page())
        output.write(header_2)
        output.write(qcircuit_line %
                     (self.column_separation, self.row_separation))
        for i in range(self.img_width):
            output.write(""\t \t"")
            for j in range(self.img_depth + 1):
                cell_str = self._latex[i][j]
                # Don't truncate offset float if drawing a barrier
                if 'barrier' in cell_str:
                    output.write(cell_str)
                else:
                    # floats can cause ""Dimension too large"" latex error in
                    # xymatrix this truncates floats to avoid issue.
                    cell_str = re.sub(r'[-+]?\d*\.\d{2,}|\d{2,}',
                                      _truncate_float,
                                      cell_str)
                    output.write(cell_str)
                if j != self.img_depth:
                    output.write("" & "")
                else:
                    output.write(r'\\' + '\n')
        output.write('\t }\n')
        output.write('\\end{equation*}\n\n')
        output.write('\\end{document}')
        contents = output.getvalue()
        output.close()
        return contents","""""""Return LaTeX string representation of circuit.
        
        This method uses the LaTeX Qconfig package to create a graphical
        representation of the circuit.
        
        Returns:
            string: for writing to a LaTeX file.
        """"""","Return LaTeX string representation of circuit.

        This method uses the LaTeX Qconfig package to create a graphical
        representation of the circuit.

        Returns:
            string: for writing to a LaTeX file.",No Error,False,The provided documentation correctly describes what the code does without any hallucinations or omissions.,0.9297121915433835,0.9733157753944397
cob_syn_5101,COBOL,"      * REFACTOR CANDIDATE BATCH_5101
      * SYSTEM GENERATED
000010 @OPTIONS MAIN,TEST
000020 Identification Division.
000030 Program-Id.  Chapt15d.
000031* Dynamic Access Example
000041 Environment Division.
000050 Configuration Section.
000051 Special-Names.
000052       Crt Status Is Keyboard-Status
000053       Cursor Is Cursor-Position.
000055 Source-Computer.  IBM-PC.
000056 Object-Computer.  IBM-PC.
000057 Input-Output Section.
000058 File-Control.
000059     Select Dealer-File Assign To ""Dealer.Dat""
000060            Organization Indexed
000061            Access Dynamic
000062            Record Key Dealer-Number
000063            Alternate Record Key Dealer-Name
000064            File Status Dealer-Status.
000065 Data Division.
000066 File Section.
000067 Fd  Dealer-File.
000068 01  Dealer-Record.
000069     03  Dealer-Number         Pic X(8).
000070     03  Dealer-Name.
000071         05  Last-Name   Pic X(25).
000072         05  First-Name  Pic X(15).
000073         05  Middle-Name Pic X(10).
000083     03  Address-Line-1      Pic X(50).
000085     03  Address-Line-2      Pic X(50).
000086     03  City                Pic X(40).
000087     03  State-Or-Country    Pic X(20).
000088     03  Postal-Code         Pic X(15).
000089     03  Home-Phone          Pic X(20).
000090     03  Work-Phone          Pic X(20).
000091     03  Other-Phone         Pic X(20).
000092     03  Start-Date          Pic 9(8).
000093     03  Last-Rent-Paid-Date Pic 9(8).
000094     03  Next-Rent-Due-Date  Pic 9(8).
000095     03  Rent-Amount         Pic 9(4)v99.
000096     03  Consignment-Percent Pic 9(3).
000097     03  Filler              Pic X(50).
000098 Working-Storage Section.
000116 01  Dealer-Status     Pic X(2) Value Spaces.
000240     88  Dealer-Success Value ""00"" Thru ""09"".
000279 01  Keyboard-Status.
000280     03  Accept-Status Pic 9.
000281     03  Function-Key  Pic X.
000282         88  F1-Pressed Value X""01"".
000283         88  F2-Pressed Value X""02"".
000284         88  F3-Pressed Value X""03"".
000285         88  F4-Pressed Value ","This code defines a COBOL program named Chapt15d that demonstrates dynamic access to a file named ""Dealer.Dat"". The program defines the structure of the Dealer file records with various fields such as Dealer-Number, Dealer-Name, Address, Phone numbers, Dates, and Amounts. It also includes definitions for handling file status and keyboard input status. The program is set up for indexed access to the Dealer file with dynamic record access using keys such as Dealer-Number and Dealer-Name.",Legacy COBOL logic requiring documentation.,No Error,False,"The code and the generated documentation are consistent with each other, with the documentation accurately describing the functionality and structure of the source code.",0.004309369973332364,0.845811665058136
cob_real_1006,COBOL,"      ******************************************************************
      * author: Erik Eriksen
      * date: 2022-04-13
      * purpose: A simple paint program to demo the mouse functionality.
      * tectonics: cobc
      ******************************************************************
       identification division.
       program-id. mouse-example.

       environment division.

       configuration section.

       special-names.
           cursor is ws-cursor-position
           crt status is ws-crt-status.

       data division.
       file section.

       working-storage section.

       copy screenio.

       01  ws-cursor-position.
           05  ws-cursor-line                  pic 99.
           05  ws-cursor-col                   pic 99.

       01  ws-kb-input                         pic x.

       01  ws-crt-status.
           05  ws-crt-key-1                    pic xx.
           05  ws-crt-key-2                    pic xx.

       01  ws-mouse-flags                      pic 9(4).

       01  ws-mouse-clicked-sw                 pic a value 'N'.
           88  ws-mouse-clicked                value 'Y'.
           88  ws-mouse-not-clicked            value 'N'.

       01  ws-exit-sw                          pic a value 'N'.
           88  ws-exit                         value 'Y'.
           88  ws-not-exit                     value 'N'.

       01  ws-draw-color                       pic 9.

       procedure division.
           set environment ""COB_SCREEN_EXCEPTIONS"" to 'Y'.
           set environment ""COB_SCREEN_ESC"" to 'Y'.
           set environment ""COB_EXIT_WAIT"" to 'N'.
           set environment ""COB_TIMEOUT_SCALE"" to '3'.

           compute ws-mouse-flags = COB-AUTO-MOUSE-HANDLING
               + COB-ALLOW-LEFT-DOWN
               + COB-ALLOW-LEFT-UP
               + COB-ALLOW-MOUSE-MOVE
           end-compute.

           set environment ""COB_MOUSE_FLAGS"" to ws-mouse-flags.

       main-procedure.

           move 1 to ws-draw-color","This COBOL program sets up a simple paint program to demonstrate mouse functionality. It initializes variables to handle mouse input and screen output, sets up the environment for mouse handling, and defines the main procedure for drawing on the screen with a specified color.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation fails to describe the entire logic and functionalities of the source code, such as how the mouse inputs influence the drawing color, operations like the environment setup details, and handling screen exceptions.",0.0067525623389387635,0.8665119409561157
cob_syn_7857,COBOL,"      * REFACTOR CANDIDATE BATCH_7857
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. AOC-2021-16-1.
       AUTHOR. ANNA KOSIERADZKA.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT INPUTFILE ASSIGN TO ""d16.input""
           ORGANIZATION IS LINE SEQUENTIAL.

       DATA DIVISION.

       FILE SECTION.
         FD INPUTFILE
           RECORD IS VARYING IN SIZE FROM 1 to 1318
           DEPENDING ON REC-LEN.
         01 INPUTRECORD PIC X(1318).

       WORKING-STORAGE SECTION.
         01 FILE-STATUS PIC 9 VALUE 0.
         01 REC-LEN PIC 9(4) COMP.
         01 N PIC 9(4) VALUE 1.
         01 WS-BITS PIC 9 VALUE 0 OCCURS 5272 TIMES.
         01 VAL-DEC PIC 99 VALUE 0.
         01 VAL-BIN PIC X(16) VALUE SPACE.
         77 D PIC 9.
         77 I PIC 9(4) VALUE 1.
         77 J PIC 9(4) VALUE 1.
         77 K PIC S9(4) VALUE 1.
         77 LEN PIC 9(4) VALUE 4.
         77 T PIC 9.
         77 X PIC X.
         77 Y PIC 9(4) VALUE 1.
         77 RESULT PIC 9(6) VALUE 0.

       PROCEDURE DIVISION.
       001-MAIN.
           OPEN INPUT INPUTFILE.
           PERFORM 002-READ.
           CLOSE INPUTFILE.           
           DISPLAY RESULT.
           STOP RUN.

       002-READ.
           READ INPUTFILE
             AT END MOVE 1 TO FILE-STATUS
             NOT AT END PERFORM 003-PROCESS-RECORD
           END-READ.

       003-PROCESS-RECORD.
           MOVE REC-LEN TO N.
           PERFORM VARYING J FROM 1 BY 1 UNTIL J > N
             MOVE INPUTRECORD(J:1) TO X 
            
      * A-F = 66-71
      * 0-9 = 49-58
             COMPUTE Y = FUNCTION ORD(X)
             IF Y > 65 THEN 
               SUBTRACT 56 FROM Y
             ELSE
               SUBTRACT 49 FROM Y 
             END-IF
            
             MOVE Y TO VAL-DEC
             PERFORM DEC-TO-BIN
             PERFORM VARYING K FROM 1 BY 1 UNTIL K > 4
               MOVE VAL-BIN(K:1) TO WS-BITS(4 * J - 4 + K)
             END-PERFORM  
           END-PERFORM.

           MOVE 1 TO J.
    ","This COBOL program reads a file ""d16.input"" containing records of variable length up to 1318 characters. For each record, it processes character data converting decimal characters ('0' to '9') to binary, and alphabetic characters ('A' to 'F') to their equivalent in decimal. The converted binary data is stored in an array. The final result is displayed after processing all records.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation claims the program converts alphabetic characters ('A' to 'F') to their equivalent in decimal, however, the code doesn't support this operation and there's no clear mapping of such conversions in code.",0.005203424609196104,0.8492363095283508
py_2267,Python,"def __last_beat(cumscore):
    """"""Get the last beat from the cumulative score array""""""

    maxes = util.localmax(cumscore)
    med_score = np.median(cumscore[np.argwhere(maxes)])

    # The last of these is the last beat (since score generally increases)
    return np.argwhere((cumscore * maxes * 2 > med_score)).max()",Get the last beat from the cumulative score array.,Get the last beat from the cumulative score array,No Error,False,The documentation accurately represents the source code's functionality.,0.8633400213704505,0.9807229042053223
cob_syn_6041,COBOL,"      * REFACTOR CANDIDATE BATCH_6041
      * SYSTEM GENERATED
       9000-mestre-nota-fiscal section.
        
            initialize                             f05000-mestre-nota-fiscal
            move wf05000-cd-empresa                to f05000-cd-empresa
            move wf05000-cd-filial                 to f05000-cd-filial
            move wf05000-tipo-nota                 to f05000-tipo-nota
            move wf05000-numero-documento          to f05000-numero-documento
            move wf05000-serie-documento           to f05000-serie-documento
            move wf05000-cd-destinatario           to f05000-cd-destinatario
            move wf05000-sequencia                 to f05000-sequencia
            move wf05000-data-operacao             to f05000-data-operacao
            move wf05000-horario-operacao          to f05000-horario-operacao
            move wf05000-id-usuario-operacao       to f05000-id-usuario-operacao
            move wf05000-data-saida                to f05000-data-saida
            move wf05000-horario-saida             to f05000-horario-saida
            move wf05000-data-entrega              to f05000-data-entrega
            move wf05000-horario-entrega           to f05000-horario-entrega
            move wf05000-base-icms                 to f05000-base-icms
            move wf05000-valor-icms                to f05000-valor-icms
            move wf05000-base-icms-st              to f05000-base-icms-st
            move wf05000-valor-icms-st             to f05000-valor-icms-st
            move wf05000-valor-importacao          to f05000-valor-importacao
            move wf05000-valor-pis                 to f05000-valor-pis
            move wf05000-valor-total-produtos      to f05000-valor-total-produtos
            move wf05000-valor-frete               to f05000-valor-frete
            move wf05000-valor-seguro              to f05000-valor-seguro
            move wf05000-valor-desconto            to f05000-valor-desconto
            move wf05000-valor-outras-despesas     to f05000-valor-outras-despe","This code section initializes a record in the F05000-MESTRE-NOTA-FISCAL file by moving values from corresponding fields in the WF05000 record. It copies various data fields such as company code, document type, dates, operation details, tax amounts, and financial details from the input WF05000 record to the output F05000-MESTRE-NOTA-FISCAL record for further processing.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the code's functionality.,0.0,0.8217725157737732
cob_real_2537,COBOL,"      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    ADD Customer                                *
      *   To add customer's password to the secutity table with        *
      *  details. Default password is BD5 checksum                     *
      *                                                                *   
      *                                                                * 
      *                                                                *      
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGACDB02.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *----------------------------------------------------------------*
      * Common defintions                                              *
      *-----------------------------------------------","This COBOL program, identified as LGACDB02, is designed to add a customer's password to the security table along with details. The default password used is the BD5 checksum. The program appears to contain common definitions in the WORKING-STORAGE SECTION.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the source code provided.,0.007469938459592591,0.8618391752243042
cob_syn_6212,COBOL,"      * REFACTOR CANDIDATE BATCH_6212
      * SYSTEM GENERATED
      *-----------------------
       IDENTIFICATION DIVISION.
      *-----------------------
       PROGRAM-ID.    SRCHSER.
       AUTHOR.        Otto B. Boolean.
      *--------------------
       ENVIRONMENT DIVISION.
      *--------------------
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT ACCT-REC   ASSIGN TO ACCTREC.
      *-------------
       DATA DIVISION.
      *-------------
       FILE SECTION.
       FD  ACCT-REC RECORDING MODE F.
       01  ACCT-FIELDS        PIC X(170).
      *
       WORKING-STORAGE SECTION.
       01  FLAGS.
           05  LASTREC            PIC X VALUE SPACE.
               88  END-OF-FILE          VALUE 'Y'.
           05  TABLE-VAR          PIC S9(4) COMP.
           05  TABLE-MAX          PIC S9(4) COMP VALUE 45.
      *
       01  ACCT-TABLE.
           05  ACCT-TABLE-ITEM OCCURS 45 TIMES INDEXED BY TABLE-IDX.
               10  ACCT-NO            PIC X(8).
               10  ACCT-LIMIT         PIC S9(7)V99 COMP-3.
               10  ACCT-BALANCE       PIC S9(7)V99 COMP-3.
               10  LAST-NAME          PIC X(20).
               10  FIRST-NAME         PIC X(15).
               10  CLIENT-ADDR.
                   15  STREET-ADDR    PIC X(25).
                   15  CITY-COUNTY    PIC X(20).
                   15  USA-STATE      PIC X(15).
               10  RESERVED           PIC X(7).
               10  COMMENTS           PIC X(50).
      *
      *------------------
       PROCEDURE DIVISION.
      *------------------
       OPEN-FILES.
           OPEN INPUT ACCT-REC.
      *
       LOAD-TABLES.
           PERFORM READ-RECORD.
           PERFORM VARYING TABLE-VAR FROM 1 BY 1
             UNTIL TABLE-VAR = TABLE-MAX OR END-OF-FILE
               MOVE ACCT-FIELDS TO ACCT-TABLE-ITEM (TABLE-VAR)
               PERFORM READ-RECORD
           END-PERFORM.
      *
       SEARCH-RECORD.
           SET TABLE-IDX TO 1.
           SEARCH ACCT-TABLE-ITEM VARYING TABLE-IDX
               AT END DISPLAY ""Not Foun","This COBOL program defines a batch processing system that reads account records from a file, loads the data into an array-like structure called ACCT-TABLE, and searches for a specific record within the table. The program reads account data from the file ACCTREC and populates fields in the ACCT-TABLE structure. The SEARCH-RECORD procedure is used to find a specific record in the table based on the account number.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention anything about how the search for a specific record is done or what account number it is searching for.,0.004740784076857388,0.8531403541564941
py_4120,Python,"def text_to_bytes_and_warn(label, obj):
    """"""
    If ``obj`` is text, emit a warning that it should be bytes instead and try
    to convert it to bytes automatically.

    :param str label: The name of the parameter from which ``obj`` was taken
        (so a developer can easily find the source of the problem and correct
        it).

    :return: If ``obj`` is the text string type, a ``bytes`` object giving the
        UTF-8 encoding of that text is returned.  Otherwise, ``obj`` itself is
        returned.
    """"""
    if isinstance(obj, text_type):
        warnings.warn(
            _TEXT_WARNING.format(label),
            category=DeprecationWarning,
            stacklevel=3
        )
        return obj.encode('utf-8')
    return obj","If ``obj`` is text, emit a warning that it should be bytes instead and try to convert it to bytes automatically.

- **Parameters:**
    - ``label`` (str): The name of the parameter from which ``obj`` was taken (so a developer can easily find the source of the problem and correct it).
    - ``obj``: The object that might need to be converted to bytes.

- **Returns:**
    - If ``obj`` is a text string type, a ``bytes`` object giving the UTF-8 encoding of that text is returned. Otherwise, ``obj`` itself is returned.","If ``obj`` is text, emit a warning that it should be bytes instead and try
    to convert it to bytes automatically.

    :param str label: The name of the parameter from which ``obj`` was taken
        (so a developer can easily find the source of the problem and correct
        it).

    :return: If ``obj`` is the text string type, a ``bytes`` object giving the
        UTF-8 encoding of that text is returned.  Otherwise, ``obj`` itself is
        returned.",No Error,False,The documentation accurately reflects what the source code does.,0.7067803152793757,0.9294021129608154
py_4207,Python,"def snap_mismatched_borders(script, edge_dist_ratio=0.01, unify_vert=True):
    """""" Try to snap together adjacent borders that are slightly mismatched.

    This situation can happen on badly triangulated adjacent patches defined by
    high order surfaces. For each border vertex the filter snaps it onto the
    closest boundary edge only if it is closest of edge_legth*threshold. When
    vertex is snapped the corresponding face it split and a new vertex is
    created.

    Args:
        script: the FilterScript object or script filename to write
            the filter to.
        edge_dist_ratio (float): Collapse edge when the edge / distance ratio
            is greater than this value. E.g. for default value 1000 two
            straight border edges are collapsed if the central vertex dist from
            the straight line composed by the two edges less than a 1/1000 of
            the sum of the edges length. Larger values enforce that only
            vertexes very close to the line are removed.
        unify_vert (bool): If true the snap vertices are welded together.

    Layer stack:
        No impacts

    MeshLab versions:
        2016.12
        1.3.4BETA
    """"""
    filter_xml = ''.join([
        '  <filter name=""Snap Mismatched Borders"">\n',
        '    <Param name=""EdgeDistRatio"" ',
        'value=""{}"" '.format(edge_dist_ratio),
        'description=""Edge Distance Ratio"" ',
        'type=""RichFloat"" ',
        '/>\n',
        '    <Param name=""UnifyVertices"" ',
        'value=""{}"" '.format(str(unify_vert).lower()),
        'description=""UnifyVertices"" ',
        'type=""RichBool"" ',
        '/>\n',
        '  </filter>\n'])
    util.write_filter(script, filter_xml)
    return None",Try to snap together adjacent borders that are slightly mismatched.,"Try to snap together adjacent borders that are slightly mismatched.

    This situation can happen on badly triangulated adjacent patches defined by
    high order surfaces. For each border vertex the filter snaps it onto the
    closest boundary edge only if it is closest of edge_legth*threshold. When
    vertex is snapped the corresponding face it split and a new vertex is
    created.

    Args:
        script: the FilterScript object or script filename to write
            the filter to.
        edge_dist_ratio (float): Collapse edge when the edge / distance ratio
            is greater than this value. E.g. for default value 1000 two
            straight border edges are collapsed if the central vertex dist from
            the straight line composed by the two edges less than a 1/1000 of
            the sum of the edges length. Larger values enforce that only
            vertexes very close to the line are removed.
        unify_vert (bool): If true the snap vertices are welded together.

    Layer stack:
        No impacts

    MeshLab versions:
        2016.12
        1.3.4BETA",No Error,False,The generated documentation accurately reflects the function code without any hallucinations or omissions.,5.573903692694596e-07,0.7961888313293457
cob_syn_2736,COBOL,"      * REFACTOR CANDIDATE BATCH_2736
      * SYSTEM GENERATED
      *****************************************************************
      *                                                               *
      * Copyright (C) 2020-2022 Micro Focus.  All Rights Reserved.    *
      * This software may be used, modified, and distributed          *
      * (provided this notice is included without modification)       *
      * solely for demonstration purposes with other                  *
      * Micro Focus software, and is otherwise subject to the EULA at *
      * https://www.microfocus.com/en-us/legal/software-licensing.    *
      *                                                               *
      * THIS SOFTWARE IS PROVIDED ""AS IS"" AND ALL IMPLIED           *
      * WARRANTIES, INCLUDING THE IMPLIED WARRANTIES OF               *
      * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,         *
      * SHALL NOT APPLY.                                              *
      * TO THE EXTENT PERMITTED BY LAW, IN NO EVENT WILL              *
      * MICRO FOCUS HAVE ANY LIABILITY WHATSOEVER IN CONNECTION       *
      * WITH THIS SOFTWARE.                                           *
      *                                                               *
      *****************************************************************
      
       copy ""mfunit_prototypes.cpy"".
       copy ""cblproto.cpy"". 
       program-id. TestCustomerStorage.

       working-storage section.
       copy ""PROCEDURE-NAMES.cpy"".
       copy ""FUNCTION-CODES.cpy"".
       copy ""HELPER-FUNCTIONS.cpy"". 
       78 TEST-WriteCustomer       value ""TestWriteCustomer"".
       78 TEST-ReadLastCustomer    value ""TestReadLastCustomer"". 
       78 TEST-ReadRecords         value ""TestReadRecords"". 
       78 TEST-UpdateCustomer      value ""TestUpdateCustomer"". 
       78 TEST-FindCustomerName    value ""TestFindCustomerName"".
       
       78 TEST-ID-1                value 100. 
       78 TEST-FIRST-NAME-1        value ""Fred"".
       78 TEST-LAST-NAME-1      ","This COBOL code defines constant values and copybooks for testing customer storage operations, such as writing, reading, updating, and finding customer records. The code includes declarations for specific test scenarios and data related to customer information.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention the copybooks ""mfunit_prototypes.cpy"", ""cblproto.cpy"", ""PROCEDURE-NAMES.cpy"", ""FUNCTION-CODES.cpy"", ""HELPER-FUNCTIONS.cpy"" and the value for TEST-LAST-NAME-1 is missing, which are included in the source code.",0.007986728673290205,0.8766090273857117
cob_real_656,COBOL,"      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    Inquire Customer                            *
      *                                                                *
      *   To obtain Customer's details from database.                  *
      *                                                                *
      * Customer Inquire Business logic                                *
      *                                                                *
      *  07                                                            *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGICUS01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *---------------------------------------------------------","This COBOL program is titled ""Inquire Customer"" and is designed to retrieve customer details from a database using specific business logic. The program is identified by LGICUS01 and sets up its working storage section to facilitate the customer inquiry process.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the source code.,0.007313425995364251,0.8728287220001221
cob_real_3097,COBOL,"000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID.    TPROG06.
000300 AUTHOR.        COMPUWARE ISPW TRAINING.
000400 DATE-WRITTEN.  JANUARY 24TH, 1996.
000500 DATE-COMPILED.
000600
000700********************************************************
      * Adding a non-displayable character in the next line for
      * testing purposes (it's a x'00')
      *
000800* THIS PROGRAM IS A TRAINING PROGRAM
000900*      WITH A LINK TO TSUBR06
001000*
001100*      AND COPYLIBS   TCPYA06   (HEADER)
001200*                     TCPYB06   (LINK AREA)
001300* ======================================================
001400*  ISPW (TM)
001500*  COPYRIGHT (C) 1986-2016 COMPUWARE CORPORATION.
001600*  UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT
001700*  LAWS OF THE UNITED STATES.
001800*
001900* ======================================================
002000*                   MODIFICATION  LOG
002100*
002200*  DD/MM/YY  PROGRAMMER  CHANGES
002300*  ********  **********  *******
002400*  96/01/24  ISPW        NEW PROGRAM
002500* ======================================================
002600 ENVIRONMENT DIVISION.
002700 CONFIGURATION SECTION.
002800 SOURCE-COMPUTER. IBM-370.
002900 OBJECT-COMPUTER. IBM-370.
003000
003100 INPUT-OUTPUT SECTION.
003200 FILE-CONTROL.
003300
003400*****************************************************
003500*  FILES USED:
003600*   INPUT   JUST SOME DUMMY DATA TO READ IN
003700*   OUTPUT  A COPY OF THE DUMMY DATA WRITTEN OUT
003800*****************************************************
003900     SELECT INFILE  ASSIGN UT-S-INPUT
004000       ORGANIZATION IS SEQUENTIAL
004100       ACCESS IS SEQUENTIAL.
004200
004300     SELECT OUTFILE ASSIGN UT-S-OUTPUT
004400       ORGANIZATION IS SEQUENTIAL
004500       ACCESS IS SEQUENTIAL.
004600
004700 DATA DIVISION.
004800
004900 FILE SECTION.
005000
005100 FD  INFILE
005200     LABEL RECORDS OMITTED
005300     BLOCK CONTAINS 0 RECORDS
005400     RECORDING MODE IS F
0","This COBOL program is a training program with a link to another program (TSUBR06) and uses copylibs TCPYA06 (HEADER) and TCPYB06 (LINK AREA). The program defines two files, INFILE for reading dummy data and OUTFILE for writing a copy of the dummy data.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the code's functionality and doesn't leave out any critical information.,0.006883858510498897,0.854332447052002
py_5410,Python,"def write(self, destination, do_compress=None):
        """""" Writes to a stream or file

        When destination is a string, it will be interpreted as the path were the file should be written to,
        also if do_compress is None, the compression will be guessed from the file extension:

        - .laz -> compressed
        - .las -> uncompressed

        .. note::

            This means that you could do something like:
                # Create .laz but not compressed

                las.write('out.laz', do_compress=False)

                # Create .las but compressed

                las.write('out.las', do_compress=True)

            While it should not confuse Las/Laz readers, it will confuse humans so avoid doing it


        Parameters
        ----------
        destination: str or file object
            filename or stream to write to
        do_compress: bool, optional
            Flags to indicate if you want to compress the data
        """"""
        if isinstance(destination, str):
            self.write_to_file(destination)
        else:
            if do_compress is None:
                do_compress = False
            self.write_to(destination, do_compress=do_compress)","""""""Writes data to a specified destination, which can be a file path or a stream. 
If the destination is a string representing a file path:
- The file will be written to that path.
- If `do_compress` is None, the compression type will be inferred from the file extension:
  - Files with .laz extension will be compressed.
  - Files with .las extension will be uncompressed.

Note that you can specify compression explicitly by passing `do_compress=True` for compressed or `do_compress=False` for uncompressed file. 
Avoid mixing compression types in filename extensions, as it may confuse humans.

Parameters:
- destination: str or file object
    The filename or stream where data will be written.
- do_compress: bool, optional
    Flag indicating whether to compress the data.

This method allows you to write data to files or streams with optional compression.""""""","Writes to a stream or file

        When destination is a string, it will be interpreted as the path were the file should be written to,
        also if do_compress is None, the compression will be guessed from the file extension:

        - .laz -> compressed
        - .las -> uncompressed

        .. note::

            This means that you could do something like:
                # Create .laz but not compressed

                las.write('out.laz', do_compress=False)

                # Create .las but compressed

                las.write('out.las', do_compress=True)

            While it should not confuse Las/Laz readers, it will confuse humans so avoid doing it


        Parameters
        ----------
        destination: str or file object
            filename or stream to write to
        do_compress: bool, optional
            Flags to indicate if you want to compress the data",Omission,True,"The documentation does not explain what happens when destination is not a string, or specifically, how 'do_compress' default value is set to False in this case.",0.1280930285408042,0.8655841946601868
py_8685,Python,"def _create_dummy_trip_stoptimes(trip_id, stops, first_service_time):
    """"""Create station stop times for each trip.""""""
    waiting = datetime.timedelta(seconds=30)
    arrival = first_service_time
    last_departure = first_service_time
    last_departure_hour = (arrival + waiting).hour
    last_stop = None

    departure_hour = None
    arrival_hour = None
    for stop_sequence, stop in enumerate(stops):

        # Avoid time travels
        arrival = last_departure + get_time_from_last_stop(last_stop, stop)
        departure = arrival + waiting

        # Cover the case when the arrival time falls into the next day
        if arrival.hour < last_departure_hour:
            diff = last_departure_hour
            arrival_hour = arrival.hour + diff
            departure_hour = departure.hour + diff
            last_departure_hour = departure.hour + diff
        else:
            arrival_hour = arrival.hour
            departure_hour = departure.hour
            last_departure_hour = departure.hour

        # Cover the case when adding waiting time to the arrival time
        # falls into the next day
        if departure.hour < arrival.hour:
            diff = last_departure_hour
            departure_hour = departure.hour + diff
            last_departure_hour = departure.hour + diff

        yield {'trip_id': trip_id,
               'arrival_time': '{:02}:{}'.format(
                   arrival_hour,
                   arrival.strftime('%M:%S')),
               'departure_time': '{:02}:{}'.format(
                   departure_hour,
                   departure.strftime('%M:%S')),
               'stop_id': stop.stop_id,
               'stop_sequence': stop_sequence}

        last_stop = stop
        last_departure = departure",Create station stop times for each trip.,Create station stop times for each trip.,No Error,False,The documentation accurately represents and explains the function of the code.,1.0,0.9999999403953552
cob_real_2372,COBOL,"000001 Identification Division.                                         00000001
000002 Program-ID. testantlr302.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005 01  CONSTANTS.                                                   00000005
000006     05  MYNAME               PIC X(012) VALUE 'testantlr302'.    00000006
000007                                                                  00000007
000008 Procedure Division.                                              00000008
000009     DISPLAY MYNAME ' Begin'                                      00000009
000010                                                                  00000010
000011     CALL 'PGMA0001'                                              00000011
000012                                                                  00000012
000013     GOBACK                                                       00000013
000014     .                                                            00000014
000015                                                                  00000015
000016                                                                  00000016
","This COBOL program defines a constant named MYNAME with a length of 12 characters and the value 'testantlr302'. The program then displays 'testantlr302 Begin', calls another program named 'PGMA0001', and finally terminates the program.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation perfectly reflects what the source code is doing.,0.008377152169377823,0.8561275005340576
cob_syn_9705,COBOL,"      * REFACTOR CANDIDATE BATCH_9705
      * SYSTEM GENERATED
000001 77  KADY-ORLOFF-DIAZ %comp1le error% PIC S9(016) COMP  VALUE +4. 00000001
",Defines a 16-digit signed numeric variable named KADY-ORLOFF-DIAZ with binary storage and initializes it with the value +4.,Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation incorrectly states that the variable is initialized with the value +4, but the code snippet shows it is initialized with the value +4.00000001.",0.0,0.8349876403808594
cob_syn_994,COBOL,"      * REFACTOR CANDIDATE BATCH_994
      * SYSTEM GENERATED
000001 Identification Division.                                         00000001
000002 Program-ID. testantlr024.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005                                                                  00000005
000006*                                                                 00000006
000007*comment                                                          00000007
000008*                                                                 00000008
000009                                                                  00000009
000010 01  CONSTANTS.                                                   00000010
000011     05  MYNAME               PIC X(012) VALUE 'testantlr024'.    00000011
000012                                                                  00000012
000013*                                                                 00000013
000014                                                                  00000014
000015 01 WORK-AREAS.                                                   00000015
000016    05  A                     PIC A VALUE 'A'.                    00000016
000017    05  X                     PIC X VALUE 'X'.                    00000017
000018    05  V99                   PIC V99.                            00000018
000019    05  B9                    PIC B9.                             00000019
000020    05  Z                     PIC Z.                              00000020
000021    05  S9                    PIC S9.                             00000021
000022                                                                  00000022
000023 Procedure Division.                                              00000023
000024     DISPLAY MYNAME ' Begin'                                      00000024
000025                                                  ",This COBOL program defines some constants and working storage variables. It then displays the value of the MYNAME constant followed by 'Begin'.,Legacy COBOL logic requiring documentation.,No Error,False,"The documentation accurately describes what the code is doing, not making unsupported claims or leaving out important details.",0.012042033681462784,0.8791881799697876
py_13865,Python,"def fix_version(context):
    """"""Fix the version in metadata.txt

    Relevant context dict item for both prerelease and postrelease:
    ``new_version``.

    """"""
    if not prerequisites_ok():
        return
    lines = codecs.open('metadata.txt', 'rU', 'utf-8').readlines()
    for index, line in enumerate(lines):
        if line.startswith('version'):
            new_line = 'version=%s\n' % context['new_version']
            lines[index] = new_line
    time.sleep(1)
    codecs.open('metadata.txt', 'w', 'utf-8').writelines(lines)","Fix the version in metadata.txt

Relevant context dict item for both prerelease and postrelease:
``new_version``.","Fix the version in metadata.txt

    Relevant context dict item for both prerelease and postrelease:
    ``new_version``.",No Error,False,The documentation accurately describes the operation of the code without any unsupported claims or omissions.,1.0,0.9563169479370117
py_6940,Python,"def get_event(self):
        """"""Fetch an event.

        This coroutine will swallow events for removed watches.
        """"""
        while True:
            prefix = yield from self._stream.readexactly(PREFIX.size)
            if prefix == b'':
                # We got closed, return None.
                return
            wd, flags, cookie, length = PREFIX.unpack(prefix)
            path = yield from self._stream.readexactly(length)

            # All async performed, time to look at the event's content.
            if wd not in self.aliases:
                # Event for a removed watch, skip it.
                continue

            decoded_path = struct.unpack('%ds' % length, path)[0].rstrip(b'\x00').decode('utf-8')
            return Event(
                flags=flags,
                cookie=cookie,
                name=decoded_path,
                alias=self.aliases[wd],
            )","Fetch an event.

This coroutine fetches events while handling removed watches gracefully.","Fetch an event.

        This coroutine will swallow events for removed watches.",No Error,False,The generated documentation accurately summarizes the function and its logic without any unsupported claims or omissions.,0.3448444257953326,0.9012427926063538
cob_real_2753,COBOL,"       identification division.
       program-id. cow.

       environment division.

       data division.

       working-storage section.


       01 newline         pic x   value x'0a'.

       01 analyzed-query pic x(1600).  

       01 the-great-dispatch.

          03  routing-table            occurs 10 times.

            05   routing-pattern   pic x(999).
            05   routing-destiny   pic x(999).


       01 tester         pic x(1) value ""n"".  
       01 anyfound       pic x(1) value ""n"".
       01 ctr            pic 99 usage comp-5.

       01 the-values.

          05 query-values           occurs 10 times.
            10 query-value-name     pic x(90).
            10 query-value          pic x(90).



       procedure division.


       copy ""src-cbl/config.cfg"".


       perform web-header.

       call 'getquery' using analyzed-query.


       perform varying ctr from 1 by 1
             until ctr > 5

           call 'checkquery' using analyzed-query routing-pattern(ctr) tester the-values

           if (tester=""y"")

              *> display routing-pattern(ctr) ""<hr>"" 
              move ""y"" to anyfound
              call routing-destiny(ctr) using the-values

           end-if


       end-perform


       if (anyfound=""n"") perform bad-query-error.

       *> if (anyfound=""y"")  call 'showvars' using the-values.  

        

       goback.



 bad-query-error.

 display ""<b>Cobol-on-Wheelchair error:</b> query pattern not found (<i>"" function trim(analyzed-query) ""</i>)"".


 web-header.

       display
           ""content-type: text/html""
           newline
       end-display.














       identification division.
       program-id. getquery.

       environment division.

              input-output section.
       file-control.
           select webinput assign to keyboard.


       data division.
       file section.
       fd webinput.
          01 postchunk       pic x(1024).

       working-storage section.

       78 name-count   ","This COBOL program, comprised of multiple paragraphs, aims to process and analyze query patterns provided as input. It reads the query pattern from a configuration file, checks the query against predefined routing patterns, and performs specific actions accordingly. If a matching pattern is found, it processes the query values and performs the associated actions. If no matching pattern is found, it displays an error message. Additionally, the program generates a web header with a content type of text/html.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation fails to explain the purpose and use of 'tester', 'anyfound', 'ctr', and 'the-values' variables.",0.004168514908224489,0.853761613368988
cob_syn_5866,COBOL,"      * REFACTOR CANDIDATE BATCH_5866
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. FILES.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER.
       OBJECT-COMPUTER.
       FILE-CONTROL.
           SELECT STUDENT ASSIGN TO DISK
           ORGANIZATION IS RELATIVE
           ACCESS MODE IS RANDOM
           RELATIVE KEY IS REL-KEY.
       DATA DIVISION.
       FILE SECTION.
       FD STUDENT
           LABEL RECORDS ARE STANDARD
           VALUE OF FILE-ID ""EMP.DAT""
           DATA RECORD IS STUDENT-REC.
       01 STUDENT-REC.
        02 RNO PIC 9(3).
        02 NAME PIC A(20).
        02 MARKS PIC 9(4).
       WORKING-STORAGE SECTION.
       77 REL-KEY PIC 9(4).
       77 CHOICE PIC X.
       PROCEDURE DIVISION.
       OPEN-PARA.
           OPEN I-O STUDENT.
       ASK-PARA.
           DISPLAY ""ENTER THE ROLL NO TO BE MODIFIED: "".
           ACCEPT REL-KEY.
       DELETE-PARA.
           DELETE STUDENT INVALID KEY DISPLAY ""RECORD NOT FOUND"".
       NEXT-RECORD-PARA.
           DISPLAY ""DO YOU WANT TO DELETE ANOTHER ROLL NO? (Y/N): "".
           ACCEPT CHOICE.
           IF CHOICE = ""Y""
                GO TO ASK-PARA.
       CLOSE-PARA.
           CLOSE STUDENT.
           STOP RUN.
","This COBOL program is designed to handle a batch process for managing student records stored in a file. It opens a file containing student records, prompts the user to enter a roll number to be modified or deleted, performs the corresponding operation, and allows the user to continue deleting more records if desired. Finally, it closes the file before ending the program.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation claims that the program allows record modification, however, the program only supports record deletion.",0.0050615410611162615,0.8647210597991943
cob_syn_5036,COBOL,"      * REFACTOR CANDIDATE BATCH_5036
      * SYSTEM GENERATED
      ******************************************************************
      * Author: Maxfx                                                  *
      * Revision: 28/8/2017 - Malanius                                 *
      * Program demonstration sequential reading database              *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. SEQUENTIAL-READ.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT DATA-FILE ASSIGN TO ""../database.dat""
           ORGANIZATION IS SEQUENTIAL
           ACCESS IS SEQUENTIAL
           FILE STATUS FILE-STATUS.

       DATA DIVISION.
       FILE SECTION.
           FD DATA-FILE.
           01 DETAILS.
             02 DETAILS-ID PIC 9(7).
             02 DETAILS-NAME.
               03 DETAILS-SURNAME PIC X(8).
               03 INITIALS        PIC XX.
             02 DETAILS-BIRTHDAY  PIC X(8).
             02 SOME-CODE         PIC X(5).

       WORKING-STORAGE SECTION.
           77 FILE-STATUS PIC XX.
           77 EOF PIC X.
             88 EOF-T value ""Y"".
             88 EOF-F value ""N"".

       PROCEDURE DIVISION.
       MAIN-PROCEDURE.
           OPEN INPUT DATA-FILE.

           IF FILE-STATUS not = ""00""
             DISPLAY ""Error opening the DB file, program will exit.""
             GOBACK
           END-IF.

           READ DATA-FILE
             AT END
               SET EOF-T TO TRUE
             NOT AT END
               SET EOF-F TO TRUE
               PERFORM DISPLAY-DET-S THROUGH DISPLAY-DET-E
           END-READ

           PERFORM UNTIL EOF-T
             READ DATA-FILE NEXT
               AT END
                 SET EOF-T TO TRUE
               NOT AT END
                 PERFORM DISPLAY-DET-S THROUGH DISPLAY-DET-E
             END-READ
           END-PERFORM

           CLOSE DATA-FILE.
           GOBACK.

           DISPAY-DET SECTION.
           DISPLAY-DET-S.
               DISPLAY DETAIL","This COBOL program reads and displays data from a sequential database file named ""database.dat"". It opens the file, reads each record in a loop, and displays the details of each record until the end of the file is reached. If there is an error opening the file, the program will exit.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation fails to describe the structure of the data within the file, as defined in the DATA DIVISION and does not mention how an error is handled.",0.005965939103175657,0.8592492938041687
cob_syn_3723,COBOL,"      * REFACTOR CANDIDATE BATCH_3723
      * SYSTEM GENERATED
000020 Identification Division.
000030 Program-Id.  Chapt23g.
000031* Validate A Date
000040 Environment Division.
000050 Configuration Section.
000051 Source-Computer.  IBM-PC.
000055 Object-Computer.  IBM-PC.
000056 Data Division.
000057 Working-Storage Section.
000099 01  Work-Number           Pic 9(5) Value Zeros.
000100 01  Work-Remainder        Pic 9(5) Value Zeros.
000101 01  Work-Remainder-100    Pic 9(5) Value Zeros.
000102 01  Work-Remainder-400    Pic 9(5) Value Zeros.
000103 01  Today-Date            Pic 9(8) Value Zeros.
000104 01  Today-Integer         Pic 9(7) Value Zeros.
000105 01  Test-Integer          Pic 9(7) Value Zeros.
000106 01  Test-Range            Pic 9(7) Value Zeros.
000107 01  Day-Table-Area.
000108     03  Day-Table-Values      Pic X(24) Value
000109         ""312831303130313130313031"".
000110     03  Day-Table Redefines Day-Table-Values.
000111         05  Days-In-Month     Pic 99   Occurs 12 Times.
000113 Linkage Section.
000114 01  Passed-Date.
000115     03  Date-To-Validate      Pic 9(8).
000116     03  Date-To-Validate-X Redefines Date-To-Validate.
000117         05  Date-MM           Pic 99.
000118         05  Date-DD           Pic 99.
000119         05  Date-YYYY         Pic 9(4).
000120 01  Valid-Status              Pic X(40).
000121 Procedure Division Using Passed-Date Valid-Status.
000159 Chapt23g-Start.
000199     Divide Date-YYYY Of Date-To-Validate-X By 4
000200            Giving Work-Number Remainder
000201                   Work-Remainder
000202     Divide Date-YYYY Of Date-To-Validate-X By 100
000203            Giving Work-Number Remainder
000204                   Work-Remainder-100
000205     Divide Date-YYYY Of Date-To-Validate-X By 400
000206            Giving Work-Number Remainder
000207                   Work-Remainder-400
000209     If Work-Remainder = Zeros And
000210        (Work-Remainder-100 Not = Zeros Or
000211         Work-Remainder-400 = Zeros)
000212           Move 29 To Days-In-Month (2)
000213     Else
","This COBOL code is a program that validates a given date. It checks if the date is valid based on leap year calculations by dividing the year by 4, 100, and 400. If the date is valid, it sets the number of days in February accordingly.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not clarify what steps happen in the case of 'Else'.,0.0065056119086392495,0.8583471179008484
py_6591,Python,"def detect_logging_level(self, node):
        """"""
        Heuristic to decide whether an AST Call is a logging call.

        """"""
        try:
            if self.get_id_attr(node.func.value) == ""warnings"":
                return None
            # NB: We could also look at the argument signature or the target attribute
            if node.func.attr in LOGGING_LEVELS:
                return node.func.attr
        except AttributeError:
            pass
        return None",Heuristic to decide whether an AST Call is a logging call.,Heuristic to decide whether an AST Call is a logging call.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,1.0
cob_syn_4479,COBOL,"      * REFACTOR CANDIDATE BATCH_4479
      * SYSTEM GENERATED
000001 Identification Division.                                         00000001
000002 Program-ID. testantlr320.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005                                                                  00000005
000006 01  CONSTANTS.                                                   00000006
000007     05  MYNAME               PIC X(012) VALUE 'testantlr320'.    00000007
000008                                                                  00000008
000009 01 WORK-AREAS.                                                   00000009
000010    05  PGM-0004              PIC X(008) VALUE SPACES.            00000010
000011    05  PGM-0005              PIC X(008) VALUE SPACES.            00000011
000012        88  PGMB5                        VALUE 'PGMB0005'.        00000012
000013    05  PGM-0008-VAL          PIC X(008) VALUE 'PGMK0008'.        00000013
000014    05  PGM-0008 REDEFINES PGM-0008-VAL PIC X(008).               00000014
000015                                                                  00000015
000016 Procedure Division.                                              00000016
000017     DISPLAY MYNAME ' Begin'                                      00000017
000018                                                                  00000018
000019     CALL PGM-0008                                                00000019
000020                                                                  00000020
000021     DISPLAY MYNAME ' End'                                        00000021
000022                                                                  00000022
000023     GOBACK                                                       00000023
000024     .                                                            00000024
000025                                                  ","This COBOL program defines constants and working areas, then displays a message indicating the beginning of the program. It calls a program labeled PGM-0008 and displays a message indicating the end of the program before terminating.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately summarises the function of the source code.,0.007986728673290205,0.8687644004821777
py_10214,Python,"def print_processor_inputs(self, processor_name):
        """"""Print processor input fields and types.

        :param processor_name: Processor object name
        :type processor_name: string

        """"""
        p = self.processors(processor_name=processor_name)

        if len(p) == 1:
            p = p[0]
        else:
            Exception('Invalid processor name')

        for field_schema, _, _ in iterate_schema({}, p['input_schema'], 'input'):
            name = field_schema['name']
            typ = field_schema['type']
            # value = fields[name] if name in fields else None
            print(""{} -> {}"".format(name, typ))",Prints the input fields and their types for a given processor object.,"Print processor input fields and types.

        :param processor_name: Processor object name
        :type processor_name: string",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.0962749922881916,0.8226785063743591
py_13074,Python,"def _run_ssh_command(entries, username, idfile, command, tunnel,
                     parallel=False):
    """"""
    Runs the given command over SSH in parallel on all hosts in `entries`.

    :param entries: The host entries the hostnames from.
    :type entries: ``list`` of :py:class:`HostEntry`
    :param username: To use a specific username.
    :type username: ``str`` or ``NoneType``
    :param idfile: The SSH identity file to use, or none.
    :type idfile: ``str`` or ``NoneType``
    :param command: The command to run.
    :type command: ``str``
    :param parallel: If true, commands will be run in parallel.
    :type parallel: ``bool``
    """"""
    if len(entries) == 0:
        print('(No hosts to run command on)')
        return 1
    if command.strip() == '' or command is None:
        raise ValueError('No command given')
    print('Running command {0} on {1} matching hosts'
          .format(green(repr(command)), len(entries)))
    shell_cmds = []
    for entry in entries:
        hname = entry.hostname or entry.public_ip
        cmd = _build_ssh_command(hname, username, idfile, command, tunnel)
        shell_cmds.append({
            'command': cmd,
            'description': entry.display()
        })
    stream_commands(shell_cmds, parallel=parallel)
    print(green('All commands finished'))","Runs the given command over SSH in parallel on all hosts in `entries`. The function takes a list of host entries, a username, an SSH identity file, a command to run, a boolean flag to specify parallel execution, and returns the command's output on the matching hosts.","Runs the given command over SSH in parallel on all hosts in `entries`.

    :param entries: The host entries the hostnames from.
    :type entries: ``list`` of :py:class:`HostEntry`
    :param username: To use a specific username.
    :type username: ``str`` or ``NoneType``
    :param idfile: The SSH identity file to use, or none.
    :type idfile: ``str`` or ``NoneType``
    :param command: The command to run.
    :type command: ``str``
    :param parallel: If true, commands will be run in parallel.
    :type parallel: ``bool``",Hallucination,True,"The documentation erroneously specifies that the function returns the command's output, whereas the code does not show any return of command output.",0.16622766015400783,0.8361669778823853
cob_syn_3127,COBOL,"      * REFACTOR CANDIDATE BATCH_3127
      * SYSTEM GENERATED
      ******************************************************************
      * Author:
      * Date:
      * Purpose:
      * Tectonics: cobc
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. RECURSION.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT OPTIONAL CALL-STACK ASSIGN TO ""stack.dat""
         ORGANIZATION IS INDEXED
         ACCESS IS RANDOM
         RECORD KEY IS COMMAND-ID.
       DATA DIVISION.
       FILE SECTION.
       FD CALL-STACK.
       01 CALL-STACK-FILE.
           02 COMMAND-ID PIC 9(5).
           02 COMMAND-NAME PIC X(20).
           02 COMMAND-RESULT PIC X(20).
           02 COMMAND-RESULT-NUMERIC
             REDEFINES COMMAND-RESULT PIC 9(20).
           02 COMMAND-RETURN-ID PIC 9(5).
           02 COMMAND-RETURNS-RESULT PIC X.
             88 COMMAND-RETURNS-RESULT-YES VALUE 'Y', FALSE 'N'.
       WORKING-STORAGE SECTION.
       01 WS-CALL-STACK-FILE-STATUS PIC X.
           88 WS-CALL-STACK-FILE-STATUS-OPEN VALUE 'Y', FALSE 'N'.
       01 WS-CALL-STACK.
           02 WS-COMMAND-ID PIC 9(5).
           02 WS-COMMAND-NAME PIC X(20).
           02 WS-COMMAND-RESULT PIC X(20).
           02 WS-COMMAND-RESULT-NUMERIC
             REDEFINES WS-COMMAND-RESULT PIC 9(20).
           02 WS-COMMAND-RETURN-ID PIC 9(5).
           02 WS-COMMAND-RETURN-VALUE PIC X(20).
           02 WS-COMMAND-RETURNS-RESULT PIC X.
               88 WS-COMMAND-RETURNS-RESULT-YES VALUE 'Y', FALSE 'N'.
       01 WS-CALL-STACK-EOF PIC A(1).
       01 WS-CALL-STACK-NEXT-ID PIC 9(5).
       01 WS-IS-LAST-EXPRESSION PIC X.
           88 WS-IS-LAST-EXPRESSION-YES VALUE 'Y', FALSE 'N'.
       01 WS-RETURN.
           02 WS-RETURN-VALUE PIC X(20).
           02 WS-RETURN-VALUE-NUMERIC PIC 9(20).
       01 WS-STACK-STATUS.
           02 WS-LAST-ID PIC 9(5).
           02 WS-OLDEST-ID PIC 9(5).
           02 WS-STACK-IS-EMPTY PIC X.
               88 WS-STACK-I","This COBOL program defines a file structure for maintaining a call stack, with fields for storing command IDs, names, results, return IDs, return values, and outcome indicators. It sets up file handling for reading and writing the call stack data to a file named ""stack.dat"". The program likely includes logic for adding, removing, and processing commands on the call stack using recursion, with indicators for tracking stack status and handling return values.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention any specific operations or methods that would be used to manipulate the call stack, which are fundamental aspects of this program.",0.0053049282909038925,0.8625224232673645
py_12236,Python,"def group(self, name):
        """"""GROUP command.
        """"""
        args = name

        code, message = self.command(""GROUP"", args)
        if code != 211:
            raise NNTPReplyError(code, message)

        parts = message.split(None, 4)
        try:
            total = int(parts[0])
            first = int(parts[1])
            last  = int(parts[2])
            group = parts[3]
        except (IndexError, ValueError):
            raise NNTPDataError(""Invalid GROUP status '%s'"" % message)

        return total, first, last, group","This method sends a GROUP command to an NNTP server with the specified name and returns the total number of articles in the group, the article number of the first article, the article number of the last article, and the name of the group. If any errors occur during the process, appropriate exceptions are raised.",GROUP command.,No Error,False,The generated documentation accurately describes the function's process and potential exceptions.,0.005598996258250374,0.8603008985519409
py_14355,Python,"def initialize(self, argv=None):
        """"""initialize the app""""""
        super(BaseParallelApplication, self).initialize(argv)
        self.to_work_dir()
        self.reinit_logging()","Initialize the application by calling the parent class's initialization method, changing the working directory to the application's directory, and reinitializing the logging system.",initialize the app,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.011603982212675388,0.8463093042373657
cob_syn_10596,COBOL,"      * REFACTOR CANDIDATE BATCH_10596
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. AdventOfCode2019-6a.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT InputFile ASSIGN TO InputPath
       ORGANIZATION IS LINE SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD InputFile   RECORD CONTAINS 7 CHARACTERS.
       01 InputRec.
          02 Orbitee  PIC X(3).
          02 FILLER   PIC X(1).
          02 Orbiter  PIC X(3).
          02 FILLER   PIC X(10).
       88 EndOfFile   VALUE HIGH-VALUES.

       WORKING-STORAGE SECTION.
       01 InputPath  PIC X(50).

       01 ObjsLen    PIC 9(4).
       01 Objs       PIC X(3) OCCURS 1 TO 9999 TIMES 
           DEPENDING ON ObjsLen.

       01 OrbsLen    PIC 9(4).
       01 Orbs       OCCURS 1 TO 9999 TIMES
           DEPENDING ON OrbsLen.
          02 Orbitee PIC 9(4).
          02 Orbiter PIC 9(4).

       01 Name       PIC X(3).
       01 Obj        PIC 9(4).

       01 ListLen    PIC 9(4).
       01 List       PIC 9(4) OCCURS 1 TO 9999 TIMES 
           DEPENDING ON ListLen.
       01 Lvl        PIC 9(4).
       01 LvlEnd     PIC 9(4).
       01 Total      PIC 9(20).

       01 Idx        PIC 9(4).
       01 Jdx        PIC 9(4).

       PROCEDURE DIVISION.
       Begin.
           ACCEPT InputPath FROM ARGUMENT-VALUE.
           OPEN INPUT InputFile.
           READ InputFile
            AT END SET EndOfFile TO TRUE
           END-READ.

           MOVE 0 TO ObjsLen.
           MOVE 1 TO OrbsLen.

           PERFORM UNTIL EndOfFile

            MOVE Orbitee OF InputRec TO Name
            PERFORM FindObj
            IF Obj IS GREATER THAN ObjsLen
             MOVE NAME TO Objs(Obj)
             ADD 1 TO ObjsLen
            END-IF
            MOVE Obj TO Orbitee OF Orbs (OrbsLen)

            MOVE Orbiter OF InputRec TO Name
            PERFORM FindObj
            IF Obj IS GREATER THAN ObjsLen
             MOVE NAME TO Objs(Obj)
             ADD 1 TO ObjsLen
            END-IF
            MOVE Obj ","This COBOL program reads input data consisting of relationships between objects and their orbits, stores the unique objects, and assigns each object to its respective orbiting object.",Legacy COBOL logic requiring documentation.,Omission,True,"The generated documentation does not explain the specifics of each record or field within the COBOL program, particularly the purpose and functionality of each section of the DATA DIVISION.",0.01015265650850611,0.8704376816749573
cob_real_2041,COBOL,"       identification division.
       program-id. cobol.
       procedure division.
       main.
           display 'FuckYouGithub.' end-display.
           stop run.
","This COBOL program displays the message ""FuckYouGithub."" and then stops execution.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.021598265052211615,0.8862951397895813
py_14794,Python,"def cd(self, newdir):
        """"""
        go to the path
        """"""
        prevdir = os.getcwd()
        os.chdir(newdir)
        try:
            yield
        finally:
            os.chdir(prevdir)",This function changes the current working directory to the specified path temporarily by using a generator to yield control and then changes it back to the original working directory once the context is exited.,go to the path,Omission,True,The documentation doesn't mention the feature of the code that also captures the previous directory before changing it.,0.020232988659160612,0.8436742424964905
py_3965,Python,"def authenticate_client(self, request, *args, **kwargs):
        """"""Authenticate itself in other means.

        Other means means is described in `Section 3.2.1`_.

        .. _`Section 3.2.1`: http://tools.ietf.org/html/rfc6749#section-3.2.1
        """"""
        client_id, client_secret = self._get_client_creds_from_request(request)
        log.debug('Authenticate client %r', client_id)

        client = self._clientgetter(client_id)
        if not client:
            log.debug('Authenticate client failed, client not found.')
            return False

        request.client = client

        # http://tools.ietf.org/html/rfc6749#section-2
        # The client MAY omit the parameter if the client secret is an empty string.
        if hasattr(client, 'client_secret') and client.client_secret != client_secret:
            log.debug('Authenticate client failed, secret not match.')
            return False

        log.debug('Authenticate client success.')
        return True","Authenticate itself in other means.

Other means means is described in `Section 3.2.1`_.

.. _`Section 3.2.1`: http://tools.ietf.org/html/rfc6749#section-3.2.1","Authenticate itself in other means.

        Other means means is described in `Section 3.2.1`_.

        .. _`Section 3.2.1`: http://tools.ietf.org/html/rfc6749#section-3.2.1",Omission,True,The documentation does not incorporate information about failure conditions or what happens when the authentication is successful or unsuccessful.,1.0,0.9411455988883972
py_8123,Python,"def get_stdin(self, os_path=None, skip_sub_command=False):
        """"""
        Returns a stdin-suitable file-like object based on the
        optional os_path and optionally skipping any configured
        sub-command.
        """"""
        sub_command = None if skip_sub_command else self.stdin_sub_command
        inn, path = self._get_in_and_path(
            self.stdin, self.stdin_root, sub_command, os_path)
        if hasattr(inn, 'stdout'):
            return inn.stdout
        return inn",Returns a stdin-suitable file-like object based on the optional os_path and optionally skipping any configured sub-command.,"Returns a stdin-suitable file-like object based on the
        optional os_path and optionally skipping any configured
        sub-command.",No Error,False,The documentation accurately describes what the function does without including any unsupported claims or leaving out crucial information.,1.0,0.9077961444854736
py_7362,Python,"def get_credentials():
    """"""
    Returns the user's stored API key if a valid credentials file is found.
    Raises CredentialsError if no valid credentials file is found.
    """"""
    try:
        netrc_path = netrc.path()
        auths = netrc(netrc_path).authenticators(
            urlparse(solvebio.api_host).netloc)
    except (IOError, TypeError, NetrcParseError) as e:
        raise CredentialsError(
            'Could not open credentials file: ' + str(e))

    if auths:
        # auths = (login, account, password)
        return auths[2]
    else:
        return None",Returns the user's stored API key if a valid credentials file is found. Raises CredentialsError if no valid credentials file is found.,"Returns the user's stored API key if a valid credentials file is found.
    Raises CredentialsError if no valid credentials file is found.",Omission,False,The documentation does not mention any information regarding what exceptions are caught and also does not mention the specifics of the returned value.,1.0,0.9720931649208069
py_2098,Python,"def set_selection(self, selection, name=""default"", executor=None):
        """"""Sets the selection object

        :param selection: Selection object
        :param name: selection 'slot'
        :param executor:
        :return:
        """"""
        def create(current):
            return selection
        self._selection(create, name, executor=executor, execute_fully=True)","Sets the selection object with the given selection, name (default value is ""default""), and executor.","Sets the selection object

        :param selection: Selection object
        :param name: selection 'slot'
        :param executor:
        :return:",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.16451929399933107,0.7846843004226685
py_11078,Python,"def remove_url_auth(url):
    """"""
    Removes the user & password and returns them along with a new url.

    :param str url: the URL to sanitize
    :return: a :class:`tuple` containing the authorization portion and
        the sanitized URL.  The authorization is a simple user & password
        :class:`tuple`.

    >>> auth, sanitized = remove_url_auth('http://foo:bar@example.com')
    >>> auth
    ('foo', 'bar')
    >>> sanitized
    'http://example.com'

    The return value from this function is simple named tuple with the
    following fields:

    - *auth* the username and password as a tuple
    - *username* the username portion of the URL or :data:`None`
    - *password* the password portion of the URL or :data:`None`
    - *url* the sanitized URL

    >>> result = remove_url_auth('http://me:secret@example.com')
    >>> result.username
    'me'
    >>> result.password
    'secret'
    >>> result.url
    'http://example.com'

    """"""
    parts = parse.urlsplit(url)
    return RemoveUrlAuthResult(auth=(parts.username or None, parts.password),
                               url=rewrite_url(url, user=None, password=None))",Removes the user & password from a given URL and returns them along with a new URL.,"Removes the user & password and returns them along with a new url.

    :param str url: the URL to sanitize
    :return: a :class:`tuple` containing the authorization portion and
        the sanitized URL.  The authorization is a simple user & password
        :class:`tuple`.

    >>> auth, sanitized = remove_url_auth('http://foo:bar@example.com')
    >>> auth
    ('foo', 'bar')
    >>> sanitized
    'http://example.com'

    The return value from this function is simple named tuple with the
    following fields:

    - *auth* the username and password as a tuple
    - *username* the username portion of the URL or :data:`None`
    - *password* the password portion of the URL or :data:`None`
    - *url* the sanitized URL

    >>> result = remove_url_auth('http://me:secret@example.com')
    >>> result.username
    'me'
    >>> result.password
    'secret'
    >>> result.url
    'http://example.com'",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.0021362730871918737,0.8073601126670837
py_689,Python,"def _extract_log_probs(num_states, dist):
  """"""Tabulate log probabilities from a batch of distributions.""""""

  states = tf.reshape(tf.range(num_states),
                      tf.concat([[num_states],
                                 tf.ones_like(dist.batch_shape_tensor())],
                                axis=0))
  return distribution_util.move_dimension(dist.log_prob(states), 0, -1)",Tabulate log probabilities from a batch of distributions.,Tabulate log probabilities from a batch of distributions.,No Error,False,The documentation accurately describes the function's functionality without any unsupported claims or omissions.,1.0,1.0000001192092896
cob_syn_395,COBOL,"      * REFACTOR CANDIDATE BATCH_395
      * SYSTEM GENERATED
       SELECT ARQUIVO-FUNCIONARIO
           ASSIGN TO ""funcionarios.txt""
           ORGANIZATION IS INDEXED
           RECORD KEY IS FUNCIONARIO-CODIGO
           ACCESS MODE IS DYNAMIC.","Defines a file named ""ARQUIVO-FUNCIONARIO"" that is assigned to a physical file called ""funcionarios.txt"". The file is organized in an indexed structure, with the record key being FUNCIONARIO-CODIGO. Access to the file is in dynamic mode. This code is a candidate for refactoring.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the source code.,0.0,0.8319098353385925
cob_real_3232,COBOL,"           select pd00500 assign to disk wid-pd00500
                organization        is indexed
                access mode         is dynamic
                record key          is f00500-chave = 
                                       f00500-cd-empresa
                                       f00500-cd-filial
                                       f00500-id-bairro
                alternate key       is f00500-chave-1 =
                                       f00500-cd-empresa
                                       f00500-cd-filial
                                       f00500-id-municipio
                                       f00500-cd-bairro                                       
                lock mode           is manual
                file status         is ws-resultado-acesso.

      


","This COBOL code defines a file named `pd00500` to be accessed on disk, using an indexed organization with dynamic access mode. The file has a primary key composed of the fields `f00500-chave`, `f00500-cd-empresa`, `f00500-cd-filial`, and `f00500-id-bairro`. Additionally, an alternate key is defined with the fields `f00500-chave-1`, `f00500-cd-empresa`, `f00500-cd-filial`, `f00500-id-municipio`, and `f00500-cd-bairro`. The file's lock mode is set to manual, and the file status is stored in the variable `ws-resultado-acesso`.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the functionality of the provided COBOL code.,0.004624392108240828,0.8123732805252075
py_7540,Python,"def exons(context, build):
    """"""Delete all exons in the database""""""
    LOG.info(""Running scout delete exons"")
    adapter = context.obj['adapter']

    adapter.drop_exons(build)",Delete all exons in the database,Delete all exons in the database,No Error,False,The documentation accurately reflects what the source code does.,1.0,1.0
cob_syn_400,COBOL,"      * REFACTOR CANDIDATE BATCH_400
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. TERMINATESTMT.
 PROCEDURE DIVISION.
    TERMINATE SOMEREPORT1.","This COBOL program is a batch job marked as a refactor candidate named ""BATCH_400"". It consists of a single procedure that terminates the execution of the program after running the ""SOMEREPORT1"" report.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the provided source code.,0.008811835296733616,0.862523078918457
py_7216,Python,"def json(self, data):
        """"""
        Defines the mock response JSON body.

        Arguments:
            data (dict|list|str): JSON body data.

        Returns:
            self: ``pook.Response`` current instance.
        """"""
        self._headers['Content-Type'] = 'application/json'
        if not isinstance(data, str):
            data = json.dumps(data, indent=4)
        self._body = data","""""""
Defines the mock response JSON body.

Arguments:
    data (dict|list|str): JSON body data.

Returns:
    self: ``pook.Response`` current instance.
""""""","Defines the mock response JSON body.

        Arguments:
            data (dict|list|str): JSON body data.

        Returns:
            self: ``pook.Response`` current instance.",No Error,False,The provided documentation correctly summarizes the function without any unsupported claims or missing critical information.,0.8852140475440834,0.9334077835083008
py_235,Python,"def refresh_from_db(self, session=None, lock_for_update=False):
        """"""
        Refreshes the task instance from the database based on the primary key

        :param lock_for_update: if True, indicates that the database should
            lock the TaskInstance (issuing a FOR UPDATE clause) until the
            session is committed.
        """"""
        TI = TaskInstance

        qry = session.query(TI).filter(
            TI.dag_id == self.dag_id,
            TI.task_id == self.task_id,
            TI.execution_date == self.execution_date)

        if lock_for_update:
            ti = qry.with_for_update().first()
        else:
            ti = qry.first()
        if ti:
            self.state = ti.state
            self.start_date = ti.start_date
            self.end_date = ti.end_date
            # Get the raw value of try_number column, don't read through the
            # accessor here otherwise it will be incremeneted by one already.
            self.try_number = ti._try_number
            self.max_tries = ti.max_tries
            self.hostname = ti.hostname
            self.pid = ti.pid
            self.executor_config = ti.executor_config
        else:
            self.state = None","Refreshes the task instance from the database based on the primary key. The function allows for locking the TaskInstance with a FOR UPDATE clause until the session is committed if `lock_for_update` is set to True. The function updates the state, start date, end date, try number, max tries, hostname, pid, and executor config of the task instance based on the corresponding values in the database if a matching TaskInstance is found. If no matching TaskInstance is found, it sets the state of the task instance to None.","Refreshes the task instance from the database based on the primary key

        :param lock_for_update: if True, indicates that the database should
            lock the TaskInstance (issuing a FOR UPDATE clause) until the
            session is committed.",No Error,False,The documentation accurately explains the functioning of the code without any hallucinations or omissions.,0.1676760942863862,0.829546332359314
py_2326,Python,"def resize_video(in_file,
                 out_file,
                 size=None,
                 ratio=None,
                 keep_ar=False,
                 log_level='info',
                 print_cmd=False,
                 **kwargs):
    """"""Resize a video.

    Args:
        in_file (str): Input video filename.
        out_file (str): Output video filename.
        size (tuple): Expected size (w, h), eg, (320, 240) or (320, -1).
        ratio (tuple or float): Expected resize ratio, (2, 0.5) means
            (w*2, h*0.5).
        keep_ar (bool): Whether to keep original aspect ratio.
        log_level (str): Logging level of ffmpeg.
        print_cmd (bool): Whether to print the final ffmpeg command.
    """"""
    if size is None and ratio is None:
        raise ValueError('expected size or ratio must be specified')
    elif size is not None and ratio is not None:
        raise ValueError('size and ratio cannot be specified at the same time')
    options = {'log_level': log_level}
    if size:
        if not keep_ar:
            options['vf'] = 'scale={}:{}'.format(size[0], size[1])
        else:
            options['vf'] = ('scale=w={}:h={}:force_original_aspect_ratio'
                             '=decrease'.format(size[0], size[1]))
    else:
        if not isinstance(ratio, tuple):
            ratio = (ratio, ratio)
        options['vf'] = 'scale=""trunc(iw*{}):trunc(ih*{})""'.format(
            ratio[0], ratio[1])
    convert_video(in_file, out_file, print_cmd, **options)","""""""Resize a video.

Args:
    in_file (str): Input video filename.
    out_file (str): Output video filename.
    size (tuple): Expected size (w, h), eg, (320, 240) or (320, -1).
    ratio (tuple or float): Expected resize ratio, (2, 0.5) means
        (w*2, h*0.5).
    keep_ar (bool): Whether to keep original aspect ratio.
    log_level (str): Logging level of ffmpeg.
    print_cmd (bool): Whether to print the final ffmpeg command.
""""""","Resize a video.

    Args:
        in_file (str): Input video filename.
        out_file (str): Output video filename.
        size (tuple): Expected size (w, h), eg, (320, 240) or (320, -1).
        ratio (tuple or float): Expected resize ratio, (2, 0.5) means
            (w*2, h*0.5).
        keep_ar (bool): Whether to keep original aspect ratio.
        log_level (str): Logging level of ffmpeg.
        print_cmd (bool): Whether to print the final ffmpeg command.",No Error,False,"The generated documentation accurately describes the arguments, their types, and the overall functionality of the function. There are no hallucinations or omissions.",0.9669306597086389,0.9665559530258179
cob_syn_4312,COBOL,"      * REFACTOR CANDIDATE BATCH_4312
      * SYSTEM GENERATED
      * FIZZBUZZ.COB
      * cobc -x -g FIZZBUZZ.COB
      *
       IDENTIFICATION        DIVISION.
       PROGRAM-ID.           fizzbuzz.
       DATA                  DIVISION.
       WORKING-STORAGE       SECTION.
       01 CNT      PIC 9(03) VALUE 1.
       01 REM      PIC 9(03) VALUE 0.
       01 QUOTIENT PIC 9(03) VALUE 0.
       PROCEDURE             DIVISION.
      *
       PERFORM UNTIL CNT > 100
         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM
         IF REM = 0
           THEN
             DISPLAY ""FizzBuzz "" WITH NO ADVANCING
           ELSE
             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM
             IF REM = 0
               THEN
                 DISPLAY ""Fizz "" WITH NO ADVANCING
               ELSE
                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM
                 IF REM = 0
                   THEN
                     DISPLAY ""Buzz "" WITH NO ADVANCING
                   ELSE
                     DISPLAY CNT "" "" WITH NO ADVANCING
                 END-IF
             END-IF
         END-IF
         ADD 1 TO CNT
       END-PERFORM
       DISPLAY """"
       STOP RUN.
","This COBOL program iterates through numbers from 1 to 100 and performs the FizzBuzz logic. It checks if the number is divisible by 15, 3, or 5, and displays ""FizzBuzz"", ""Fizz"", ""Buzz"", or the number itself accordingly. The program uses divisions and remainders to determine divisibility and print the appropriate output for each number.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes what the program does and contains no unfounded claims or omissions.,0.0056860862169080505,0.8558520674705505
cob_syn_1797,COBOL,"      * REFACTOR CANDIDATE BATCH_1797
      * SYSTEM GENERATED
       *> Try POH
       *> author: Leonardone @ NEETSDKASU
       *>  1
       *>==============================================================$
       IDENTIFICATION DIVISION.
       PROGRAM-ID. Main.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       REPOSITORY.
           FUNCTION ALL INTRINSIC.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 LF PIC X VALUE X""0A"".
       01 Solver-Variables.
           05 INT-I   PIC 9(4).
           05 INT-N   PIC 9(10).
           05 INT-M   PIC 9(10).
           05 STR-Z   PIC Z(9)9.
           05 INT-F   PIC 9 VALUE IS 0.
           05 STR-C   PIC X.
           05 INT-O   PIC 999.
           05 ANSWER  BINARY-LONG.
           05 ARR OCCURS 26 TIMES.
               07 INT-T    BINARY-LONG.
       01 File-Variables.
           05 Access-Mode PIC X USAGE COMP-X VALUE 1.
           05 File-Handle PIC X(4) USAGE COMP-X.
           05 File-Offset PIC X(8) USAGE COMP-X VALUE 0.
           05 Read-Length PIC X(4) USAGE COMP-X VALUE 1000.
           05 Read-Buffer PIC X(1000).
       PROCEDURE DIVISION.
       000-Main SECTION.
              
           CALL ""CBL_OPEN_FILE""
               USING ""/dev/stdin"" Access-Mode 0 0 File-Handle.
           
           PERFORM WITH TEST AFTER UNTIL INT-F >= 4
               
               CALL ""CBL_READ_FILE""
                   USING File-Handle File-Offset
                         Read-Length 0 Read-Buffer
               
               PERFORM WITH TEST AFTER
               VARYING INT-I FROM 1 BY 1 UNTIL INT-I >= Read-Length
                   MOVE Read-Buffer(INT-I:1) TO STR-C
                   EVALUATE INT-F
                       WHEN 0
                           IF STR-C = SPACE THEN
                               MOVE STR-Z TO INT-N
                               MOVE 0 TO STR-Z
                               ADD 1 TO INT-F
                           ELSE
                               MOVE CONCATENATE(TRIM(STR-Z),STR-C)
                      ","This COBOL code reads from a file '/dev/stdin' and processes the data until a certain condition is met. It opens the file, reads the contents into a buffer, and iterates through the buffer character by character. If certain conditions are met, it updates variables and calculates an answer.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention the condition after which the file reading and processing stops.,0.006277466950757328,0.8602920174598694
py_1929,Python,"def fetch_streams_with_retry(plugin, interval, count):
    """"""Attempts to fetch streams repeatedly
       until some are returned or limit hit.""""""

    try:
        streams = fetch_streams(plugin)
    except PluginError as err:
        log.error(u""{0}"", err)
        streams = None

    if not streams:
        log.info(""Waiting for streams, retrying every {0} ""
                 ""second(s)"", interval)
    attempts = 0

    while not streams:
        sleep(interval)

        try:
            streams = fetch_streams(plugin)
        except FatalPluginError as err:
            raise
        except PluginError as err:
            log.error(u""{0}"", err)

        if count > 0:
            attempts += 1
            if attempts >= count:
                break

    return streams","Attempts to fetch streams repeatedly until some are returned or the limit of attempts is reached. This function takes a plugin, an interval (in seconds), and a count as input parameters. If an error occurs while fetching streams, it logs the error message and continues the retry process. It stops retrying after reaching the specified count of attempts.","Attempts to fetch streams repeatedly
       until some are returned or limit hit.",Omission,True,"The documentation does not explain the different types of exceptions 'PluginError' and 'FatalPluginError' that the function can raise, and the fact that 'FatalPluginError' terminates the program immediately.",0.15275393757315023,0.853847324848175
py_7501,Python,"def _check_year(year, month, error, error_msg):
    """"""Checks that the year is within 50 years from now.""""""
    if year not in xrange((now.year - 50), (now.year + 51)):
        year = now.year
        month = now.month
        error = error_msg
    return year, month, error","Checks that the year is within 50 years from now and returns the corrected year, month, and error message if needed.",Checks that the year is within 50 years from now.,Omission,True,The documentation does not account for the defaulting of the year and month to the current date when the year is not within the 50 years range.,0.38091370416670794,0.9253711104393005
py_2208,Python,"def pitch_shift(y, sr, n_steps, bins_per_octave=12, res_type='kaiser_best'):
    '''Pitch-shift the waveform by `n_steps` half-steps.


    Parameters
    ----------
    y : np.ndarray [shape=(n,)]
        audio time-series

    sr : number > 0 [scalar]
        audio sampling rate of `y`

    n_steps : float [scalar]
        how many (fractional) half-steps to shift `y`

    bins_per_octave : float > 0 [scalar]
        how many steps per octave

    res_type : string
        Resample type.
        Possible options: 'kaiser_best', 'kaiser_fast', and 'scipy', 'polyphase',
        'fft'.
        By default, 'kaiser_best' is used.
        
        See `core.resample` for more information.

    Returns
    -------
    y_shift : np.ndarray [shape=(n,)]
        The pitch-shifted audio time-series


    See Also
    --------
    time_stretch : time stretching
    librosa.core.phase_vocoder : spectrogram phase vocoder


    Examples
    --------
    Shift up by a major third (four half-steps)

    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> y_third = librosa.effects.pitch_shift(y, sr, n_steps=4)

    Shift down by a tritone (six half-steps)

    >>> y_tritone = librosa.effects.pitch_shift(y, sr, n_steps=-6)

    Shift up by 3 quarter-tones

    >>> y_three_qt = librosa.effects.pitch_shift(y, sr, n_steps=3,
    ...                                          bins_per_octave=24)
    '''

    if bins_per_octave < 1 or not np.issubdtype(type(bins_per_octave), np.integer):
        raise ParameterError('bins_per_octave must be a positive integer.')

    rate = 2.0 ** (-float(n_steps) / bins_per_octave)

    # Stretch in time, then resample
    y_shift = core.resample(time_stretch(y, rate), float(sr) / rate, sr,
                            res_type=res_type)

    # Crop to the same dimension as the input
    return util.fix_length(y_shift, len(y))","Pitch-shift the waveform by a specified number of half-steps. This function takes an audio time-series `y`, its sampling rate `sr`, the number of half-steps to shift `n_steps`, the number of steps per octave `bins_per_octave`, and the resampling type `res_type`. The pitch-shifted audio time-series `y_shift` is returned. See `core.resample` for more details. Also, refer to `time_stretch` and `librosa.core.phase_vocoder` for related functionalities. The function includes examples demonstrating pitch shifting by various intervals such as a major third, a tritone, and quarter-tones.","Pitch-shift the waveform by `n_steps` half-steps.


    Parameters
    ----------
    y : np.ndarray [shape=(n,)]
        audio time-series

    sr : number > 0 [scalar]
        audio sampling rate of `y`

    n_steps : float [scalar]
        how many (fractional) half-steps to shift `y`

    bins_per_octave : float > 0 [scalar]
        how many steps per octave

    res_type : string
        Resample type.
        Possible options: 'kaiser_best', 'kaiser_fast', and 'scipy', 'polyphase',
        'fft'.
        By default, 'kaiser_best' is used.
        
        See `core.resample` for more information.

    Returns
    -------
    y_shift : np.ndarray [shape=(n,)]
        The pitch-shifted audio time-series


    See Also
    --------
    time_stretch : time stretching
    librosa.core.phase_vocoder : spectrogram phase vocoder


    Examples
    --------
    Shift up by a major third (four half-steps)

    >>> y, sr = librosa.load(librosa.util.example_audio_file())
    >>> y_third = librosa.effects.pitch_shift(y, sr, n_steps=4)

    Shift down by a tritone (six half-steps)

    >>> y_tritone = librosa.effects.pitch_shift(y, sr, n_steps=-6)

    Shift up by 3 quarter-tones

    >>> y_three_qt = librosa.effects.pitch_shift(y, sr, n_steps=3,
    ...                                          bins_per_octave=24)",No Error,False,"The generated documentation accurately describes what the function does, its parameters, return value, related functionalities, and provides relevant examples, in line with the source code.",0.06403317718105776,0.811172366142273
cob_syn_10786,COBOL,"      * REFACTOR CANDIDATE BATCH_10786
      * SYSTEM GENERATED
IDENTIFICATION DIVISION.
PROGRAM-ID. HELLO-WORLD.
PROCEDURE DIVISION.
    DISPLAY 'Hello world!'.
    STOP RUN.
","This COBOL program is a simple ""Hello world!"" program. When run, it displays the message ""Hello world!"" on the system output.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the source code.,0.012518377344512808,0.8727548718452454
py_1029,Python,"def _flatten_summand_list(kernels):
  """"""Flatten a list of kernels which may contain _SumKernel instances.

  Args:
    kernels: Python list of `PositiveSemidefiniteKernel` instances

  Returns:
    Python list containing the elements of kernels, with any _SumKernel
    instances replaced by their `kernels` property contents.
  """"""
  flattened = []
  for k in kernels:
    if isinstance(k, _SumKernel):
      flattened += k.kernels
    else:
      flattened.append(k)
  return flattened","Flatten a list of kernels which may contain \_SumKernel instances, replacing any \_SumKernel instances by their `kernels` property contents.","Flatten a list of kernels which may contain _SumKernel instances.

  Args:
    kernels: Python list of `PositiveSemidefiniteKernel` instances

  Returns:
    Python list containing the elements of kernels, with any _SumKernel
    instances replaced by their `kernels` property contents.",No Error,False,The documentation accurately describes the functionality of the code without any hallucinations or omissions.,0.24907819045366622,0.8943276405334473
cob_syn_9286,COBOL,"      * REFACTOR CANDIDATE BATCH_9286
      * SYSTEM GENERATED
000100 PROCESS XOPTS(APOST)
000100 PROCESS NOSEQ LIB OPTIMIZE(FULL)
000100 Identification Division.
000100 Program-ID. 
000100  Opts.
000100 Procedure Division.","This COBOL code represents a batch processing program with the program ID ""Opts"". The code processes a set of options defined in an external file with the specified characteristics.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention that this is a system-generated refactor candidate and the specification NOSEQ LIB OPTIMIZE(FULL).,0.009565665109256835,0.8733949661254883
py_10827,Python,"def auto_find_instance_path(self):
        """"""Tries to locate the instance path if it was not provided to the
        constructor of the application class.  It will basically calculate
        the path to a folder named ``instance`` next to your main file or
        the package.

        .. versionadded:: 0.8
        """"""
        prefix, package_path = find_package(self.import_name)
        if prefix is None:
            return os.path.join(package_path, 'instance')
        return os.path.join(prefix, 'var', self.name + '-instance')",Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named ``instance`` next to your main file or the package.,"Tries to locate the instance path if it was not provided to the
        constructor of the application class.  It will basically calculate
        the path to a folder named ``instance`` next to your main file or
        the package.

        .. versionadded:: 0.8",No Error,False,The documentation accurately describes the function's operation and does not make unsupported claims.,0.9221189220143736,0.8854888677597046
py_2321,Python,"def current_lr(self):
        """"""Get current learning rates.

        Returns:
            list: Current learning rate of all param groups.
        """"""
        if self.optimizer is None:
            raise RuntimeError(
                'lr is not applicable because optimizer does not exist.')
        return [group['lr'] for group in self.optimizer.param_groups]","Get current learning rates.

Returns:
    list: Current learning rate of all param groups.","Get current learning rates.

        Returns:
            list: Current learning rate of all param groups.",No Error,False,The documentation accurately reflects what the code does.,1.0,0.9497397541999817
cob_real_1929,COBOL,"       IDENTIFICATION DIVISION.                                                 
       PROGRAM-ID.  TRTMNT.                                                     
       AUTHOR. JON SAYLES.                                                      
       INSTALLATION. COBOL DEV Center.                                          
       DATE-WRITTEN. 01/23/88.                                                  
       DATE-COMPILED. 01/23/88.                                                 
       SECURITY. CONFIDENTIAL PATIENT DATA.                                     
                                                                                
      ******************************************************************        
      *REMARKS.                                                                 
      *                                                                         
      *          THIS PROGRAM EDITS A DAILY TREATMENT TRANSACTION FILE          
      *          PRODUCED BY DATA ENTRY OPERATORS FROM CICS SCREENS             
      *                                                                         
      *          IT CONTAINS EVERY TREATMENT FOR EVERY PATIENT IN THE           
      *          HOSPITAL.                                                      
      *                                                                         
      *          THE PROGRAM EDITS EACH RECORD AGAINST A NUMBER OF              
      *          CRITERIA, BALANCES FINAL TOTALS AND WRITES GOOD                
      *          RECORDS TO AN OUTPUT FILE                                      
      *                                                                         
      ******************************************************************        
                                                                                
               INPUT FILE              -   DDS0001.TRMTDATA                     
                                                        ","This COBOL program edits a daily treatment transaction file generated by data entry operators from CICS screens. It processes every treatment for every patient in the hospital by validating each record against specific criteria, calculating final totals, and outputting valid records to an output file.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly summarizes the functionality of the source code without any unsupported claims or omitted critical information.,0.006626589205134352,0.8654034733772278
py_7798,Python,"def generate_hpo_gene_list(self, *hpo_terms):
        """"""Generate a sorted list with namedtuples of hpogenes

            Each namedtuple of the list looks like (hgnc_id, count)

            Args:
                hpo_terms(iterable(str))

            Returns:
                hpo_genes(list(HpoGene))
        """"""
        genes = {}
        for term in hpo_terms:
            hpo_obj = self.hpo_term(term)
            if hpo_obj:
                for hgnc_id in hpo_obj['genes']:
                    if hgnc_id in genes:
                        genes[hgnc_id] += 1
                    else:
                        genes[hgnc_id] = 1
            else:
                LOG.warning(""Term %s could not be found"", term)

        sorted_genes = sorted(genes.items(), key=operator.itemgetter(1), reverse=True)
        return sorted_genes","Generate a sorted list with namedtuples of hpogenes. Each namedtuple of the list looks like (hgnc_id, count).

Args:
- hpo_terms (iterable(str)): Iterable of HPO terms.

Returns:
- hpo_genes (list(HpoGene)): List of namedtuples with hgnc_id and count of occurrences.","Generate a sorted list with namedtuples of hpogenes

            Each namedtuple of the list looks like (hgnc_id, count)

            Args:
                hpo_terms(iterable(str))

            Returns:
                hpo_genes(list(HpoGene))",Omission,True,The documentation does not explain what happens when a given term is not found in the hpo_terms.,0.33336338752218725,0.830540657043457
py_9125,Python,"def iffti(wave, npoints=None, indep_min=None, indep_max=None):
    r""""""
    Return the imaginary part of the inverse Fast Fourier Transform of a waveform.

    :param wave: Waveform
    :type  wave: :py:class:`peng.eng.Waveform`

    :param npoints: Number of points to use in the transform. If **npoints**
                    is less than the size of the independent variable vector
                    the waveform is truncated; if **npoints** is greater than
                    the size of the independent variable vector, the waveform
                    is zero-padded
    :type  npoints: positive integer

    :param indep_min: Independent vector start point of computation
    :type  indep_min: integer or float

    :param indep_max: Independent vector stop point of computation
    :type  indep_max: integer or float

    :rtype: :py:class:`peng.eng.Waveform`

    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc(raised=True)) ]]]
    .. Auto-generated exceptions documentation for
    .. peng.wave_functions.iffti

    :raises:
     * RuntimeError (Argument \`indep_max\` is not valid)

     * RuntimeError (Argument \`indep_min\` is not valid)

     * RuntimeError (Argument \`npoints\` is not valid)

     * RuntimeError (Argument \`wave\` is not valid)

     * RuntimeError (Incongruent \`indep_min\` and \`indep_max\`
       arguments)

     * RuntimeError (Non-uniform frequency spacing)

    .. [[[end]]]
    """"""
    return imag(ifft(wave, npoints, indep_min, indep_max))","Return the imaginary part of the inverse Fast Fourier Transform of a waveform, given the waveform, number of points for the transform, start and stop points of computation on the independent vector. This function returns a waveform. It raises various RuntimeError exceptions for invalid arguments and incongruent parameters.","r""""""
    Return the imaginary part of the inverse Fast Fourier Transform of a waveform.

    :param wave: Waveform
    :type  wave: :py:class:`peng.eng.Waveform`

    :param npoints: Number of points to use in the transform. If **npoints**
                    is less than the size of the independent variable vector
                    the waveform is truncated; if **npoints** is greater than
                    the size of the independent variable vector, the waveform
                    is zero-padded
    :type  npoints: positive integer

    :param indep_min: Independent vector start point of computation
    :type  indep_min: integer or float

    :param indep_max: Independent vector stop point of computation
    :type  indep_max: integer or float

    :rtype: :py:class:`peng.eng.Waveform`

    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc(raised=True)) ]]]
    .. Auto-generated exceptions documentation for
    .. peng.wave_functions.iffti

    :raises:
     * RuntimeError (Argument \`indep_max\` is not valid)

     * RuntimeError (Argument \`indep_min\` is not valid)

     * RuntimeError (Argument \`npoints\` is not valid)

     * RuntimeError (Argument \`wave\` is not valid)

     * RuntimeError (Incongruent \`indep_min\` and \`indep_max\`
       arguments)

     * RuntimeError (Non-uniform frequency spacing)

    .. [[[end]]]",No Error,False,The documentation accurately represents the source code's functionality and exceptions.,0.03700980972803017,0.7769540548324585
cob_syn_3039,COBOL,"      * REFACTOR CANDIDATE BATCH_3039
      * SYSTEM GENERATED
       DELEGATE-ID func.
       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG
           RETURNING ret AS FLOAT-LONG.
       END DELEGATE.

       CLASS-ID. MainClass.

       78  T0                     VALUE 100.0.
       78  TR                     VALUE 20.0.
       78  k                      VALUE 0.07.

       01  delta-t                INITIALIZE ONLY STATIC
                                  FLOAT-LONG OCCURS 3 VALUES 2.0, 5.0, 10.0.

       78  n                      VALUE 100.

       METHOD-ID NewtonCooling STATIC.
       PROCEDURE DIVISION USING VALUE t AS FLOAT-LONG
               RETURNING ret AS FLOAT-LONG.
           COMPUTE ret = - k * (t - TR)
       END METHOD.

       METHOD-ID Main STATIC.
           DECLARE f AS TYPE func
           SET f TO METHOD self::NewtonCooling

           DECLARE delta-t-len AS BINARY-LONG
           MOVE delta-t::Length TO delta-t-len
           PERFORM VARYING i AS BINARY-LONG FROM 1 BY 1
                   UNTIL i > delta-t-len
               DECLARE elt AS FLOAT-LONG = delta-t (i)
               INVOKE TYPE Console::WriteLine(""delta-t = {0:F4}"", elt)
               INVOKE self::Euler(f, T0, n, elt)
           END-PERFORM
       END METHOD.

       METHOD-ID Euler STATIC.
       PROCEDURE DIVISION USING VALUE f AS TYPE func, y AS FLOAT-LONG,
               n AS BINARY-LONG, h AS FLOAT-LONG.
           PERFORM VARYING x AS BINARY-LONG FROM 0 BY h UNTIL x >= n
               INVOKE TYPE Console::WriteLine(""x = {0:F4}, y = {1:F4}"", x, y)
               COMPUTE y = y + h * RUN f(y)
           END-PERFORM
       END METHOD.
       END CLASS.
","This COBOL code defines a MainClass with methods to calculate Newton's cooling, perform the Euler method for a given function, and display the results. The Main method calculates and displays the results of Newton's cooling for different time intervals stored in the delta-t array using the Euler method.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the code's functionality without any unsupported claims or missing critical information.,0.006277466950757328,0.8616956472396851
cob_real_988,COBOL,"       PROCESS XOPTS(SP APOST)
       PROCESS NOSEQ LIB OPTIMIZE(FULL) ARITH(EXTEND)
       Identification Division.
       Program-ID. 
        Opts.
       Procedure Division.","This COBOL program is named ""Opts"" and defines the necessary identification and program name sections. It processes various compiler options such as SP (space), APOST (apostrophes), NOSEQ (no sequence), LIB (library), OPTIMIZE (full optimization), and ARITH (extended arithmetic).",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the details present in the source code.,0.007633935801913548,0.84333735704422
py_7020,Python,"def build_downstream(self, process_descriptions, task, all_tasks,
                         task_pipeline,
                         count_forks, total_tasks, forks):
        """"""Builds the downstream pipeline of the current process

        Checks for the downstream processes to the current process and
        adds them to the current pipeline fragment.

        Parameters
        ----------
        process_descriptions : dict
            Information of processes input, output and if is forkable
        task : str
            Current process
        all_tasks : list
            A list of all provided processes
        task_pipeline : list
            Current pipeline fragment
        count_forks : int
            Current number of forks
        total_tasks : str
            All space separated processes
        forks : list
            Current forks
        Returns
        -------
        list : resulting pipeline fragment
        """"""

        if task in process_descriptions:
            if process_descriptions[task][2] is not None:
                if len(process_descriptions[task][2].split(""|"")) > 1:
                    local_forks = process_descriptions[task][2].split(""|"")

                    # Adds the process to the pipeline fragment downstream
                    # and defines a new pipeline fragment for each fork.
                    # Those will only look for downstream processes
                    for local_fork in local_forks:
                        if local_fork in total_tasks:
                            count_forks += 1
                            task_pipeline.append(process_descriptions[task][2])
                            self.define_pipeline_string(
                                process_descriptions,
                                local_fork,
                                False,
                                True,
                                count_forks,
                                total_tasks,
                                forks
                            )

                    return task_pipeline
                else:
                    if process_descriptions[task][2] in total_tasks:
                        task_pipeline.append(process_descriptions[task][2].split(""|"")[0])

                        # Proceeds building downstream until the output for a
                        # process is None
                        self.build_downstream(
                            process_descriptions,
                            process_descriptions[task][2].split(""|"")[0],
                            all_tasks,
                            task_pipeline,
                            count_forks,
                            total_tasks,
                            forks
                        )

                    return task_pipeline
            else:
                return task_pipeline","Builds the downstream pipeline of the current process by checking for downstream processes and adding them to the current pipeline fragment. It takes in various parameters such as process descriptions, the current process, all tasks, task pipeline, count of forks, total tasks, and forks. The function recursively builds the downstream pipeline until the output for a process is None.","Builds the downstream pipeline of the current process

        Checks for the downstream processes to the current process and
        adds them to the current pipeline fragment.

        Parameters
        ----------
        process_descriptions : dict
            Information of processes input, output and if is forkable
        task : str
            Current process
        all_tasks : list
            A list of all provided processes
        task_pipeline : list
            Current pipeline fragment
        count_forks : int
            Current number of forks
        total_tasks : str
            All space separated processes
        forks : list
            Current forks
        Returns
        -------
        list : resulting pipeline fragment",No Error,False,The documentation accurately reflects what the source code is designed to accomplish without any unsupported claims or crucial missing information.,0.15420764123961067,0.7645455002784729
cob_real_2751,COBOL,"*> ------------------------------------------------------------------
*> -                    Babylonian Square Roots                     -
*> -                  Re-engineered with love. <3                   -
*> -                   by Jason Nguyen (XXXXXXXX)                    -
*> ------------------------------------------------------------------

*> - made the abs() check more efficient
*> - inlined the constant print messages
*> - renamed s1 to GET_NEW_LINE
*> - renamed b1 to EXECUTE_BABYLON
*> - renamed s2 to MAKE_NEXT_GUESS
*> - renamed e2 to NEXT_ITERATION

identification division.
program-id. SQRT.

environment division.

input-output section.
file-control.
    select inputFile assign to ""sqrt.dat""
        organization is line sequential.
    select standardOutput assign to display.

data division.
file section.
fd inputFile.
    01 standardInput   pic X(80).
fd standardOutput.
    01 outLine         pic X(80).

working-storage section.
77 epsilon     pic v9(5).
77 radicand    pic 9(11)V9(6).

77 guess       pic 9(11)v9(6).
77 nextGuess   pic 9(11)v9(6).

77 i           pic s9999.

*> formatted line to be read in
*> num: 1 (sign), 10 (characteristic), 6 (mantissa)
*> eps: 5 (epsilon needed for halt, v implied decimal)
*> the x(58) represents 58 unused spaces in the file
01 lineStruct.
    02 radicandIn      pic s9(10)v9(6) sign leading separate.
    02 epsilonIn       pic v9(5). *> reads in 00100
    02 filler pic x(58). *> reads in 58 spaces lmfao

*> ------------------------Logging Messages--------------------------
01 printLine.
    02 filler pic x value space.
    02 outZ pic z(11)9.9(6).
    02 filler pic x(5) value spaces.
    02 outY pic z(11)9.9(6).

01 errorMessage.
    02 filler pic x value space.
    02 otZ pic -(11)9.9(6).
    02 filler pic x(21) value '        Invalid Input'.

01 abortMessage.
    02 filler pic x value space.
    02 outpZ pic z(11)9.9(6).
    02 filler pic x(37) value '  Attempt aborted.Too many iterations'.
*> -----------------","This COBOL program calculates square roots using the Babylonian method. It reads input data from a file named ""sqrt.dat"" and outputs the results to the display. The program includes optimizations such as efficient absolute value checks and inlined constant print messages. Key components like variables and file structures have been appropriately renamed for clarity.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly summarizes the functions and processes within the source code.,0.0056860862169080505,0.862575113773346
py_4335,Python,"def fit(self, Z):
        """"""
        Fit linear model.

        Parameters
        ----------
        Z : DictRDD with (X, y) values
            X containing numpy array or sparse matrix - The training data
            y containing the target values

        Returns
        -------
        self : returns an instance of self.
        """"""
        check_rdd(Z, {'X': (sp.spmatrix, np.ndarray)})
        return self._spark_fit(SparkLinearRegression, Z)","""""""
Fit linear model.

Parameters
----------
Z : DictRDD with (X, y) values
    X containing numpy array or sparse matrix - The training data
    y containing the target values

Returns
-------
self : returns an instance of self.
""""""","Fit linear model.

        Parameters
        ----------
        Z : DictRDD with (X, y) values
            X containing numpy array or sparse matrix - The training data
            y containing the target values

        Returns
        -------
        self : returns an instance of self.",Omission,True,The documentation is missing information about the function calling the 'check_rdd' function and '_spark_fit' function.,0.9466178497997028,0.9092774987220764
cob_syn_4820,COBOL,"      * REFACTOR CANDIDATE BATCH_4820
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. SUBTRSTMT.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 77 SOMEID1 PIC 9(10).
 77 SOMEID2 PIC 9(10).
 77 SOMEID3 PIC 9(10).
 PROCEDURE DIVISION.
     SUBTRACT SOMEID1 1 FROM SOMEID2 SOMEID3 ROUNDED.","Subtracts the value of variable SOMEID1 from the sum of variables SOMEID2 and SOMEID3, rounding the result.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation incorrectly states that the value of SOMEID1 is subtracted from the sum of SOMEID2 and SOMEID3, whereas the code subtracts from SOMEID2 and SOMEID3 individually.",0.0,0.8313482403755188
cob_syn_10031,COBOL,"      * REFACTOR CANDIDATE BATCH_10031
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. DATADESCRREDEFINED.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 01 ITEMS1.
    02 ITEM PIC X(10).
 01 ITEMS2.
    02 ITEM PIC X(10).
","This COBOL program declares two data structures, ITEMS1 and ITEMS2, each containing a field named ITEM with a length of 10 characters. The purpose of this program is to define the data layout for ITEM elements in a batch processing system.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the source code.,0.0071638813215387015,0.8646916747093201
cob_real_3793,COBOL,"       Identification Division.
       Program-ID. testantlr030.
       Data Division.
       Working-Storage Section.
       01  CONSTANTS.
           05  MYNAME               PIC X(012) VALUE 'testantlr030'.

      * 
       01  SOME-DATA.
           05  SD-001               PIC X(008).
           05  SD-002.
               10  SD-002-A         PIC X(001).
               10  SD-002-B         PIC X(001).
           05  SD-003               PIC X(008).

       01  WS-BUF                   PIC X(100).

       77  WS-COUNT                 PIC 9(008) COMP-5 VALUE 0.

       Procedure Division.
           DISPLAY MYNAME ' Begin'
           
           XML GENERATE WS-BUF FROM SOME-DATA END-XML

           XML GENERATE
               WS-BUF FROM SOME-DATA
               COUNT WS-COUNT
               ENCODING 37
               XML-DECLARATION
               ATTRIBUTES
               NAMESPACE 'AEIOU'
               NAMESPACE-PREFIX 'ZZ9PLURALZA'
               NAME SD-001 'ARTHUR'
                    SD-002 'DENT'
               TYPE SD-003 ELEMENT SD-002-A ATTRIBUTE SD-002-B CONTENT
               SUPPRESS EVERY NONNUMERIC ELEMENT WHEN LOW-VALUES
                        EVERY NUMERIC ELEMENT 
                              WHEN LOW-VALUES OR HIGH-VALUES
               ON EXCEPTION PERFORM 1000-para
               NOT ON EXCEPTION CALL 'CEE3ABD'
           END-XML

           XML GENERATE
               WS-BUF FROM SOME-DATA
               COUNT IN WS-COUNT
               WITH ENCODING 37
               WITH XML-DECLARATION
               WITH ATTRIBUTES
               NAMESPACE IS 'AEIOU'
               NAMESPACE-PREFIX IS 'ZZ9PLURALZA'
               NAME OF SD-001 IS 'ARTHUR'
                       SD-002 IS 'DENT'
               TYPE OF SD-003 IS ELEMENT
                       SD-002-A IS ATTRIBUTE
                       SD-002-B IS CONTENT
               SUPPRESS EVERY NONNUMERIC ELEMENT WHEN LOW-VALUES
                        SD-001 WHEN ZERO OR ZEROES OR ZEROS
     ","This COBOL code defines data structures and uses XML GENERATE statements to generate XML data from the specified data items. The generated XML includes various attributes such as encoding, namespace, namespace prefix, element names, and content types. It also includes suppression conditions for specific elements based on their values. An exception handling mechanism is implemented to handle exceptions during the XML generation process.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the source code.,0.0049936829345510496,0.8604016304016113
cob_real_3963,COBOL,"      *-----------------------------------------------------------------
      * $ cobc -Wall -Wextra -std=ibm-strict -fixed -g -O0 -debug \
      *        -x -o a.out cobol/MAIN2.cbl
      * $ cat example.txt | ./a.out
      *-----------------------------------------------------------------
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  AOC-2021-D01-2.
      * AUTHOR. HBOBENICIO.
      * DATE-WRITTEN. 09/12/2021.
      * SECURITY. NON-CONFIDENTIAL.
      *-----------------------------------------------------------------
       ENVIRONMENT DIVISION.
         INPUT-OUTPUT SECTION.
         FILE-CONTROL.
           SELECT INPUT-FILE ASSIGN TO '/dev/stdin' *> KEYBOARD
           ORGANIZATION IS LINE SEQUENTIAL.
      *-----------------------------------------------------------------
       DATA DIVISION.

       FILE SECTION.
       FD  INPUT-FILE.
       01  INPUT-FILE-RECORD.
           05 NUM PIC X(4).

       WORKING-STORAGE SECTION.
       01  WS-XS.
         05  XS-ARR  PIC 9(4) OCCURS 2048 TIMES.
         05  XS-LEN  PIC 9(4) VALUE 0.
       01  WS-LOOP      PIC A(1).
         88  LOOP-BREAK          VALUE 'B'.
         88  LOOP-CONTINUE       VALUE 'C'.
       01  WS-AUX.
         05  WS-I         PIC 9(4) VALUE 1.
         05  WS-COUNT     PIC 9(4) VALUE 0.
         05  WS-PREV      PIC 9(5) VALUE 9999.
         05  WS-SUM       PIC 9(5).
         05  WS-SOLUTION  PIC 9(4) VALUE 0.
      *-----------------------------------------------------------------
       PROCEDURE DIVISION.
       MAIN.
           PERFORM READ-AND-PARSE-INPUT.
           PERFORM SOLVE.
           DISPLAY WS-SOLUTION.
           MOVE 0 TO RETURN-CODE.
           GOBACK.

       READ-AND-PARSE-INPUT.
           OPEN INPUT INPUT-FILE.
           PERFORM UNTIL LOOP-BREAK
              READ INPUT-FILE AT END SET LOOP-BREAK TO TRUE
              NOT AT END
                 MOVE NUM TO XS-ARR(XS-LEN + 1)
                 SET XS-LEN UP BY 1
              END-READ
           END-PERFORM.
   ","This COBOL program reads a list of numbers from the standard input, stores them in an array, calculates the sum of the numbers, and then displays the result. The program defines various data structures and sections for file handling, working storage, and procedure. The `READ-AND-PARSE-INPUT` section reads the input numbers, while the `SOLVE` section calculates the sum. Finally, the program displays the total sum of the input numbers.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation claims that the program calculates the sum of numbers, while the source code does not support this claim.",0.004681807893998983,0.8487743735313416
cob_real_570,COBOL,"      ***********************************************************************
      ** (c) Copyright IBM Corp. 2007 All rights reserved.
      ** 
      ** The following sample of source code (""Sample"") is owned by International 
      ** Business Machines Corporation or one of its subsidiaries (""IBM"") and is 
      ** copyrighted and licensed, not sold. You may use, copy, modify, and 
      ** distribute the Sample in any form without payment to IBM, for the purpose of 
      ** assisting you in the development of your applications.
      ** 
      ** The Sample code is provided to you on an ""AS IS"" basis, without warranty of 
      ** any kind. IBM HEREBY EXPRESSLY DISCLAIMS ALL WARRANTIES, EITHER EXPRESS OR 
      ** IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
      ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Some jurisdictions do 
      ** not allow for the exclusion or limitation of implied warranties, so the above 
      ** limitations or exclusions may not apply to you. IBM shall not be liable for 
      ** any damages you suffer as a result of using, copying, modifying or 
      ** distributing the Sample, even if IBM has been advised of the possibility of 
      ** such damages.
      ***********************************************************************
      **
      ** SOURCE FILE NAME: monsz.cbl 
      **
      ** SAMPLE: How to get a database monitor snapshot
      **
      **         This program first requests for the buffer size that would
      **         required for issuing a snapshot for locks, tables, and 
      **         database level information.
      **
      **         This testcase will return SQL1611, no data was returned
      **         by Database System Monitor. Some activity must be done to
      **         generate data for the snapshot: connect to database, 
      **         manipulate data, etc
      **
      ** DB2 APIs USED:
      **         db2GetSnapshotSize -- ESTIMATE BUFFER SIZE
     ","This COBOL program demonstrates how to retrieve a database monitor snapshot by first determining the buffer size needed for capturing lock, table, and database-level information. It provides guidance on generating data to ensure that the snapshot returns meaningful results. The specific DB2 API mentioned is db2GetSnapshotSize, which is used to estimate the buffer size required for the snapshot.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the source code and its functionalities without any hallucinations or omissions.,0.005354194904142114,0.8614363670349121
py_7962,Python,"def subs_consts(self, expr):
        """"""Substitute constants in expression unless it is already a number.""""""
        if isinstance(expr, numbers.Number):
            return expr
        else:
            return expr.subs(self.constants)",Substitute constants in expression unless it is already a number.,Substitute constants in expression unless it is already a number.,No Error,False,The documentation accurately represents the source code's functionality.,1.0,1.0
cob_syn_6828,COBOL,"      * REFACTOR CANDIDATE BATCH_6828
      * SYSTEM GENERATED
# PIO ROM emulation testing
# PIO puts valid data out about 40ns after the ""enable"" signal asserts
# actual Keyboard ROM in the Apple IIe takes about 100 ns.
# @baldengineer

import array
import time
import board
import rp2pio
import adafruit_pioasm
import rom

iie_address_decode = """"""
.program iie_address_decode

loop:

in pins, 10     ; Need Inputs -- Johnny 5
in null, 22     ; shifts bits so address is readable
push            ; put pins into RX FIFO
; issue is, the FIFO is bigger than I need, so how
; to handle
jmp loop
""""""


iie_rom = """"""
.program iie_rom

; output pins : 21-27 (GP16-GP22)
; enable input: 31 (GP26)

mov x, null        ; fallback char if TX FIFO is empty
mov y, null        ; will store last decoded character

loop:
    wait 0 gpio 26     ; wait for ENABLE to assert
    pull noblock       ; if empty, MOV OSR, X

    ; check if there is a new character
    mov x, osr
    jmp !x output      

    ; mmmm fresh char, save for later
    mov y, x           

output:
    mov osr, y         ; repeat previous if not new
    out pins, 7        ; load out_pins register (7 bit data) from OSR
    mov osr, ~ null    ; load FFs into OSR (for change to output)
    out pindirs, 7     ; shift 7 FFs into pin direction register from OSR

    mov osr, null      ; load 0s into OSR (for change to Hi-Z)
    wait 1 gpio 26     ; wait for ENABLE to de-assert
    out pindirs, 7     ; shfit 7 0s into pin dir register from OSR

    mov x, null        ; reset x for next iteration
    jmp loop           ; do it again!

""""""

assembled = adafruit_pioasm.assemble(iie_rom)
address_assembled = adafruit_pioasm.assemble(iie_address_decode)

sm_data = rp2pio.StateMachine(
    assembled,
    frequency=125_000_000,
    first_out_pin=board.GP16,  # pin 21 (bottom right corner)
    out_pin_count=7,
    initial_out_pin_direction=0,
    first_in_pin=board.GP26,   # pin 31
)

sm_addr = rp2pio.StateMachine(
    address_assembled,
    frequency=125_000_000,
    first_in_pin=board.GP0,   # Pin ","This COBOL code snippet does not contain a valid COBOL program. The code seems to be a mix of Python code for setting up RP2PIO state machines for ROM emulation testing along with inline assembly code for the state machine behavior. This code initializes two state machines for ROM emulation, defines the behavior of reading/writing data using PIO (Programmable I/O) instructions, and sets up the pins and frequencies for the state machines.",Legacy COBOL logic requiring documentation.,Irrelevant,True,"The code presented is written in Python and assembly languages, not in COBOL as stated in the generated documentation.",0.0044608951829991,0.8538552522659302
cob_real_580,COBOL,"        >> source format is free
program-id. sysserialup.
*> System file maintenance
options.
  default rounded mode is nearest-even *> use banker's
  entry-convention is cobol
  .
environment division.
configuration section.
source-computer. Linux.
object-computer. Linux.
special-names.
  numeric sign is trailing separate
  .
repository.
  function upper-case intrinsic.
input-output section.
file-control.
copy ""system-sel.cpy"".
data division.
file section.
copy ""system-fd.cpy"".
working-storage section.
01  ws-program-name   pic x(21)  value ""sysserialup (0.01.01)"".

01  ws-old-save-area.
  05  old-invoicing   pic 9.
  05  old-stock       pic 9.
  05  old-OE          pic 9.
  05  old-EPOS        pic 9.
  05  old-Payroll     pic 9.
  05  old-Project-Z   pic 9.
  05  wsmaps-ser.
    10  wsmaps-ser-xx pic xx.
    10  wsmaps-ser-nn pic 9(4).
  05  usera pic x(32).
01  pass-name pic x(32).

01  system-record-1.
  05  maps-serial-data.
    10  maps-ser-xx pic xx.
    10  maps-ser-nn pic 9(4).
copy ""version-ws.cpy"".
copy ""system-ws.cpy"".
01  relative-record-number pic 999.
01  file-status pic xx.

01  ws-user-credentials.
  05  encode-switch   pic x.
    88  pass                  value ""P"".
    88  user                  value ""N"".
  05  pass-code       pic x(16).
  05  user-name       pic x(32).

procedure division.
main-begin.
  perform opening-paragraph
  perform main-process
  perform closing-paragraph
  .
main-exit.
  goback
  .
opening-paragraph.
  *> Force Esc, PgUp, PgDown, PrtSC to be detected
  set environment ""COB_SCREEN_EXCEPTIONS"" to ""Y""
  set environment ""COB_SCREEN_ESC"" to ""Y""
  set environment ""COB_EXIT_WAIT""  to ""N""
  perform display-do-not-issue

  open i-o system-file
  if file-status not = zero
    display ""No system file found to update"" at 1001 with foreground-color 2 end-display
    display ""Hit return to exit"" at 1101    with foreground-color 2 end-display
    accept omitted at 1120 end-accept
    close system-file
    goback
  end-if
  move 1 to rel","This COBOL program is designed to perform system file maintenance. It opens the system file for input-output operations, checks for the existence of the file, and prompts the user if the file is not found. The program includes handling of user credentials and specific screen exceptions.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the main functionality of the source code.,0.0065056119086392495,0.8695194125175476
cob_syn_7578,COBOL,"      * REFACTOR CANDIDATE BATCH_7578
      * SYSTEM GENERATED
********
********  EMPLOYEE RECORD WORK-AREA.  EMPLOYEE DATA IS REDEFINED
********  BASED ON ONE OF THE 3 EMPLOYEE TYPES, HOURLY, SALES OR
********  MANAGEMENT.
********
       01  EMPLOYEE-WORK-AREA.
           05  WA-EMP-NUM            PIC 9(5).
           05  WA-EMP-TYPE           PIC X.
               88  HOURLY            VALUE 'H'.
               88  SALES             VALUE 'S'.
               88  MANAGEMENT        VALUE 'M'.
           05  WA-EMP-REGION         PIC 9.
               88  NORTH             VALUE 1.
               88  SOUTH             VALUE 2.
               88  EAST              VALUE 3.
               88  WEST              VALUE 4.
           05  WA-EMP-NAME           PIC X(15).
           05  WA-EMP-ADDRESS.
               10  WA-EMP-STREET     PIC X(15).
               10  WA-EMP-CITY       PIC X(8).
               10  WA-EMP-STATE      PIC XX.
               10  WA-EMP-ZIP        PIC X(9).
           05  WA-HOURLY-EMPLOYEE-DATA.
               10  WA-EMP-HOURS      PIC 9(2).
               10  WA-EMP-RATE       PIC 9(3)V99     COMP-3.
               10  FILLER            PIC X(8).
           05  WA-SALES-EMPLOYEE-DATA   REDEFINES
                                        WA-HOURLY-EMPLOYEE-DATA.
               10  WA-SALES-SALARY   PIC 9(5)V99     COMP-3.
               10  WA-SALES-AMOUNT   PIC 9(5)V99.
               10  FILLER            PIC X(2).
           05  WA-MGMT-EMPLOYEE-DATA   REDEFINES
                                        WA-SALES-EMPLOYEE-DATA.
               10  WA-MGMT-SALARY    PIC 9(5)V99     COMP-3.
               10  FILLER            PIC X(9).
           05  WA-EMP-HIRE-DATE.
               10  WA-EMP-HIRE-YY    PIC 9(2).
               10  WA-EMP-HIRE-MM    PIC 9(2).
               10  WA-EMP-HIRE-DD    PIC 9(2).
           05  FILLER                PIC X(5).","Defines an employee record work-area in COBOL that can hold data for employees of three different types: hourly, sales, or management. It includes fields for employee number, type, region, name, address, specific data for each employee type (such as hours and rate for hourly employees, salary for sales employees, and salary for management employees), and hire date. The structure uses redefinition for the different types of employee data to efficiently store and access information based on the employee type.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention the purpose of the field with pic X(5) labeled 'FILLER'.,0.004123736633351873,0.8420133590698242
py_13338,Python,"def get_mtime(fname):
        """"""
        Find the time this file was last modified.

        :param fname: File name
        :return: The last time the file was modified.
        """"""
        try:
            mtime = os.stat(fname).st_mtime_ns
        except OSError:
            # The file might be right in the middle of being written
            # so sleep
            time.sleep(1)
            mtime = os.stat(fname).st_mtime_ns

        return mtime","Find the time this file was last modified.

:param fname: File name
:return: The last time the file was modified.","Find the time this file was last modified.

        :param fname: File name
        :return: The last time the file was modified.",Omission,True,"The documentation does not describe the exception handling process, specifically what happens when an OSError occurs.",1.0,0.9141852855682373
py_6239,Python,"def create_vars_from_data(self, dataset, split=""train""):
        """"""
        Create vars given a dataset and set test values.
        Useful when dataset is already defined.
        """"""
        from deepy.core.neural_var import NeuralVariable
        vars = []
        if split == ""valid"":
            data_split = dataset.valid_set()
        elif split == ""test"":
            data_split = dataset.test_set()
        else:
            data_split = dataset.train_set()
        first_data_piece = list(data_split)[0]
        for i, numpy_tensor in enumerate(first_data_piece):
            if numpy_tensor.dtype == ""int64"":
                numpy_tensor = numpy_tensor.astype(""int32"")
            if numpy_tensor.dtype == ""float64"":
                numpy_tensor = numpy_tensor.astype(env.FLOATX)
            type_map = {
                0: ""scalar"",
                1: ""vector"",
                2: ""matrix"",
                3: ""tensor3"",
                4: ""tensor4"",
                5: ""tensor5"",
            }
            tensor_type = type_map[numpy_tensor.ndim] if numpy_tensor.ndim in type_map else type_map[0]
            if numpy_tensor.dtype.kind == ""i"":
                tensor_type = ""i"" + tensor_type
            theano_tensor = getattr(TT, tensor_type)(""input_{}_{}"".format(i + 1, tensor_type))
            last_dim = numpy_tensor.shape[-1]
            var = NeuralVariable(theano_tensor, dim=last_dim)
            var.set_test_value(numpy_tensor)
            vars.append(var)
        return vars",Create vars given a dataset and set test values. Useful when dataset is already defined.,"Create vars given a dataset and set test values.
        Useful when dataset is already defined.",No Error,False,The generated documentation accurately describes the function's behavior. There are no hallucinations or omissions.,1.0,0.9460418224334717
py_3090,Python,"def get_event_descriptions(self, event_name=None):
        """"""
        Get the thing's events as an array.

        event_name -- Optional event name to get descriptions for

        Returns the event descriptions.
        """"""
        if event_name is None:
            return [e.as_event_description() for e in self.events]
        else:
            return [e.as_event_description()
                    for e in self.events if e.get_name() == event_name]","Get the thing's events as an array.

event_name -- Optional event name to get descriptions for

Returns the event descriptions.","Get the thing's events as an array.

        event_name -- Optional event name to get descriptions for

        Returns the event descriptions.",No Error,False,The documentation accurately represents what the code is doing.,1.0,0.9241616129875183
py_3176,Python,"def __fetch_merge_requests(self, from_date):
        """"""Fetch the merge requests""""""

        merges_groups = self.client.merges(from_date=from_date)

        for raw_merges in merges_groups:
            merges = json.loads(raw_merges)
            for merge in merges:
                merge_id = merge['iid']

                if self.blacklist_ids and merge_id in self.blacklist_ids:
                    logger.warning(""Skipping blacklisted merge request %s"", merge_id)
                    continue

                # The single merge_request API call returns a more
                # complete merge request, thus we inflate it with
                # other data (e.g., notes, emojis, versions)
                merge_full_raw = self.client.merge(merge_id)
                merge_full = json.loads(merge_full_raw)

                self.__init_merge_extra_fields(merge_full)

                merge_full['notes_data'] = self.__get_merge_notes(merge_id)
                merge_full['award_emoji_data'] = self.__get_award_emoji(GitLabClient.MERGES, merge_id)
                merge_full['versions_data'] = self.__get_merge_versions(merge_id)

                yield merge_full","Fetches merge requests from a GitLab instance using the GitLab API. It filters out any blacklisted merge requests based on provided IDs. Each merge request is then enriched with additional data such as notes, emojis, and versions before yielding the complete merge request data.",Fetch the merge requests,No Error,False,The documentation perfectly aligns with the given source code with no omissions or hallucinations.,0.016023990943264246,0.8517142534255981
cob_syn_2711,COBOL,"      * REFACTOR CANDIDATE BATCH_2711
      * SYSTEM GENERATED
*>---------------
*> system-sel.cpy
*>---------------
  select system-file
    assign to ""system.dat""
    organization is sequential
    file status is file-status
    .
","This COBOL code defines a file structure for a file named ""system.dat"" that will be accessed sequentially. It declares a SELECT statement for the file called ""system-file"" with an assignment to the physical file named ""system.dat"" and specifies that the organization of the file is sequential. The file status will be stored in the variable ""file-status"".",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately explains the COBOL code.,0.005514743143838301,0.8562746047973633
py_14124,Python,"def show_exception_only(self, etype, evalue):
        """"""Only print the exception type and message, without a traceback.

        Parameters
        ----------
        etype : exception type
        value : exception value
        """"""
        # This method needs to use __call__ from *this* class, not the one from
        # a subclass whose signature or behavior may be different
        ostream = self.ostream
        ostream.flush()
        ostream.write('\n'.join(self.get_exception_only(etype, evalue)))
        ostream.flush()","Only print the exception type and message, without a traceback.","Only print the exception type and message, without a traceback.

        Parameters
        ----------
        etype : exception type
        value : exception value",Omission,True,The documentation omitted an explanation of the function's internal behavior and the parameters etype and evalue are not properly described.,0.36787944117144233,0.83896803855896
py_11609,Python,"def iter_resource(filename):
    """"""
    Return a stream for a given resource file in the module.

    The resource file has to be part of the module and its filenane given
    relative to the module.
    """"""
    with pkg_resources.resource_stream(__name__, filename) as resource:
        for line in resource:
            yield line.decode('utf-8')",Return a stream for a given resource file in the module. The resource file has to be part of the module and its filename given relative to the module.,"Return a stream for a given resource file in the module.

    The resource file has to be part of the module and its filenane given
    relative to the module.",No Error,False,The provided documentation accurately describes the function's behavior and does not make unsupported claims.,0.9061874434879645,0.9427371621131897
py_13879,Python,"def n_digit_freqs(digits, n, normalize=False):
    """"""
    Consume digits of pi and compute n digits freq. counts.

    This should only be used for 1-6 digits.
    """"""
    freqs = np.zeros(pow(10,n), dtype='i4')
    current = np.zeros(n, dtype=int)
    for i in range(n):
        current[i] = digits.next()
    for d in digits:
        index = int(''.join(map(str, current)))
        freqs[index] += 1
        current[0:-1] = current[1:]
        current[-1] = d
    if normalize:
        freqs = freqs/freqs.sum()
    return freqs","""""""
Consume digits of pi and compute the frequency counts of n consecutive digits.

This function is designed for processing digits of pi and computing frequency counts of n consecutive digits. It is optimized for processing 1 to 6 digits. If the 'normalize' parameter is set to True, the function will normalize the frequency counts. 
""""""","Consume digits of pi and compute n digits freq. counts.

    This should only be used for 1-6 digits.",No Error,False,The generated documentation accurately represents the function of the source code.,0.0950666165752572,0.8751571178436279
py_13470,Python,"def _find_link(inst1, inst2, rel_id, phrase):
    '''
    Find links that correspond to the given arguments.
    '''
    metaclass1 = get_metaclass(inst1)
    metaclass2 = get_metaclass(inst2)

    if isinstance(rel_id, int):
        rel_id = 'R%d' % rel_id
        
    for ass in metaclass1.metamodel.associations:
        if ass.rel_id != rel_id:
            continue

        if (ass.source_link.from_metaclass.kind == metaclass1.kind and
            ass.source_link.to_metaclass.kind == metaclass2.kind and
            ass.source_link.phrase == phrase):
            return inst1, inst2, ass

        if (ass.target_link.from_metaclass.kind == metaclass1.kind and
            ass.target_link.to_metaclass.kind == metaclass2.kind and
            ass.target_link.phrase == phrase):
            return inst2, inst1, ass

    raise UnknownLinkException(metaclass1.kind, metaclass2.kind, rel_id, phrase)",Find links that correspond to the given arguments.,Find links that correspond to the given arguments.,No Error,False,The documentation correctly describes the functionality of the source code and includes all necessary information. No missing claims or hallucinations.,1.0,0.9999999403953552
cob_real_385,COBOL,"       fd   pd00100.
       
       01   f00100-modulos.
            03 f00100-cd-empresa                   pic 9(03).
            03 f00100-cd-filial                    pic 9(04).
            03 f00100-programa-principal           pic x(08).
            03 f00100-cd-programa                  pic x(08).
            03 f00100-tipo-programa                pic x(01).
               88 f00100-programa-logico                value ""L"".
               88 f00100-programa-fisico                value ""F"".
            03 f00100-operacao-programa            pic 9(02).
            03 f00100-descricao-programa           pic x(55). 
      


","Defines a file description (FD) for a file named PD00100. This file contains records with fields related to program modules. Each record includes fields for company code, branch code, main program name, program code, program type (logical or physical), program operation, and program description.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately represents the associated source code without any omissions or unsupported claims.,0.0,0.8292767405509949
cob_syn_9424,COBOL,"      * REFACTOR CANDIDATE BATCH_9424
      * SYSTEM GENERATED
   CBL NUMPROC(MIG),FLAG(I,W),RENT
       ID DIVISION.
       PROGRAM-ID. EPSMPMT.
      *    THIS IS A CALLED PROGRAM EXAMPLE FOR DEMONSTRATION
      *
      *    THIS PROGRAM WILL BE CALLED BY ANOTHER, RECEIVE
      *    THE FOLLOWING INFOMATION AND RETURN A MONTLY PAYMENT AMOUNT
      *    INPUT:
      *       ORIGINAL PRINCIPLE AMOUNT
      *       YEARS OR MONTH INDICATOR
      *       NUMBER OF YEARS
      *       NUMBER OF MONTHS
      *       INTEREST RATE
      *    OUTPUT:
      *       MONTHLY PAYMENT
      *
      *    (C) 2008 IBM - Jim Hildner
      *    SAJ 2 3 4
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER. FLEX-ES.
       OBJECT-COMPUTER. FLEX-ES.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
      *
       01 WS-STATIC-DATA.
           03 STATIC-MAXIMUM-PRINCIPLE    PIC 9(9)V99
                                VALUE 100000000.01.
           03 STATIC-ERRORS.
              05 FILLER                  PIC 99 VALUE 1.
              05 FILLER                  PIC X(80)
              VALUE 'PRINCIPLE AMOUNT IS NEGATIVE'.
              05 FILLER                  PIC 99 VALUE 2.
              05 FILLER                  PIC X(80)
              VALUE 'PRINCIPLE EXCEEDED MAXIMUM AMOUNT'.
              05 FILLER                  PIC 99 VALUE 3.
              05 FILLER                  PIC X(80)
              VALUE 'NEGATIVE INTEREST RATE'.
              05 FILLER                  PIC 99 VALUE 4.
              05 FILLER                  PIC X(80)
              VALUE 'YEARS INDICATED, BUT YEARS ZERO OR LESS'.
              05 FILLER                  PIC 99 VALUE 5.
              05 FILLER                  PIC X(80)
              VALUE 'ZERO OR LESS MONTHS'.
              05 FILLER                  PIC 99 VALUE 6.
              05 FILLER                  PIC X(80)
              VALUE ' '.
              05 FILLER                  PIC 99 VALUE 7.
              05 FILLER                  PIC X(80)
              VALUE ' '.
","This COBOL program is a called program that calculates a monthly payment amount based on input data including the original principal amount, indicator for years or months, number of years, number of months, and interest rate. It defines static data for maximum principal amount and error messages for negative values or invalid input.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the purpose and function of the COBOL program as indicated in the source code.,0.005776163584689931,0.8535411953926086
cob_syn_5008,COBOL,"      * REFACTOR CANDIDATE BATCH_5008
      * SYSTEM GENERATED
       identification division.
       program-id. condition_statements_08.

       data division.
       working-storage section.
       01 ws-a pic 9 value 0.

       procedure division.
           move 3 to ws-a.

           evaluate true
              when ws-a > 2
                 display 'ws-a greater than 2'

              when ws-a < 0
                 display 'ws-a less than 0'

              when other
                 display 'invalid value of ws-a'
           end-evaluate.

           stop run.
","This COBOL program declares a working storage variable `ws-a` and assigns it the value of 3. It then uses an `evaluate` statement to check the value of `ws-a` against different conditions. If `ws-a` is greater than 2, it displays 'ws-a greater than 2'. If `ws-a` is less than 0, it displays 'ws-a less than 0'. If neither condition is met, it displays 'invalid value of ws-a'. Finally, the program stops execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the source code without any hallucinations or omissions.,0.00451399365518933,0.8336125016212463
py_1775,Python,"def merge(
            self, reservation_order_id, sources=None, custom_headers=None, raw=False, polling=True, **operation_config):
        """"""Merges two `Reservation`s.

        Merge the specified `Reservation`s into a new `Reservation`. The two
        `Reservation`s being merged must have same properties.

        :param reservation_order_id: Order Id of the reservation
        :type reservation_order_id: str
        :param sources: Format of the resource id should be
         /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
        :type sources: list[str]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: The poller return type is ClientRawResponse, the
         direct response alongside the deserialized response
        :param polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :return: An instance of LROPoller that returns list or
         ClientRawResponse<list> if raw==True
        :rtype:
         ~msrestazure.azure_operation.AzureOperationPoller[list[~azure.mgmt.reservations.models.ReservationResponse]]
         or
         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[list[~azure.mgmt.reservations.models.ReservationResponse]]]
        :raises:
         :class:`ErrorException<azure.mgmt.reservations.models.ErrorException>`
        """"""
        raw_result = self._merge_initial(
            reservation_order_id=reservation_order_id,
            sources=sources,
            custom_headers=custom_headers,
            raw=True,
            **operation_config
        )

        def get_long_running_output(response):
            deserialized = self._deserialize('[ReservationResponse]', response)

            if raw:
                client_raw_response = ClientRawResponse(deserialized, response)
                return client_raw_response

            return deserialized

        lro_delay = operation_config.get(
            'long_running_operation_timeout',
            self.config.long_running_operation_timeout)
        if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)","Merges two `Reservation`s by creating a new `Reservation` that combines the properties of the two input reservations. The reservations to be merged must have the same properties.

- `reservation_order_id`: Order Id of the reservation.
- `sources`: List of resource ids in a specific format.
- `custom_headers`: Headers to be included in the request.
- `raw`: Determines the return type of the poller.
- `polling`: Specifies the polling strategy for the operation.
- Returns an `LROPoller` instance that returns either a list of `ReservationResponse` objects or a `ClientRawResponse` containing the deserialized response if `raw` is set to True.

Raises an `ErrorException` if an error occurs during the operation.","Merges two `Reservation`s.

        Merge the specified `Reservation`s into a new `Reservation`. The two
        `Reservation`s being merged must have same properties.

        :param reservation_order_id: Order Id of the reservation
        :type reservation_order_id: str
        :param sources: Format of the resource id should be
         /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
        :type sources: list[str]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: The poller return type is ClientRawResponse, the
         direct response alongside the deserialized response
        :param polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :return: An instance of LROPoller that returns list or
         ClientRawResponse<list> if raw==True
        :rtype:
         ~msrestazure.azure_operation.AzureOperationPoller[list[~azure.mgmt.reservations.models.ReservationResponse]]
         or
         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[list[~azure.mgmt.reservations.models.ReservationResponse]]]
        :raises:
         :class:`ErrorException<azure.mgmt.reservations.models.ErrorException>`",No Error,False,"The generated documentation accurately describes the purpose, input parameters, return type, and potential exceptions of the merge method per the source code.",0.0686568757834482,0.8169353604316711
cob_syn_3182,COBOL,"      * REFACTOR CANDIDATE BATCH_3182
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      *                                                                *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2019 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                   Inquire Policy                               *
      *  Business logic for policy inquire                             *
      *   To obtain full details of an individual policy:              *
      *     Endowment, House or Motor  NJL   v6                        *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGIPOL01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *----------------------------------------------------------------*
      * Common defintions                                              *
      *----------------------------------------------------------------*
      * Run time (debug) infomation for this invocation
        ","This COBOL program named LGIPOL01 is designed to handle business logic for policy inquiries. It allows users to retrieve full details of individual policies such as Endowment, House, or Motor using the NJL v6 system.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the purpose and workings of the program as stated in the code comments.,0.009723975927788436,0.8699589967727661
cob_syn_2530,COBOL,"      * REFACTOR CANDIDATE BATCH_2530
      * SYSTEM GENERATED
      ******************************************************************
      * Copyright 2014 IBM Corp. All Rights Reserved.
      *
      * Licensed under the Apache License, Version 2.0 (the ""License"");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
      * either express or implied.
      * See the License for the specific language governing permissions
      * and limitations under the License.
      ******************************************************************

      *                                                                *
      *                    Patient thresholds                          *
      *                                                                *
      * Menu for Patient thresholds                                    *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HCT1PL01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       77 INQ-TRANS                    PIC X(4) VALUE 'HCT1'.
       77 ADD-TRANS                    PIC X(4) VALUE 'HCTA'.
       77 MSGEND                       PIC X(24) VALUE
                                        'Transaction ended      '.
       01  WS-RESP                   PIC S9(8) COMP.

        COPY HCMAPS.
        01 COMM-AREA.
        COPY HCCMAREA.

      *--","This COBOL program defines patient thresholds and provides a menu for interacting with these thresholds. It declares variables for transaction codes, messages, and response codes. It includes copies of external files for maps and communication areas.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the functions and variables declared in the given COBOL program code.,0.007986728673290205,0.8757281303405762
cob_syn_2292,COBOL,"      * REFACTOR CANDIDATE BATCH_2292
      * SYSTEM GENERATED
      ****************************************************************************
      *                                                                          *
      * Copyright 2018 ABSA Group Limited                                        *
      *                                                                          *
      * Licensed under the Apache License, Version 2.0 (the ""License"");          *
      * you may not use this file except in compliance with the License.         *
      * You may obtain a copy of the License at                                  *
      *                                                                          *
      *     http://www.apache.org/licenses/LICENSE-2.0                           *
      *                                                                          *
      * Unless required by applicable law or agreed to in writing, software      *
      * distributed under the License is distributed on an ""AS IS"" BASIS,        *
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
      * See the License for the specific language governing permissions and      *
      * limitations under the License.                                           *
      *                                                                          *
      ****************************************************************************

      ****** Names, Ids and values in this example are completely fictional and
      ****** were generated randomly. Any resemblance to actual persons or companies
      ****** or actual transactions is purely coincidental.

        01  TRANSDATA.
            05  CURRENCY          PIC X(3).
            05  SIGNATURE         PIC X(8).
            05  COMPANY-NAME-NP      PIC X(15).
            05  COMPIANY-ID       PIC X(10).
            05  WEALTH-QFY        PIC 9(1).
            05  AMOUNT            PIC S9(09)V99  BINARY.
            
","This COBOL code defines a data structure named TRANSDATA with fields for currency, signature, company name, company ID, wealth quantity, and amount. The fields are defined with specific lengths and formats using PIC clauses. The code also includes licensing information and a disclaimer at the beginning.",Legacy COBOL logic requiring documentation.,Fabricated Variable,True,"The documentation erroneously mentions a ""company name"" field which is not present in the code.",0.0065056119086392495,0.8648277521133423
py_3224,Python,"def reviews(self, last_item, filter_=None):
        """"""Get the reviews starting from last_item.""""""

        cmd = self._get_gerrit_cmd(last_item, filter_)

        logger.debug(""Getting reviews with command: %s"", cmd)
        raw_data = self.__execute(cmd)
        raw_data = str(raw_data, ""UTF-8"")

        return raw_data",Get the reviews starting from the specified last_item.,Get the reviews starting from last_item.,Omission,True,The documentation does not mention about the 'filter_' parameter and its use in the function.,0.5410822690539396,0.9681668281555176
py_1986,Python,"def mnemonic(self, index):
        """"""Make a nice mnemonic
        """"""
        i,c,d0 = self.splitSymbol(index)
        iLower, _ = i.code.span(i.index)
        iExtra = i.extraBits()
        cLower, _ = c.code.span(c.index)
        cExtra = c.extraBits()
        return 'I{}{}{}C{}{}{}{}'.format(
            iLower,
            '+' if iExtra else '',
            'x'*iExtra if iExtra<6 else '[{}*x]'.format(iExtra),
            cLower,
            '+' if cExtra else '',
            'x'*cExtra if cExtra<6 else '[{}*x]'.format(cExtra),
            '&D=0' if d0 else '')","Generate a mnemonic based on the given index, incorporating information from splitSymbol into the mnemonic template. The mnemonic includes formatted representations of different parts of the index, such as lowercase versions, extra bits denoted by 'x's or a number in brackets, and a flag for 'D=0'.",Make a nice mnemonic,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.007736519969200231,0.8535476326942444
py_13193,Python,"def asAMP(cls):
        """"""
        Returns the exception's name in an AMP Command friendly format.

        For example, given a class named ``ExampleExceptionClass``, returns
        ``""EXAMPLE_EXCEPTION_CLASS""``.
        """"""
        parts = groupByUpperCase(cls.__name__)
        return cls, ""_"".join(part.upper() for part in parts)",Returns the exception's name in an AMP Command friendly format by splitting the class name based on uppercase letters and joining the parts with underscores in uppercase.,"Returns the exception's name in an AMP Command friendly format.

        For example, given a class named ``ExampleExceptionClass``, returns
        ``""EXAMPLE_EXCEPTION_CLASS""``.",Wrong Logic,True,"The documentation claims that the function returns the modified class name only, but the function actually returns a tuple containing the class and the modified class name.",0.2988565156407745,0.8322470784187317
cob_syn_4980,COBOL,"      * REFACTOR CANDIDATE BATCH_4980
      * SYSTEM GENERATED
       01  X PIC 9.
           88 X-Is-One        VALUE 1.
           88 X-Is-Even       VALUE 0 2 4 6 8.
           88 X-Larger-Than-5 VALUE 6 THRU 9.
","Defines a variable `X` of type numeric with one decimal digit. Three condition indicators are associated with `X`: `X-Is-One` is true if `X` has a value of 1, `X-Is-Even` is true if `X` has a value of 0, 2, 4, 6, or 8, and `X-Larger-Than-5` is true if `X` has a value in the range of 6 to 9 (inclusive).",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the source code.,0.0,0.8109809160232544
py_11118,Python,"def from_json(self):
        '''
        Reads dataset from json.
        '''
        with gzip.open('%s.gz' % self.path,
                       'rt') if self.gz else open(self.path) as file:
            return list(map(list, zip(*json.load(file))))[::-1]","Reads dataset from json file, unzips the file if it is gzipped, and returns the dataset as a list of lists with the rows reversed.",Reads dataset from json.,No Error,False,The documentation accurately describes what the code does.,0.05022135506220879,0.8908441066741943
cob_syn_7351,COBOL,"      * REFACTOR CANDIDATE BATCH_7351
      * SYSTEM GENERATED
IDENTIFICATION DIVISION.
PROGRAM-ID. HELLO-WORLD.
AUTHOR. Kevin Roper.
INSTALLATION. KEYHOLE HQ.
DATE-WRITTEN. 05/15/20.

DATA DIVISION.
WORKING-STORAGE SECTION.
01 COUNTER  PIC 9(3) VALUE IS 0.
01 DEMO-A   PIC S9(2)V9(2) VALUE IS 99.

01 DEMO-B   PIC S9(2)V9(3) VALUE IS 1.25.
88 ACCEPTABLE VALUES ARE 1 THRU 10.
88 UNACCEPTABLE VALUES ARE 12 THRU 20.

01 DEMO-C   PIC S9(3)V9(9).
01 HDR      PIC A(8) VALUE IS ""OUTPUT"".
01 DVDR     PIC X(8) VALUE IS ""--------"".

01 POINT-A.
  02 X      PIC 9(2) VALUE IS 1.
  02 Y      PIC 9(2) VALUE IS 2.

01 POINT-B.
  03 X      PIC 9(2) VALUE IS 8.
  03 Y      PIC 9(2) VALUE IS 9.

01 DBTABLE.
  04 DBTABLE-ROW OCCURS 10 TIMES.
    10 DBTABLE-ROWVAL PIC A(10) VALUE 'ROW'.
    10 DBTABLE-COL OCCURS 10 TIMES.
      15 DBTABLE-COLVAL PIC 9(3) VALUE 100.

PROCEDURE DIVISION.
DISPLAY 'Hello, world3'.
DISPLAY HDR.
DISPLAY 'A='DEMO-A.
DISPLAY 'B='DEMO-B.
DISPLAY DVDR.
DISPLAY X IN POINT-A.
DISPLAY X IN POINT-B.
DISPLAY DVDR.
MOVE X IN POINT-A TO X IN POINT-B.
DISPLAY X IN POINT-B.
DISPLAY DVDR.
ADD DEMO-A DEMO-B GIVING DEMO-C.
DISPLAY DEMO-C.
SUBTRACT Y IN POINT-B FROM DEMO-C GIVING DEMO-A.
DISPLAY DEMO-A.
COMPUTE DEMO-A=(DEMO-B * 3).
DISPLAY DEMO-A.
DISPLAY DVDR.
DISPLAY DEMO-A.
DISPLAY DEMO-B.
IF DEMO-A IS GREATER THAN DEMO-B THEN
  DISPLAY 'A IS GREATER THAN B'
ELSE
  DISPLAY 'B IS GREATER THAN A'
END-IF.
DISPLAY DVDR.
MULTIPLY DEMO-B BY 12 GIVING DEMO-B.
DISPLAY DEMO-B.
IF ACCEPTABLE
  DISPLAY 'ACCEPTABLE: ' DEMO-B.
IF UNACCEPTABLE
  DISPLAY 'UNACCEPTABLE: ' DEMO-B.

PERFORM ROUTINE-A UNTIL COUNTER IS EQUAL TO 5.
DISPLAY DVDR.
PERFORM ROUTINE-A 10 TIMES.
DISPLAY DVDR.
PERFORM ROUTINE-B VARYING COUNTER FROM 0 BY 1 UNTIL COUNTER=10
MOVE 2 TO COUNTER.
GO TO ROUTINE-C ROUTINE-D ROUTINE-E DEPENDING ON COUNTER.

ROUTINE-C.
DISPLAY DVDR.
DISPLAY 'C'.
GO TO ROUTINE-F.

ROUTINE-D.
DISPLAY DVDR.
DISPLAY 'D'.
GO TO ROUTINE-F.

ROUTINE-E.
DISPLAY DVDR.
DISPLAY 'E'.
GO TO ROUTINE-F.

ROUTINE-F.
DISPLAY 'DBTABLE: ' DBTABLE.
DISPLAY 'STUDENT 1, GRADE ","This COBOL program is a demonstration of various operations such as arithmetic calculations, conditional statements, looping structures, and subroutine calls. It defines and manipulates different data types including integers and decimal numbers, and performs operations like addition, subtraction, multiplication, and comparison. The program also includes a table data structure and uses DISPLAY statements to output messages to the console. Additionally, it contains a set of routines labeled A to F, with branching logic based on a counter variable. It ends abruptly with an incomplete DISPLAY statement referencing a student and grade, suggesting unfinished code.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not cover how the system handles UNACCEPTABLE and ACCEPTABLE values and does not mention the purpose of 'DBTABLE' in the code. Furthermore, ROUTINE-A and ROUTINE-B are not explained in the document. Also, the document fails to flag that generated codes are abruptly terminated, which will impede its execution.",0.0042306118714881364,0.8559049367904663
cob_syn_9353,COBOL,"      * REFACTOR CANDIDATE BATCH_9353
      * SYSTEM GENERATED
 ---- helloworld.cob -------------------------
       * Sample COBOL program
        IDENTIFICATION DIVISION.
        PROGRAM-ID. hello-world.
        PROCEDURE DIVISION.
        DISPLAY ""Hello World!"".
        STOP RUN.
 ----------------------------------------","This COBOL program is a simple ""Hello World"" program. It displays the message ""Hello World!"" on the output screen and then stops the program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly represents the code's functionality.,0.011199617145528714,0.8747056722640991
py_3580,Python,"def attach(word, josa=EUN_NEUN):
    """"""add josa at the end of this word""""""
    last_letter = word.strip()[-1]
    try:
        _, _, letter_jong = letter.decompose(last_letter)
    except NotHangulException:
        letter_jong = letter.get_substituent_of(last_letter)

    if letter_jong in ('', josa['except']):
        return word + josa['has']

    return word + josa['not']",add josa at the end of this word,add josa at the end of this word,No Error,False,"The documentation correctly describes the function of the code, which is to add josa at the end of a given word.",1.0,1.0
py_8147,Python,"def _resolve_option(self, options, option_name, section_name):
        """"""Resolves an option value into options.

        Sets options.<option_name> to a resolved value. Any value
        already in options overrides a value in os.environ which
        overrides self.context.conf.

        :param options: The options instance as returned by optparse.
        :param option_name: The name of the option, such as
            ``auth_url``.
        :param section_name: The name of the section, such as
            ``swiftly``.
        """"""
        if getattr(options, option_name, None) is not None:
            return
        if option_name.startswith(section_name + '_'):
            environ_name = option_name.upper()
            conf_name = option_name[len(section_name) + 1:]
        else:
            environ_name = (section_name + '_' + option_name).upper()
            conf_name = option_name
        setattr(
            options, option_name,
            os.environ.get(
                environ_name,
                (self.context.conf.get(section_name, {})).get(conf_name)))","Resolves an option value into options by setting options.<option_name> to a resolved value. If the value is already in options, it overrides any corresponding value in os.environ, which in turn overrides the value in self.context.conf.

:param options: The options instance as returned by optparse.
:param option_name: The name of the option, such as ``auth_url``.
:param section_name: The name of the section, such as ``swiftly``.","Resolves an option value into options.

        Sets options.<option_name> to a resolved value. Any value
        already in options overrides a value in os.environ which
        overrides self.context.conf.

        :param options: The options instance as returned by optparse.
        :param option_name: The name of the option, such as
            ``auth_url``.
        :param section_name: The name of the section, such as
            ``swiftly``.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.6028577002593477,0.8768786787986755
py_6278,Python,"def expire_soon(self, seconds):
        """"""
        Returns ``True`` if credentials expire sooner than specified.

        :param int seconds:
            Number of seconds.

        :returns:
            ``True`` if credentials expire sooner than specified,
            else ``False``.

        """"""

        if self.expiration_time:
            return self.expiration_time < int(time.time()) + int(seconds)
        else:
            return False","""""""
Returns ``True`` if credentials expire sooner than specified.

:param int seconds:
    Number of seconds.

:returns:
    ``True`` if credentials expire sooner than specified,
    else ``False``.
""""""","Returns ``True`` if credentials expire sooner than specified.

        :param int seconds:
            Number of seconds.

        :returns:
            ``True`` if credentials expire sooner than specified,
            else ``False``.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.9181891462193902,0.9295503497123718
py_6232,Python,"def _run_train(self, epoch, train_set, train_size=None):
        """"""
        Run one training iteration.
        """"""
        self.network.train_logger.record_epoch(epoch + 1)
        costs = self.train_step(train_set, train_size)
        if not epoch % self.config.monitor_frequency:
            self.report(dict(costs), ""train"", epoch)
        self.last_run_costs = costs
        return costs",Run one training iteration.,Run one training iteration.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,1.0
cob_real_2655,COBOL,"       ID Division.
      * 
      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.
      * 
      * I accept no liability for damages of any kind resulting 
      * from the use of this software.  Use at your own risk.
      *
      * This software may be modified and distributed under the terms
      * of the MIT license. See the LICENSE file for details.
      *
      *
       Program-ID. cs08a.
       Environment Division.
       Input-Output Section.
       File-Control.
           Select INPT-DATA            Assign Keyboard.
       Data Division.
       File Section.
       FD  INPT-DATA.
       01  INPT-DATA-REC-MAX PIC X(4096).

       Working-Storage Section.
       01  CONSTANTS.
           05  MYNAME             PIC X(008) VALUE 'cs08a'.

       01  WORK-AREAS.
           05  WS-REC-COUNT       PIC 9(009) COMP    VALUE 0.
           05  ENTRY-COUNT        PIC 9(009) COMP    VALUE 0.
           05  UNSTRING-PTR       PIC 9(009) COMP    VALUE 0.
           05  SEGMENT-COUNT      PIC 9(009) COMP    VALUE 0.
           05  UNIQUE-COUNT       PIC 9(009) COMP    VALUE 0.
           05  PROCESS-TYPE       PIC X(004)         VALUE LOW-VALUES.
           05  IN-SIGNAL-PATTERNS PIC X(060)         VALUE SPACES.
           05  IN-FOUR-DIGITS     PIC X(032)         VALUE SPACES.

       01  WS-INPT-DATA.
           05  WS-INPT            PIC X(4096)        VALUE SPACES.

       01  SWITCHES.
           05  INPT-DATA-EOF-SW   PIC X(001)         VALUE 'N'.
               88  INPT-DATA-EOF                     VALUE 'Y'.
           05  PROCESS-SW         PIC X(004)         VALUE LOW-VALUES.
               88  PROCESS-TEST                      VALUE 'TEST'.

       01  ENTRY-TABLE.
           05  ENTRY-TBL
               OCCURS 200
               INDEXED ENTRY-INDX.
               10  SIGNAL-PATTERN
                   OCCURS 10
                   INDEXED SIGNAL-INDX
                   PIC X(008).
               10  DIGIT
                   OCCURS 4
         ","This COBOL program defines data structures and file controls for processing input data from the keyboard. It initializes various working storage fields and switches, reads input data into memory, and processes it based on predefined patterns and digits. The program loops through the input data until reaching the end-of-file marker.",Legacy COBOL logic requiring documentation.,Hallucination,True,The documentation claims the code reads and processes input data but the code provided doesn't perform these actions.,0.006065997938636506,0.8601565957069397
py_14700,Python,"def parse(url):
    """"""Parses a database URL.""""""

    config = {}

    if not isinstance(url, six.string_types):
        url = ''

    url = urlparse.urlparse(url)

    # Remove query strings.
    path = url.path[1:]
    path = path.split('?', 2)[0]

    # Update with environment configuration.
    config.update({
        'NAME': path,
        'USER': url.username,
        'PASSWORD': url.password,
        'HOST': url.hostname,
        'PORT': url.port,
    })

    if url.scheme in SCHEMES:
        config['ENGINE'] = SCHEMES[url.scheme]

    return config","This function parses a database URL to extract various connection details such as database name, username, password, host, port, and engine based on the URL's scheme. It then returns a dictionary containing these connection details.",Parses a database URL.,No Error,False,The documentation accurately describes how the function works without making any false claims or omissions.,0.01780895112194094,0.8642688393592834
py_4593,Python,"def switch(
        cls, variable, custom=False
    ):  # pylint: disable=inconsistent-return-statements
        """"""
        Switch PyFunceble.CONFIGURATION variables to their opposite.

        :param variable:
            The variable name to switch.
            The variable should be an index our configuration system.
            If we want to switch a bool variable, we should parse
            it here.
        :type variable: str|bool

        :param custom:
            Let us know if have to switch the parsed variable instead
            of our configuration index.
        :type custom: bool

        :return:
            The opposite of the configuration index or the given variable.
        :rtype: bool

        :raises:
            :code:`Exception`
                When the configuration is not valid. In other words,
                if the PyFunceble.CONFIGURATION[variable_name] is not a bool.
        """"""

        if not custom:
            # We are not working with custom variable which is not into
            # the configuration.

            # We get the current state.
            current_state = dict.get(PyFunceble.CONFIGURATION, variable)
        else:
            # We are working with a custom variable which is not into the
            # configuration
            current_state = variable

        if isinstance(current_state, bool):
            # The current state is a boolean.

            if current_state:
                # The current state is equal to True.

                # We return False.
                return False

            # The current state is equal to False.

            # We return True.
            return True

        # The current state is not a boolean.

        # We set the message to raise.
        to_print = ""Impossible to switch %s. Please post an issue to %s""

        # We raise an exception inviting the user to report an issue.
        raise Exception(
            to_print % (repr(variable), PyFunceble.LINKS[""repo""] + ""/issues."")
        )","Switch PyFunceble.CONFIGURATION variables to their opposite.

:param variable:
    The variable name to switch.
    The variable should be an index in our configuration system.
    If we want to switch a bool variable, we should parse it here.
:type variable: str|bool

:param custom:
    Let us know if we have to switch the parsed variable instead of our configuration index.
:type custom: bool

:return:
    The opposite of the configuration index or the given variable.
:rtype: bool

:raises:
    :code:`Exception`
        When the configuration is not valid. In other words,
        if PyFunceble.CONFIGURATION[variable_name] is not a bool.","Switch PyFunceble.CONFIGURATION variables to their opposite.

        :param variable:
            The variable name to switch.
            The variable should be an index our configuration system.
            If we want to switch a bool variable, we should parse
            it here.
        :type variable: str|bool

        :param custom:
            Let us know if have to switch the parsed variable instead
            of our configuration index.
        :type custom: bool

        :return:
            The opposite of the configuration index or the given variable.
        :rtype: bool

        :raises:
            :code:`Exception`
                When the configuration is not valid. In other words,
                if the PyFunceble.CONFIGURATION[variable_name] is not a bool.",No Error,False,"The provided code and generated documentation are consistent with each other in terms of the function and variables explained, hence there is neither hallucinations nor omissions present.",0.9252471886205862,0.9294992089271545
py_13824,Python,"def _method_magic_marker(magic_kind):
    """"""Decorator factory for methods in Magics subclasses.
    """"""

    validate_type(magic_kind)

    # This is a closure to capture the magic_kind.  We could also use a class,
    # but it's overkill for just that one bit of state.
    def magic_deco(arg):
        call = lambda f, *a, **k: f(*a, **k)

        if callable(arg):
            # ""Naked"" decorator call (just @foo, no args)
            func = arg
            name = func.func_name
            retval = decorator(call, func)
            record_magic(magics, magic_kind, name, name)
        elif isinstance(arg, basestring):
            # Decorator called with arguments (@foo('bar'))
            name = arg
            def mark(func, *a, **kw):
                record_magic(magics, magic_kind, name, func.func_name)
                return decorator(call, func)
            retval = mark
        else:
            raise TypeError(""Decorator can only be called with ""
                            ""string or function"")
        return retval

    # Ensure the resulting decorator has a usable docstring
    magic_deco.__doc__ = _docstring_template.format('method', magic_kind)
    return magic_deco",Decorator factory for methods in Magics subclasses.,Decorator factory for methods in Magics subclasses.,No Error,False,The provided documentation accurately represents the purpose and functionality of the method without adding any extraneous information or omitting necessary details.,1.0,0.9999999403953552
py_6012,Python,"def run(self, subcmd_name, arg):
        """"""Run subcmd_name with args using obj for the environent""""""
        entry=self.lookup(subcmd_name)
        if entry:
            entry['callback'](arg)
        else:
            self.cmdproc.undefined_cmd(entry.__class__.name, subcmd_name)
            pass
        return",Run subcmd_name with args using obj for the environment.,Run subcmd_name with args using obj for the environent,Omission,True,Documentation fails to mention that the function checks if the subcommand exists and calls the undefined command procedure if it does not.,0.8633400213704505,0.9678246974945068
py_9127,Python,"def ifftp(wave, npoints=None, indep_min=None, indep_max=None, unwrap=True, rad=True):
    r""""""
    Return the phase of the inverse Fast Fourier Transform of a waveform.

    :param wave: Waveform
    :type  wave: :py:class:`peng.eng.Waveform`

    :param npoints: Number of points to use in the transform. If **npoints**
                    is less than the size of the independent variable vector
                    the waveform is truncated; if **npoints** is greater than
                    the size of the independent variable vector, the waveform
                    is zero-padded
    :type  npoints: positive integer

    :param indep_min: Independent vector start point of computation
    :type  indep_min: integer or float

    :param indep_max: Independent vector stop point of computation
    :type  indep_max: integer or float

    :param unwrap: Flag that indicates whether phase should change phase shifts
                   to their :code:`2*pi` complement (True) or not (False)
    :type  unwrap: boolean

    :param rad: Flag that indicates whether phase should be returned in radians
                (True) or degrees (False)
    :type  rad: boolean

    :rtype: :py:class:`peng.eng.Waveform`

    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc(raised=True)) ]]]
    .. Auto-generated exceptions documentation for
    .. peng.wave_functions.ifftp

    :raises:
     * RuntimeError (Argument \`indep_max\` is not valid)

     * RuntimeError (Argument \`indep_min\` is not valid)

     * RuntimeError (Argument \`npoints\` is not valid)

     * RuntimeError (Argument \`rad\` is not valid)

     * RuntimeError (Argument \`unwrap\` is not valid)

     * RuntimeError (Argument \`wave\` is not valid)

     * RuntimeError (Incongruent \`indep_min\` and \`indep_max\`
       arguments)

     * RuntimeError (Non-uniform frequency spacing)

    .. [[[end]]]
    """"""
    return phase(ifft(wave, npoints, indep_min, indep_max), unwrap=unwrap, rad=rad)","Return the phase of the inverse Fast Fourier Transform of a waveform, with options to specify the number of points used in the transform, the independent vector start and stop points, whether to unwrap phase shifts, and whether to return the phase in radians or degrees.","r""""""
    Return the phase of the inverse Fast Fourier Transform of a waveform.

    :param wave: Waveform
    :type  wave: :py:class:`peng.eng.Waveform`

    :param npoints: Number of points to use in the transform. If **npoints**
                    is less than the size of the independent variable vector
                    the waveform is truncated; if **npoints** is greater than
                    the size of the independent variable vector, the waveform
                    is zero-padded
    :type  npoints: positive integer

    :param indep_min: Independent vector start point of computation
    :type  indep_min: integer or float

    :param indep_max: Independent vector stop point of computation
    :type  indep_max: integer or float

    :param unwrap: Flag that indicates whether phase should change phase shifts
                   to their :code:`2*pi` complement (True) or not (False)
    :type  unwrap: boolean

    :param rad: Flag that indicates whether phase should be returned in radians
                (True) or degrees (False)
    :type  rad: boolean

    :rtype: :py:class:`peng.eng.Waveform`

    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc(raised=True)) ]]]
    .. Auto-generated exceptions documentation for
    .. peng.wave_functions.ifftp

    :raises:
     * RuntimeError (Argument \`indep_max\` is not valid)

     * RuntimeError (Argument \`indep_min\` is not valid)

     * RuntimeError (Argument \`npoints\` is not valid)

     * RuntimeError (Argument \`rad\` is not valid)

     * RuntimeError (Argument \`unwrap\` is not valid)

     * RuntimeError (Argument \`wave\` is not valid)

     * RuntimeError (Incongruent \`indep_min\` and \`indep_max\`
       arguments)

     * RuntimeError (Non-uniform frequency spacing)

    .. [[[end]]]",Omission,True,The documentation does not mention that a variety of runtime errors could potentially be raised.,0.010318006552915185,0.77141273021698
cob_real_241,COBOL,"      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HCPRESTW.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

      *****************************************************************
      *    DFHJS2WS GENERATED COPYBOOKS
      *****************************************************************

        01 JSON-REST-DATA.

        COPY HCPRST01.

        01 HCPAPP-PATIENT-DETAILS.

        COPY HCCMAREA.

       01 DEFAULT-CHANNEL            PIC X(16).

       01  WS-TSQ-FIELDS.
           03  WS-TSQ-NAME           PIC X(8) VALUE 'HCPRESTW'.
           03  WS-TSQ-LEN            PIC S9(4) COMP VALUE +200.
           03  WS-TSQ-DATA           PIC X(200).

       01 WS-RETURN-RESPONSE         PIC X(100).

    ","This COBOL program defines several data structures and copybooks for interacting with a REST service. It includes declarations for JSON data, patient details, a default channel, a working storage section for temporary data, and a response buffer. The program appears to be named HCPRESTW and is likely part of a larger system for handling REST requests in a mainframe environment.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the COBOL program's structure and purpose without hallucinations or omissions.,0.005203424609196104,0.8566938638687134
py_8185,Python,"def _execute(self, backend_args, archive_args):
        """"""Execute a backend of Perceval.

        Run the backend of Perceval assigned to this job using the
        given arguments. It will raise an `AttributeError` when any of
        the required parameters to run the backend are not found.
        Other exceptions related to the execution of the backend
        will be raised too.

        This method will return an iterator of the items fetched
        by the backend. These items will include some metadata
        related to this job.

        It will also be possible to retrieve the items from the
        archive setting to `True` the parameter `fetch_from_archive`.

        :param backend_args: arguments to execute the backend
        :param archive_args: archive arguments

        :returns: iterator of items fetched by the backend

        :raises AttributeError: raised when any of the required
            parameters is not found
        """"""
        if not archive_args or not archive_args['fetch_from_archive']:
            return perceval.backend.fetch(self._bklass, backend_args, self.category,
                                          manager=self.archive_manager)
        else:
            return perceval.backend.fetch_from_archive(self._bklass, backend_args,
                                                       self.archive_manager, self.category,
                                                       archive_args['archived_after'])","""""""Execute a backend of Perceval.

Run the backend of Perceval assigned to this job using the
given arguments. It will raise an `AttributeError` when any of
the required parameters to run the backend are not found.
Other exceptions related to the execution of the backend
will be raised too.

This method will return an iterator of the items fetched
by the backend. These items will include some metadata
related to this job.

It will also be possible to retrieve the items from the
archive setting to `True` the parameter `fetch_from_archive`.

:param backend_args: arguments to execute the backend
:param archive_args: archive arguments

:returns: iterator of items fetched by the backend

:raises AttributeError: raised when any of the required
    parameters is not found
""""""","Execute a backend of Perceval.

        Run the backend of Perceval assigned to this job using the
        given arguments. It will raise an `AttributeError` when any of
        the required parameters to run the backend are not found.
        Other exceptions related to the execution of the backend
        will be raised too.

        This method will return an iterator of the items fetched
        by the backend. These items will include some metadata
        related to this job.

        It will also be possible to retrieve the items from the
        archive setting to `True` the parameter `fetch_from_archive`.

        :param backend_args: arguments to execute the backend
        :param archive_args: archive arguments

        :returns: iterator of items fetched by the backend

        :raises AttributeError: raised when any of the required
            parameters is not found",No Error,False,The provided document matches completely with the source code. No hallucinations or omissions are detected.,0.9834010485386678,0.909986138343811
cob_syn_9773,COBOL,"      * REFACTOR CANDIDATE BATCH_9773
      * SYSTEM GENERATED

recipe apa {
  conv [strides := [2, 2, 2]]
  relu []
  batch_normalize []
}

recipe bepa {
  conv [strides := [3,3]]
  relu []
  apa
}

model my_model {
  apa
  apa
  bepa
  bepa  
}
","This COBOL code defines a series of neural network layers and a model. The `apa` recipe performs convolution, ReLU activation, and batch normalization. The `bepa` recipe performs convolution and ReLU activation with different parameters. The `my_model` model is composed of multiple instances of the `apa` and `bepa` recipes.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention that `apa` is used in `bepa` recipe.,0.006277466950757328,0.8494150042533875
py_2470,Python,"def quaternion_from_euler(angles, order='yzy'):
    """"""Generate a quaternion from a set of Euler angles.

    Args:
        angles (array_like): Array of Euler angles.
        order (str): Order of Euler rotations.  'yzy' is default.

    Returns:
        Quaternion: Quaternion representation of Euler rotation.
    """"""
    angles = np.asarray(angles, dtype=float)
    quat = quaternion_from_axis_rotation(angles[0], order[0])\
        * (quaternion_from_axis_rotation(angles[1], order[1])
           * quaternion_from_axis_rotation(angles[2], order[2]))
    quat.normalize(inplace=True)
    return quat",Generate a quaternion from a set of Euler angles.,"Generate a quaternion from a set of Euler angles.

    Args:
        angles (array_like): Array of Euler angles.
        order (str): Order of Euler rotations.  'yzy' is default.

    Returns:
        Quaternion: Quaternion representation of Euler rotation.",No Error,False,The documentation accurately describes the functionality of the code.,0.0776490817034759,0.8586409687995911
py_14520,Python,"def create_profile_dir_by_name(cls, path, name=u'default', config=None):
        """"""Create a profile dir by profile name and path.

        Parameters
        ----------
        path : unicode
            The path (directory) to put the profile directory in.
        name : unicode
            The name of the profile.  The name of the profile directory will
            be ""profile_<profile>"".
        """"""
        if not os.path.isdir(path):
            raise ProfileDirError('Directory not found: %s' % path)
        profile_dir = os.path.join(path, u'profile_' + name)
        return cls(location=profile_dir, config=config)",Create a profile dir by profile name and path.,"Create a profile dir by profile name and path.

        Parameters
        ----------
        path : unicode
            The path (directory) to put the profile directory in.
        name : unicode
            The name of the profile.  The name of the profile directory will
            be ""profile_<profile>"".",Omission,True,"The documentation does not mention the possibility of a directory not existing and the resulting ProfileDirError, nor does it mention the optional config parameter.",0.0319224918348957,0.8000664114952087
cob_syn_7595,COBOL,"      * REFACTOR CANDIDATE BATCH_7595
      * SYSTEM GENERATED
       identification division.
       program-id. cow.

       environment division.

       data division.

       working-storage section.


       01 newline         pic x   value x'0a'.

       01 analyzed-query pic x(1600).  

       01 the-great-dispatch.

          03  routing-table            occurs 10 times.

            05   routing-pattern   pic x(999).
            05   routing-destiny   pic x(999).


       01 tester         pic x(1) value ""n"".  
       01 anyfound       pic x(1) value ""n"".
       01 ctr            pic 99 usage comp-5.

       01 the-values.

          05 query-values           occurs 10 times.
            10 query-value-name     pic x(90).
            10 query-value          pic x(90).



       procedure division.


       copy ""src-cbl/config.cfg"".


       perform web-header.

       call 'getquery' using analyzed-query.


       perform varying ctr from 1 by 1
             until ctr > 5

           call 'checkquery' using analyzed-query routing-pattern(ctr) tester the-values

           if (tester=""y"")

              *> display routing-pattern(ctr) ""<hr>"" 
              move ""y"" to anyfound
              call routing-destiny(ctr) using the-values

           end-if


       end-perform


       if (anyfound=""n"") perform bad-query-error.

       *> if (anyfound=""y"")  call 'showvars' using the-values.  

        

       goback.



 bad-query-error.

 display ""<b>Cobol-on-Wheelchair error:</b> query pattern not found (<i>"" function trim(analyzed-query) ""</i>)"".


 web-header.

       display
           ""content-type: text/html""
           newline
       end-display.














       identification division.
       program-id. getquery.

       environment division.

              input-output section.
       file-control.
           select webinput assign to keyboard.


       data division.
       file section.
       fd webinput.
          01 postchunk       pic x(1024).

       working-storage section.

       78 name-count   ","This COBOL program consists of multiple modules. The main program (`cow`) reads a query from an input source, calls a module (`getquery`) to fetch the query, and then loops through a routing table to check the query against patterns. If a match is found, it calls a corresponding module and sets a flag. If no matches are found, it calls an error module. Finally, it displays an HTML header and ends the program. The program uses other modules to fetch the query and handle errors as needed.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the source code's logic and operations without making unsupported claims or missing critical information.,0.0037995386103063552,0.850433886051178
cob_syn_9342,COBOL,"      * REFACTOR CANDIDATE BATCH_9342
      * SYSTEM GENERATED
000100!                                                                 POS00049
000200!   lrschema.cob - Schema for COBOL programming                   95/03/31
000300!                                                                 95/03/31
000500!   Copyright (c) 1991-2009 iMatix Corporation                    95/03/31
000600!                                                                 95/03/31
000700!  Usage:      Generates single copybook, with extension '.cob'.  95/03/31
000800!              By default, generates ANSI 74 COBOL, for a main    95/03/31
000900!              program (without linkage).  Accept these options:  95/03/31
001000!                                                                 95/03/31
001100!              -opt:model=main   - generate main program (default)95/03/31
001200!              -opt:model=called - generate called program        95/06/25
001300!              -opt:level=ansi74 - generate ANSI74 code (default) 95/03/31
001400!              -opt:level=ansi85 - generate ANSI85 code           95/03/31
001500!              -opt:ext=cbl      - use extension '.cbl' (default) 95/03/31
001600!              -opt:ext=xxx      - use extension '.xxx'           95/03/31
001700!              -opt:console=""""   - suffix for DISPLAY verb        95/10/01
001800!              -opt:stack_max=n  - subdialog stack size (20)      95/11/02
001900!              -opt:template=xxx - template file (TEMPLATE.cob)   95/12/18
002000!                                                                 95/03/27
002100!              I recommend that your dialog carries the program   95/03/27
002200!              name followed by 'd', with extension '.l'.         95/03/27
002300!                                                                 95/03/27
002400!              Assumes linkage section in $SOURCE\R.$ext.         95/12/08
002500!                                                                 95/03/27
002800!  ------------------ GPL Licensed Source Code ---","This COBOL code generates a single copybook with the extension '.cob'. By default, it produces ANSI 74 COBOL for a main program without linkage. It provides options such as generating main or called programs, selecting ANSI 74 or ANSI 85 code, specifying different extensions, setting a suffix for DISPLAY verb, defining subdialog stack size, and using a template file. It is recommended to append 'd' to the program name with an extension '.l'. The code assumes a linkage section in a specific directory.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately represents the source code with no hallucinations or omissions.,0.003954503988322001,0.8483937978744507
cob_syn_9166,COBOL,"      * REFACTOR CANDIDATE BATCH_9166
      * SYSTEM GENERATED
1234                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ","This COBOL code seems to be a generated template or placeholder with comments indicating it as a ""REFACTOR CANDIDATE."" The actual purpose or functionality of the code is not clear as the content is mostly empty and contains a comment saying ""SYSTEM GENERATED.""",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the provided source code.,0.006883858510498897,0.862947940826416
cob_real_3115,COBOL,"*> Asks the user for From and To account number (up to 5 digits long) and the amount
*> having value no larger than 9999.99 and appends such record to the file.
IDENTIFICATION DIVISION.
    PROGRAM-ID. SeqWrite.
ENVIRONMENT DIVISION.
    INPUT-OUTPUT SECTION.
        FILE-CONTROL.
            SELECT OPTIONAL OutFile ASSIGN TO ""transactions.dat""
                ORGANIZATION IS LINE SEQUENTIAL.

DATA DIVISION.
    FILE SECTION.
        FD OutFile.
        01 TransactionDetails.
            05 FromAccount  PIC 9(5).
            05 ToAccount    PIC 9(5).
            05 Amount       PIC 9999.99.

    WORKING-STORAGE SECTION.
        01 ShouldContinue   PIC X   VALUE ""C"".
            88 Done         VALUES ""Q"" ""q"".

PROCEDURE DIVISION.
    OPEN EXTEND OutFile.
    DISPLAY ""Enter transaction, use Q command to quit."".
    PERFORM SaveTransaction UNTIL Done.
    CLOSE OutFile.
    STOP RUN.

SaveTransaction.
    DISPLAY ""From   > "" WITH NO ADVANCING.
    ACCEPT FromAccount.
    DISPLAY ""To     > "" WITH NO ADVANCING.
    accept ToAccount.
    DISPLAY ""Amount > "" WITH NO ADVANCING.
    ACCEPT Amount.

    WRITE TransactionDetails.
    DISPLAY ""Enter to add new record, 'Q' to quit > "".
    ACCEPT ShouldContinue.
","This COBOL program prompts the user to input a From account number, a To account number (both up to 5 digits), and an amount (up to 9999.99), then appends this transaction record to the ""transactions.dat"" file. The user can add multiple records until choosing to quit by entering 'Q'.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the program functionality without any unsupported claims or omissions.,0.00616976802746866,0.8520723581314087
py_3208,Python,"def comments(self, group, event_id):
        """"""Fetch the comments of a given event.""""""

        resource = urijoin(group, self.REVENTS, event_id, self.RCOMMENTS)

        params = {
            self.PPAGE: self.max_items
        }

        for page in self._fetch(resource, params):
            yield page",Fetch the comments of a given event.,Fetch the comments of a given event.,No Error,False,The documentation accurately describes the function of the code.,1.0,1.0
py_1657,Python,"def swap_deployment(self, service_name, production, source_deployment):
        '''
        Initiates a virtual IP swap between the staging and production
        deployment environments for a service. If the service is currently
        running in the staging environment, it will be swapped to the
        production environment. If it is running in the production
        environment, it will be swapped to staging.

        service_name:
            Name of the hosted service.
        production:
            The name of the production deployment.
        source_deployment:
            The name of the source deployment.
        '''
        _validate_not_none('service_name', service_name)
        _validate_not_none('production', production)
        _validate_not_none('source_deployment', source_deployment)
        return self._perform_post(self._get_hosted_service_path(service_name),
                                  _XmlSerializer.swap_deployment_to_xml(
                                      production, source_deployment),
                                  as_async=True)","Initiates a virtual IP swap between the staging and production deployment environments for a service. If the service is currently running in the staging environment, it will be swapped to the production environment. If it is running in the production environment, it will be swapped to staging. The function takes in the service name, the name of the production deployment, and the name of the source deployment as parameters.","Initiates a virtual IP swap between the staging and production
        deployment environments for a service. If the service is currently
        running in the staging environment, it will be swapped to the
        production environment. If it is running in the production
        environment, it will be swapped to staging.

        service_name:
            Name of the hosted service.
        production:
            The name of the production deployment.
        source_deployment:
            The name of the source deployment.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.7532928448943258,0.8377164602279663
cob_syn_2487,COBOL,"      * REFACTOR CANDIDATE BATCH_2487
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. AOC-2020-04-1.
       AUTHOR. ANNA KOSIERADZKA.
      
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT INPUTFILE ASSIGN TO ""d4.input""
           ORGANIZATION IS LINE SEQUENTIAL.
           
       DATA DIVISION.
       FILE SECTION.
         FD INPUTFILE
         RECORD IS VARYING IN SIZE FROM 1 to 99
         DEPENDING ON REC-LEN.
         01 INPUTRECORD PIC X(99).
       WORKING-STORAGE SECTION.
         01 FILE-STATUS PIC 9 VALUE 0.
         01 REC-LEN PIC 9(2) COMP.
         01 WS-ROW PIC X(16) OCCURS 8 TIMES.
         01 WS-CHAR PIC X.

       LOCAL-STORAGE SECTION.
         01 CORRECT-PASSPORTS UNSIGNED-INT VALUE 0.
         01 FOUND-FIELDS UNSIGNED-INT VALUE 0.
         01 STRING-PTR UNSIGNED-INT VALUE 1.
         01 I UNSIGNED-INT VALUE 1.

       PROCEDURE DIVISION.
       001-MAIN.
           OPEN INPUT INPUTFILE.
           PERFORM 002-READ UNTIL FILE-STATUS = 1.
           CLOSE INPUTFILE.
           PERFORM 004-NEXT-PASSPORT.
           DISPLAY CORRECT-PASSPORTS.
           STOP RUN.

       002-READ.
            READ INPUTFILE
                AT END MOVE 1 TO FILE-STATUS
                NOT AT END PERFORM 003-PROCESS-RECORD
            END-READ.
       
       003-PROCESS-RECORD.
           IF REC-LEN = 0 THEN
              PERFORM 004-NEXT-PASSPORT
           ELSE 
              PERFORM 005-PROCESS-ROW
           END-IF.
          
       004-NEXT-PASSPORT.
           IF FOUND-FIELDS = 7 THEN 
              ADD 1 TO CORRECT-PASSPORTS
           END-IF.
           MOVE 0 TO FOUND-FIELDS.
           
       005-PROCESS-ROW.
           MOVE 1 TO STRING-PTR.
           PERFORM VARYING I FROM 1 BY 1 UNTIL I > 8
             UNSTRING INPUTRECORD DELIMITED BY SPACE INTO WS-ROW(I)
             WITH POINTER STRING-PTR
           END-PERFORM.
           
           PERFORM VARYING I FROM 1 BY 1 UNTIL I > 8
              MOVE WS-ROW(I)(1:1) TO WS-CHAR
            ","This COBOL program reads data from an input file, processes each record by splitting it into rows and characters, and counts the number of correct passports based on specified conditions. The program opens the input file, reads records until the end of the file is reached, closes the file, processes each record to identify correct passports, and finally displays the count of correct passports before stopping the program.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not detail what is considered a ""correct passport"" based on the code, nor does it explain the specific processing done on each row and incoming character.",0.004681807893998983,0.8557135462760925
cob_real_2795,COBOL,"000001 Identification Division.                                         00000001
000002 Program-ID. testantlr311.                                        00000002
000003 Data Division.                                                   00000003
000004 Working-Storage Section.                                         00000004
000005                                                                  00000005
000006 01  CONSTANTS.                                                   00000006
000007     05  MYNAME               PIC X(012) VALUE 'testantlr311'.    00000007
000008                                                                  00000008
000009 Procedure Division.                                              00000009
000010     DISPLAY MYNAME ' Begin'                                      00000010
000011                                                                  00000011
000012     EXEC CICS                                                    00000012
000013          LINK                                                    00000013
000014          PROGRAM('PGMA0001')                                     00000014
000015          COMMAREA(CA-STUFF)                                      00000015
000016          COMMAREALENGTH(CA-STUFF-LEN)                            00000016
000017     END-EXEC                                                     00000017
000018                                                                  00000018
000019     DISPLAY MYNAME ' End'                                        00000019
000020                                                                  00000020
000021     GOBACK                                                       00000021
000022     .                                                            00000022
000023                                                                  00000023
000024                                                                  00000024
","This COBOL program defines a constant `MYNAME` with a value of 'testantlr311'. It then displays 'testantlr311 Begin', executes a CICS program 'PGMA0001' passing `CA-STUFF` as the communication area with a specified length `CA-STUFF-LEN`, and finally displays 'testantlr311 End' before terminating the program.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the actions and variables outlined in the provided source code.,0.00702083472657119,0.8369651436805725
cob_syn_8512,COBOL,"      * REFACTOR CANDIDATE BATCH_8512
      * SYSTEM GENERATED
# This is a sample hie.yaml file for opening haskell-language-server
# in hie, using cabal as the build system.  To use is, copy it to a
# file called 'hie.yaml'
# WARNING: This configuration works for hie but does not for
#          haskell-language-server or ghcide.
#          They need support for multi-cradle:
#          https://github.com/digital-asset/ghcide/issues/113
cradle:
  cabal:

    - path: ""./test/functional/""
      component: ""haskell-language-server:func-test""

    - path: ""./test/utils/""
      component: ""haskell-language-server:hls-test-utils""

    - path: ""./exe/Main.hs""
      component: ""haskell-language-server:exe:haskell-language-server""

    - path: ""./exe/Wrapper.hs""
      component: ""haskell-language-server:exe:haskell-language-server-wrapper""

    - path: ""./src""
      component: ""lib:haskell-language-server""

    - path: ""./ghcide/src""
      component: ""ghcide:lib:ghcide""

    - path: ""./ghcide/exe""
      component: ""ghcide:exe:ghcide""
","This is a sample `hie.yaml` configuration file for opening haskell-language-server in hie, using cabal as the build system. It includes paths to various components and specifies their corresponding components for the build system. There is a warning that this configuration may not work for haskell-language-server or ghcide as they require multi-cradle support.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not explain what each path and component in the code does, or provide any context or examples for use.",0.0,0.8303211331367493
py_483,Python,"def _enqueue_task_instances_with_queued_state(self, simple_dag_bag,
                                                  simple_task_instances):
        """"""
        Takes task_instances, which should have been set to queued, and enqueues them
        with the executor.

        :param simple_task_instances: TaskInstances to enqueue
        :type simple_task_instances: list[SimpleTaskInstance]
        :param simple_dag_bag: Should contains all of the task_instances' dags
        :type simple_dag_bag: airflow.utils.dag_processing.SimpleDagBag
        """"""
        TI = models.TaskInstance
        # actually enqueue them
        for simple_task_instance in simple_task_instances:
            simple_dag = simple_dag_bag.get_dag(simple_task_instance.dag_id)
            command = TI.generate_command(
                simple_task_instance.dag_id,
                simple_task_instance.task_id,
                simple_task_instance.execution_date,
                local=True,
                mark_success=False,
                ignore_all_deps=False,
                ignore_depends_on_past=False,
                ignore_task_deps=False,
                ignore_ti_state=False,
                pool=simple_task_instance.pool,
                file_path=simple_dag.full_filepath,
                pickle_id=simple_dag.pickle_id)

            priority = simple_task_instance.priority_weight
            queue = simple_task_instance.queue
            self.log.info(
                ""Sending %s to executor with priority %s and queue %s"",
                simple_task_instance.key, priority, queue
            )

            self.executor.queue_command(
                simple_task_instance,
                command,
                priority=priority,
                queue=queue)","Enqueues task instances that have been set to queued with the executor by generating a command using the task instance details and passing it to the executor with the specified priority and queue.

:param simple_task_instances: TaskInstances to enqueue
:type simple_task_instances: list[SimpleTaskInstance]
:param simple_dag_bag: Should contain all of the task_instances' dags
:type simple_dag_bag: airflow.utils.dag_processing.SimpleDagBag","Takes task_instances, which should have been set to queued, and enqueues them
        with the executor.

        :param simple_task_instances: TaskInstances to enqueue
        :type simple_task_instances: list[SimpleTaskInstance]
        :param simple_dag_bag: Should contains all of the task_instances' dags
        :type simple_dag_bag: airflow.utils.dag_processing.SimpleDagBag",No Error,False,The documentation correctly describes the tasks performed by the code without any hallucinations or omissions.,0.3687546890956331,0.897095799446106
py_3056,Python,"def finalize():
  """"""A function that should be called after parsing all Gin config files.

  Calling this function allows registered ""finalize hooks"" to inspect (and
  potentially modify) the Gin config, to provide additional functionality. Hooks
  should not modify the configuration object they receive directly; instead,
  they should return a dictionary mapping Gin binding keys to (new or updated)
  values. This way, all hooks see the config as originally parsed.

  Raises:
    RuntimeError: If the config is already locked.
    ValueError: If two or more hooks attempt to modify or introduce bindings for
      the same key. Since it is difficult to control the order in which hooks
      are registered, allowing this could yield unpredictable behavior.
  """"""
  if config_is_locked():
    raise RuntimeError('Finalize called twice (config already locked).')

  bindings = {}
  for hook in _FINALIZE_HOOKS:
    new_bindings = hook(_CONFIG)
    if new_bindings is not None:
      for key, value in six.iteritems(new_bindings):
        pbk = ParsedBindingKey(key)
        if pbk in bindings:
          err_str = 'Received conflicting updates when running {}.'
          raise ValueError(err_str.format(hook))
        bindings[pbk] = value

  for pbk, value in six.iteritems(bindings):
    bind_parameter(pbk, value)

  _set_config_is_locked(True)","A function that should be called after parsing all Gin config files. Calling this function allows registered ""finalize hooks"" to inspect (and potentially modify) the Gin config, to provide additional functionality. Hooks should not modify the configuration object they receive directly; instead, they should return a dictionary mapping Gin binding keys to (new or updated) values. This way, all hooks see the config as originally parsed. Raises RuntimeError if the config is already locked, and ValueError if two or more hooks attempt to modify or introduce bindings for the same key. Since it is difficult to control the order in which hooks are registered, allowing this could yield unpredictable behavior.","A function that should be called after parsing all Gin config files.

  Calling this function allows registered ""finalize hooks"" to inspect (and
  potentially modify) the Gin config, to provide additional functionality. Hooks
  should not modify the configuration object they receive directly; instead,
  they should return a dictionary mapping Gin binding keys to (new or updated)
  values. This way, all hooks see the config as originally parsed.

  Raises:
    RuntimeError: If the config is already locked.
    ValueError: If two or more hooks attempt to modify or introduce bindings for
      the same key. Since it is difficult to control the order in which hooks
      are registered, allowing this could yield unpredictable behavior.",No Error,False,The documentation accurately represents the functionality of the source code without any hallucinations or omissions.,0.9073556002785339,0.9296491146087646
cob_syn_5810,COBOL,"      * REFACTOR CANDIDATE BATCH_5810
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. server.
       DATA DIVISION.
           WORKING-STORAGE SECTION.
           01 USER-NAME PIC X(10).
           01 MENU-CHOICE PIC X.

           SCREEN SECTION.
           01 LOGIN-SCREEN.
             05 BLANK SCREEN.
             05 LINE 2 COLUMN 10 VALUE ""Makers BBS"".
             05 LINE 4 COLUMN 10 VALUE ""What's your name?"".
             05 USER-NAME-FIELD LINE 6 COLUMN 10 PIC X(10)
                USING USER-NAME.

           01 MENU-SCREEN
             BACKGROUND-COLOR IS 1.
             05 BLANK SCREEN.
             05 LINE 2 COLUMN 10 VALUE ""Makers BBS"".
             05 LINE 4 COLUMN 10 VALUE ""Welcome, "".
             05 LINE 4 COLUMN 19 PIC X(10) USING USER-NAME.
             05 LINE 8 COLUMN 10 VALUE ""(n) Nothing"".
             05 LINE 8 COLUMN 30 VALUE ""(l) Logout"".
             05 LINE 8 COLUMN 60 VALUE ""(q) Quit"".
             05 LINE 20 COLUMN 10 VALUE ""Pick: "".
             05 MENU-CHOICE-FIELD LINE 20 COLUMN 16 PIC X
                USING MENU-CHOICE.

       PROCEDURE DIVISION.

       0110-DISPLAY-LOGIN.
           INITIALIZE USER-NAME.
           DISPLAY LOGIN-SCREEN.
           ACCEPT USER-NAME-FIELD.
           PERFORM 0120-DISPLAY-MENU.

       0120-DISPLAY-MENU.
           INITIALIZE MENU-CHOICE.
           DISPLAY MENU-SCREEN.
           ACCEPT MENU-CHOICE-FIELD.
           IF MENU-CHOICE = ""q"" THEN
             STOP RUN
           ELSE IF MENU-CHOICE = ""l"" THEN
             PERFORM 0110-DISPLAY-LOGIN
           ELSE IF MENU-CHOICE = ""n"" THEN
             PERFORM 0120-DISPLAY-MENU
           END-IF.
","This COBOL program implements a simple interactive menu-based system for a Bulletin Board Service (BBS). It first displays a login screen prompting the user for their name. After entering the name, it displays a menu screen with options to continue using the BBS, log out, or quit the program. The user's name is displayed on the menu screen. The program loops to the login screen or menu screen based on the user's menu choice. It ends when the user selects to quit from the menu.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the code's function without any hallucinations or omissions.,0.0038753562430613995,0.8519505858421326
cob_syn_8928,COBOL,"      * REFACTOR CANDIDATE BATCH_8928
      * SYSTEM GENERATED
           select pd00400 assign to disk wid-pd00400
                organization        is indexed
                access mode         is dynamic
                record key          is f00400-chave = 
                                       f00400-cd-empresa
                                       f00400-cd-filial
                                       f00400-id-municipio
                alternate key       is f00400-chave-1 =
                                       f00400-cd-empresa
                                       f00400-cd-filial
                                       f00400-id-estado
                                       f00400-cd-municipio                                       
                lock mode           is manual
                file status         is ws-resultado-acesso.
","This COBOL code snippet defines a file named pd00400 with an indexed organization and dynamic access mode. The file contains records with a composite key composed of f00400-chave, f00400-cd-empresa, f00400-cd-filial, and f00400-id-municipio. It also includes an alternate key with f00400-chave-1 consisting of f00400-cd-empresa, f00400-cd-filial, f00400-id-estado, and f00400-cd-municipio. The file has manual lock mode and uses ws-resultado-acesso to store the file status.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the provided COBOL code snippet without any hallucinations or omissions.,0.005131423326712104,0.8176634907722473
py_7745,Python,"def mark_causative(self, institute, case, user, link, variant):
        """"""Create an event for marking a variant causative.

        Arguments:
          institute (dict): A Institute object
          case (dict): Case object
          user (dict): A User object
          link (str): The url to be used in the event
          variant (variant): A variant object

        Returns:
            updated_case(dict)
        """"""
        display_name = variant['display_name']
        LOG.info(""Mark variant {0} as causative in the case {1}"".format(
            display_name, case['display_name']))

        LOG.info(""Adding variant to causatives in case {0}"".format(
            case['display_name']))

        LOG.info(""Marking case {0} as solved"".format(
            case['display_name']))

        updated_case = self.case_collection.find_one_and_update(
            {'_id': case['_id']},
            {
                '$push': {'causatives': variant['_id']},
                '$set': {'status': 'solved'}
            },
            return_document=pymongo.ReturnDocument.AFTER
        )

        LOG.info(""Creating case event for marking {0}"" \
                    "" causative"".format(variant['display_name']))

        self.create_event(
            institute=institute,
            case=case,
            user=user,
            link=link,
            category='case',
            verb='mark_causative',
            variant=variant,
            subject=variant['display_name'],
        )

        LOG.info(""Creating variant event for marking {0}"" \
                    "" causative"".format(case['display_name']))

        self.create_event(
            institute=institute,
            case=case,
            user=user,
            link=link,
            category='variant',
            verb='mark_causative',
            variant=variant,
            subject=variant['display_name'],
        )
        return updated_case",Create an event for marking a variant causative.,"Create an event for marking a variant causative.

        Arguments:
          institute (dict): A Institute object
          case (dict): Case object
          user (dict): A User object
          link (str): The url to be used in the event
          variant (variant): A variant object

        Returns:
            updated_case(dict)",No Error,False,The documentation accurately reflects the information about the function that is provided in the source code.,0.01831563888873418,0.7922003865242004
py_5449,Python,"def sub_fields(self):
        """""" Returns a dict of the sub fields for this point format

        Returns
        -------
        Dict[str, Tuple[str, SubField]]
            maps a sub field name to its composed dimension with additional information

        """"""
        sub_fields_dict = {}
        for composed_dim_name, sub_fields in self.composed_fields.items():
            for sub_field in sub_fields:
                sub_fields_dict[sub_field.name] = (composed_dim_name, sub_field)
        return sub_fields_dict","Returns a dict of the sub fields for this point format, mapping a sub field name to its composed dimension with additional information.","Returns a dict of the sub fields for this point format

        Returns
        -------
        Dict[str, Tuple[str, SubField]]
            maps a sub field name to its composed dimension with additional information",No Error,False,The generated documentation correctly summarizes the function's purpose and return value without any hallucinations or omissions.,0.6315036049462546,0.8489605784416199
py_13317,Python,"def work(self):
        """"""
        Start ternya work.

        First, import customer's service modules.
        Second, init openstack mq.
        Third, keep a ternya connection that can auto-reconnect.
        """"""
        self.init_modules()
        connection = self.init_mq()
        TernyaConnection(self, connection).connect()","Starts the ternya work by importing customer's service modules, initializing openstack mq, and maintaining a ternya connection that can automatically reconnect.","Start ternya work.

        First, import customer's service modules.
        Second, init openstack mq.
        Third, keep a ternya connection that can auto-reconnect.",No Error,False,The documentation correctly describes what the code does.,0.2082198320914845,0.8829861283302307
cob_real_995,COBOL,"       id division.
       program-id. hello-world.
      *
       environment division.
       input-output section.
      *
       data division.
       working-storage section.
       01 greeting              pic x(12).
       01 loop-count            pic 9 value zero.
      *
       procedure division.
      *
       0010-start.
           move ""Hello World"" to greeting.
           display greeting.
      *
       00020-loop.
           perform until loop-count = 3
               display ""Nice to meet you!""
               add 1 to loop-count
           end-perform.
      *
       9999-end.
       goback.      
","This COBOL program defines a procedure that displays ""Hello World"" and then repeats the phrase ""Nice to meet you!"" three times.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects what the code does.,0.012518377344512808,0.877280056476593
cob_real_855,COBOL,"000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID.    TSUBR06.
000300 AUTHOR.        COMPUWARE ISPW TRAINING.
000400 DATE-WRITTEN.  JANUARY 24TH, 1996.
000500 DATE-COMPILED.
000600
000700********************************************************
000800* THIS PROGRAM IS A TRAINING PROGRAM
000900*      CALLED FROM    TPROG06
001000*      WITH COPYLIB   TCPYB06 (LINKAGE AREA)
001100* ======================================================
001200*  ISPW (TM)
001300*  COPYRIGHT (C) 1986-2016 COMPUWARE CORPORATION.
001400*  UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT
001500*  LAWS OF THE UNITED STATES.
001600*
001700* ======================================================
001800*                   MODIFICATION  LOG
001900*
002000*  DD/MM/YY  PROGRAMMER  CHANGES
002100*  ********  **********  *******
002200*  96/01/24  ISPW        NEW PROGRAM
002300* ======================================================
002400 ENVIRONMENT DIVISION.
002500 CONFIGURATION SECTION.
002600 SOURCE-COMPUTER. IBM-370.
002700 OBJECT-COMPUTER. IBM-370.
002800
002900 INPUT-OUTPUT SECTION.
003000 FILE-CONTROL.
003100
003200********************************************************
003300*  FILES USED:
003400*   INPUT   JUST SOME DUMMY DATA TO READ IN
003500********************************************************
003600     SELECT INFILE  ASSIGN UT-S-INPUT
003700       ORGANIZATION IS SEQUENTIAL
003800       ACCESS IS SEQUENTIAL.
003900
004000
004100 DATA DIVISION.
004200
004300 FILE SECTION.
004400
004500 FD  INFILE
004600     LABEL RECORDS OMITTED
004700     BLOCK CONTAINS 0 RECORDS
004800     RECORDING MODE IS F
004900     DATA RECORD IS INPUT-REC.
005000
005100 01  INPUT-REC         PIC X(80).
005200
005300 WORKING-STORAGE SECTION.
005400
005500 01   INFILE-OPEN-FLAG     PIC X(1) VALUE 'N'.
005600      88 INFILE-OPEN       VALUE 'Y'.
005700
005800 LINKAGE SECTION.
005900********************************************************
006000**** A COPY MEMBER FOR THE LINKAGE AREA
006100*********************","This COBOL program is a training program called `TSUBR06` that reads dummy data from an input file. It is designed to be called from `TPROG06` and uses a copybook called `TCPYB06` for the linkage area. The program contains information about its author, creation date, and modification log. The input file `INFILE` is assigned for sequential access to read records with a length of 80 characters.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately represents the details and functionalities implemented within the source code.,0.004863687509482329,0.8499642014503479
py_7004,Python,"def update_inspection(self):
        """"""Wrapper method that calls the appropriate main updating methods of
        the inspection.

        It is meant to be used inside a loop (like while), so that it can
        continuously update the class attributes from the trace and log files.
        It already implements checks to parse these files only when they
        change, and they ignore entries that have been previously processes.
        """"""

        try:
            self.log_parser()
        except (FileNotFoundError, StopIteration) as e:
            logger.debug(""ERROR: "" + str(sys.exc_info()[0]))
            self.log_retry += 1
            if self.log_retry == self.MAX_RETRIES:
                raise e
        try:
            self.trace_parser()
        except (FileNotFoundError, StopIteration) as e:
            logger.debug(""ERROR: "" + str(sys.exc_info()[0]))
            self.trace_retry += 1
            if self.trace_retry == self.MAX_RETRIES:
                raise e","Wrapper method that calls the appropriate main updating methods of the inspection. It is meant to be used inside a loop (like while), so that it can continuously update the class attributes from the trace and log files. It already implements checks to parse these files only when they change, and they ignore entries that have been previously processed.","Wrapper method that calls the appropriate main updating methods of
        the inspection.

        It is meant to be used inside a loop (like while), so that it can
        continuously update the class attributes from the trace and log files.
        It already implements checks to parse these files only when they
        change, and they ignore entries that have been previously processes.",No Error,False,The generated documentation correctly and accurately describes the function and its behaviour.,0.9826020581357531,0.902868926525116
cob_syn_9450,COBOL,"      * REFACTOR CANDIDATE BATCH_9450
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                                                                *
      *                                                                *
      *                                                                *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGASTAT1.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      * Run time (debug) infomation for this invocation
        01  WS-ABSTIME                 PIC S9(8) COMP VALUE +0.
        01  WS-TIME                    Pic X(8).
       ",This COBOL program defines a program named LGASTAT1. It starts with licensing information and sets up working storage variables for run-time information such as the current time.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly reflects the information and functions of the provided source code.,0.01015265650850611,0.8715760707855225
py_13141,Python,"def date(start, end):
    """"""Get a random date between two dates""""""

    stime = date_to_timestamp(start)
    etime = date_to_timestamp(end)

    ptime = stime + random.random() * (etime - stime)

    return datetime.date.fromtimestamp(ptime)",Get a random date between two given dates.,Get a random date between two dates,No Error,False,The generated documentation correctly reflects what the source code does.,0.6803749333171202,0.9577741026878357
cob_syn_10689,COBOL,"      * REFACTOR CANDIDATE BATCH_10689
      * SYSTEM GENERATED
       >>SOURCE FORMAT FREE
IDENTIFICATION DIVISION.
PROGRAM-ID. example7.
AUTHOR. Ursin Filli
DATE-WRITTEN. April 29th 2020
ENVIRONMENT DIVISION.

DATA DIVISION.
FILE SECTION.
WORKING-STORAGE SECTION.
01 StartNum    PIC 9(8)V99 VALUE 00001123.55.
01 NoZero      PIC ZZZZZZZ9.99.
01 NoZPlusC    PIC ZZ,ZZZ,ZZ9.99.
01 Dollar      PIC $$,$$$,$$9.99.
01 BDay        PIC 9(8) VALUE 12211974.
01 ADate       PIC 99/99/9999.
PROCEDURE DIVISION.
MOVE StartNum TO NoZero
DISPLAY NoZero
MOVE StartNum TO NoZPlusC
DISPLAY NoZPlusC
MOVE StartNum TO Dollar
DISPLAY Dollar
MOVE BDay TO ADate
DISPLAY ADate

STOP RUN.
","This COBOL program defines numeric and date variables, assigns values to them, and displays them with specific formats. The program moves a starting number to different variables representing currency and numbers with various formats, and then displays them. Finally, it moves a birth date to a variable and displays it. The program concludes by stopping the execution.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation did not detail the fact that the 'StartNum' was initially assigned a value.,0.005433186420677938,0.8642074465751648
py_1921,Python,"def iter_http_requests(server, player):
    """"""Repeatedly accept HTTP connections on a server.

    Forever if the serving externally, or while a player is running if it is not
    empty.
    """"""

    while not player or player.running:
        try:
            yield server.open(timeout=2.5)
        except OSError:
            continue","Repeatedly accept HTTP connections on a server.

Forever if the serving externally, or while a player is running if it is not empty.","Repeatedly accept HTTP connections on a server.

    Forever if the serving externally, or while a player is running if it is not
    empty.",No Error,False,The documentation correctly describes the functionality of the source code.,1.0,0.938095211982727
py_5394,Python,"def parse_geo_tiff(
    key_dir_vlr: GeoKeyDirectoryVlr,
    double_vlr: GeoDoubleParamsVlr,
    ascii_vlr: GeoAsciiParamsVlr,
) -> List[GeoTiffKey]:
    """""" Parses the GeoTiff VLRs information into nicer structs
    """"""
    geotiff_keys = []

    for k in key_dir_vlr.geo_keys:
        if k.tiff_tag_location == 0:
            value = k.value_offset
        elif k.tiff_tag_location == 34736:
            value = double_vlr.doubles[k.value_offset]
        elif k.tiff_tag_location == 34737:
            try:
                value = ascii_vlr.strings[k.value_offset][k.count :]
            except IndexError:
                # Maybe I'm just misunderstanding the specification :thinking:
                value = ascii_vlr.strings[0][k.value_offset : k.value_offset + k.count]
        else:
            logger.warning(
                ""GeoTiffKey with unknown tiff tag location ({})"".format(
                    k.tiff_tag_location
                )
            )
            continue

        geotiff_keys.append(GeoTiffKey(k.id, value))
    return geotiff_keys","Parses the GeoTiff VLRs (Variable Length Records) information into nicer structs by extracting relevant data based on the tiff tag location from the GeoKeyDirectoryVlr, GeoDoubleParamsVlr, and GeoAsciiParamsVlr inputs. Returns a list of GeoTiffKey objects containing the extracted information.",Parses the GeoTiff VLRs information into nicer structs,No Error,False,The documentation accurately explains the function's logic and purpose with no unsupported claims or missing critical information.,0.12133716389700896,0.8821305632591248
py_12418,Python,"def first(self) -> Signature:
        """""" Retrieve the first Signature ordered by mangling descendant """"""
        k = sorted(self._hsig.keys())
        return self._hsig[k[0]]",Retrieve the first Signature ordered by mangling descendant.,Retrieve the first Signature ordered by mangling descendant,No Error,False,The generated documentation accurately represents what the code is doing.,0.8408964152537145,0.9650729298591614
py_70,Python,"def make_naive(value, timezone=None):
    """"""
    Make an aware datetime.datetime naive in a given time zone.

    :param value: datetime
    :param timezone: timezone
    :return: naive datetime
    """"""
    if timezone is None:
        timezone = TIMEZONE

    # Emulate the behavior of astimezone() on Python < 3.6.
    if is_naive(value):
        raise ValueError(""make_naive() cannot be applied to a naive datetime"")

    o = value.astimezone(timezone)

    # cross library compatibility
    naive = dt.datetime(o.year,
                        o.month,
                        o.day,
                        o.hour,
                        o.minute,
                        o.second,
                        o.microsecond)

    return naive",Make an aware datetime.datetime naive in a given time zone by converting it to the specified timezone and then creating a new naive datetime object based on the converted datetime values.,"Make an aware datetime.datetime naive in a given time zone.

    :param value: datetime
    :param timezone: timezone
    :return: naive datetime",No Error,False,The documentation accurately describes the functionality of the provided source code.,0.2840200788037191,0.8695254921913147
py_12793,Python,"def init_stage(self, name, config):

        '''Construct and configure a stage from known stages.

        `name` must be the name of one of the stages in this.  `config`
        is the configuration dictionary of the containing object, and its `name`
        member will be passed into the stage constructor.

        :param str name: name of the stage
        :param dict config: parent object configuration
        :return: callable stage
        :raise exceptions.KeyError: if `name` is not a known stage

        '''
        subconfig = config.get(name, {})
        ctor = self[name]
        return ctor(subconfig)","Construct and configure a stage from known stages. `name` must be the name of one of the stages in this. `config` is the configuration dictionary of the containing object, and its `name` member will be passed into the stage constructor. :param str name: name of the stage :param dict config: parent object configuration :return: callable stage :raise exceptions.KeyError: if `name` is not a known stage","Construct and configure a stage from known stages.

        `name` must be the name of one of the stages in this.  `config`
        is the configuration dictionary of the containing object, and its `name`
        member will be passed into the stage constructor.

        :param str name: name of the stage
        :param dict config: parent object configuration
        :return: callable stage
        :raise exceptions.KeyError: if `name` is not a known stage",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,0.9038814306259155
py_8690,Python,"def build_shape(relation, nodes, ways):
    """"""Extract shape of one route.""""""
    sequence_index = 0

    for member_type, member_id, member_role in relation.member_info:

        if member_id in nodes:
            yield Shape(
                relation.id,
                nodes[member_id].lat,
                nodes[member_id].lon,
                sequence_index)

            sequence_index += 1

        # Do we need to consider ways too? It dramatically increases the number of shapes.
        elif member_id in ways:
            continue
        #     for point in ways[member_id].points:
        #         shape = Shape(
        #             relation.id,
        #             point.lat,
        #             point.lon,
        #             sequence_index)
        #         sequence_index += 1

        else:
            # Ignore excessive logging for now.
            pass",Extract shape of one route.,Extract shape of one route.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,1.0
cob_syn_6810,COBOL,"      * REFACTOR CANDIDATE BATCH_6810
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. PROGRAMFILE.

       ENVIRONMENT DIVISION.
          INPUT-OUTPUT SECTION.
          FILE-CONTROL.
          SELECT STUDENT ASSIGN TO ""FILE001""
             ORGANIZATION IS SEQUENTIAL
             ACCESS IS SEQUENTIAL
             FILE STATUS IS FS.

       DATA DIVISION.
          FILE SECTION.
          FD STUDENT.
          01 STUDENT-FILE.
             05 STUDENT-ID PIC 9(5).
             05 NAME1 PIC A(25).
             05 CLASS1 PIC X(3).

          01 FS PIC XX.

          WORKING-STORAGE SECTION.

          01 WS-STUDENT.
             05 WS-STUDENT-ID PIC 9(5).
             05 WS-NAME PIC A(25).
             05 WS-CLASS PIC X(3).

          01 WS-EOF PIC A(1).

       PROCEDURE DIVISION.
       DISPLAY 'ProgramFILE:'.

          OPEN OUTPUT STUDENT.
             MOVE 1 TO STUDENT-ID.
             MOVE '  Tim' TO NAME1.
             MOVE '12' TO CLASS1.
             WRITE STUDENT-FILE
             END-WRITE.
          CLOSE STUDENT.

          OPEN EXTEND STUDENT.
             MOVE 2 TO STUDENT-ID.
             MOVE '  Kate' TO NAME1.
             MOVE '9' TO CLASS1.
             WRITE STUDENT-FILE
             END-WRITE.
          CLOSE STUDENT.

          OPEN INPUT STUDENT.
             PERFORM UNTIL WS-EOF='Y'
                READ STUDENT INTO WS-STUDENT
                   AT END MOVE 'Y' TO WS-EOF
                   NOT AT END DISPLAY WS-STUDENT
                END-READ
             END-PERFORM.
          CLOSE STUDENT.

       STOP RUN.
","This COBOL program defines a student file with fields for student ID, name, and class. It then writes two student records to the file and reads all records, displaying them on the screen until the end of the file is reached. The file ""FILE001"" is used for input/output operations with error handling using the file status variable FS.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the operations performed by the COBOL code without any unsupported claims or omissions.,0.005354194904142114,0.8623413443565369
cob_syn_6845,COBOL,"      * REFACTOR CANDIDATE BATCH_6845
      * SYSTEM GENERATED
       Identification Division.                                         00000001
       Program-ID. testantlr220.                                        00000002
       Data Division.                                                   00000003
       Working-Storage Section.                                         00000004
                                                                        00000005
       01  CONSTANTS.                                                   00000006
           05  MYNAME               PIC X(012) VALUE 'testantlr220'.    00000007
                                                                        00000008
       01 WORK-AREAS.                                                   00000009
          05  PGM-0004              PIC X(008) VALUE SPACES.            00000010
          05  PGM-0005              PIC X(008) VALUE SPACES.            00000011
              88  PGMB5                        VALUE 'PGMB0005'.        00000012
          05  PGM-0008-VAL          PIC X(008) VALUE 'PGMK0008'.        00000013
          05  PGM-0008 REDEFINES PGM-0008-VAL PIC X(008).               00000014
                                                                        00000015
       Procedure Division.                                              00000016
           DISPLAY MYNAME ' Begin'                                      00000017
                                                                        00000018
           CALL PGM-0008                                                00000019
                                                                        00000020
           DISPLAY MYNAME ' End'                                        00000021
                                                                        00000022
           GOBACK                                                       00000023
           .                                                            00000024
                                                        ","This COBOL program defines some constants and working storage areas. It displays a message indicating the beginning of the program, calls a subroutine identified as PGM-0008, displays a message indicating the end of the program, and then terminates.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.007633935801913548,0.8637865781784058
py_14909,Python,"def blank_canvas(width, height):
        """"""Return a blank canvas to annotate.

        :param width: xdim (int)
        :param height: ydim (int)
        :returns: :class:`jicbioimage.illustrate.Canvas`
        """"""
        canvas = np.zeros((height, width, 3), dtype=np.uint8)
        return canvas.view(Canvas)","Return a blank canvas in the form of a :class:`jicbioimage.illustrate.Canvas` object to annotate, given the width and height provided as integer values.","Return a blank canvas to annotate.

        :param width: xdim (int)
        :param height: ydim (int)
        :returns: :class:`jicbioimage.illustrate.Canvas`",Omission,True,"The documentation does not mention the necessity of the np.zeros function, and the Canvas class view return.",0.1196655750514248,0.8559497594833374
py_9347,Python,"def duplicate(self, new_parent=None):
        ""Create a new object exactly similar to self""
        kwargs = {}
        for spec_name, spec in self._meta.specs.items():
            value = getattr(self, spec_name)
            if isinstance(value, Color):
                print ""COLOR"", value, value.default
                if value.default:
                    value = None
            if value is not None:
                kwargs[spec_name] = value
        del kwargs['parent'] 
        new_id = wx.NewId()
        kwargs['id'] = new_id
        kwargs['name'] = ""%s_%s"" % (kwargs['name'], new_id)
        new_obj = self.__class__(new_parent or self.get_parent(), **kwargs)
        # recursively create a copy of each child (in the new parent!)
        for child in self:
            child.duplicate(new_obj)
        return new_obj",Create a new object exactly similar to self.,Create a new object exactly similar to self,Omission,True,"The documentation doesn't explain the role of the 'new_parent' argument or the specifics of the object duplication process, and does not mention that the function also handles Color type values differently.",0.8408964152537145,0.9843568205833435
py_13861,Python,"def multiple_replace(dict, text):
    """""" Replace in 'text' all occurences of any key in the given
    dictionary by its corresponding value.  Returns the new string.""""""

    # Function by Xavier Defrang, originally found at:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/81330

    # Create a regular expression  from the dictionary keys
    regex = re.compile(""(%s)"" % ""|"".join(map(re.escape, dict.keys())))
    # For each match, look-up corresponding value in dictionary
    return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)",Replace in 'text' all occurrences of any key in the given dictionary by its corresponding value. Returns the new string.,"Replace in 'text' all occurences of any key in the given
    dictionary by its corresponding value.  Returns the new string.",No Error,False,The generated documentation accurately describes the function's behavior.,0.8578928092681435,0.9476514458656311
cob_syn_3943,COBOL,"      * REFACTOR CANDIDATE BATCH_3943
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HCTRESTW.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

      *****************************************************************
      *    DFHJS2WS GENERATED COPYBOOKS
      *****************************************************************

        01 JSON-REST-DATA.

      * start of expanded file: C:\REGI_EZSOURCE\IBMUSER.ZMOBILE.COPYLIB\HCTRST01.cpy at HCTRESTW.cbl line 31
      * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * This file contains the generated language structure(s) for
      *  restful JSON schema 'getThreshold.json'.
      * This structure was generated using 'DFHJS2LS' at mapping level
      *  '3.0'.
      *
      *
      *      06 patient-threshold-i","This COBOL program defines a working storage section with a data structure named `JSON-REST-DATA`. The program's purpose seems to involve processing RESTful JSON data related to patient thresholds, as indicated by the structure comment mentioning 'getThreshold.json'.",Legacy COBOL logic requiring documentation.,No Error,False,"The documentation accurately represents the source code's functionality, with no unsupported claims or omissions.",0.007986728673290205,0.8569499850273132
cob_syn_5055,COBOL,"      * REFACTOR CANDIDATE BATCH_5055
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. PRECEDENCE.
 PROCEDURE DIVISION.
    DISPLAY ""Hello World"".
    STOP RUN.","This COBOL program simply displays ""Hello World"" and then stops the program execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the basic functionality of the provided COBOL code.,0.018724372764461875,0.8876917362213135
cob_syn_6787,COBOL,"      * REFACTOR CANDIDATE BATCH_6787
      * SYSTEM GENERATED
       fd   pd00400.
       
       01   f00400-municipio.
            03 f00400-cd-empresa                   pic 9(03).
            03 f00400-cd-filial                    pic 9(04).
            03 f00400-id-municipio                 pic 9(09).
            03 f00400-cd-municipio                 pic 9(07).
            03 f00400-nome-municipio               pic x(55).
            03 f00400-id-estado                    pic 9(09). 
       
      


","This COBOL code defines a file structure named ""pd00400"" with a record structure ""f00400-municipio"" containing fields for municipality information such as company code, branch code, municipality ID, municipality code, municipality name, and state ID.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately reflects the provided source code.,0.008377152169377823,0.8500202894210815
cob_real_3293,COBOL,"      ******************************************************************
      * Copyright 2014 IBM Corp. All Rights Reserved.
      *
      * Licensed under the Apache License, Version 2.0 (the ""License"");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
      * either express or implied.
      * See the License for the specific language governing permissions
      * and limitations under the License.
      ******************************************************************
      *                                                                *
      *                    ADD Medication                              *
      *                                                                *
      *   Business logic for adding a new medication & prescription    *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HCMABA01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *----------------------------------------------------------------*
      * Common defintions                                              *
      *----------------------------------------------------------------*
      * Run time (debug) infomation for this invocation
        01  WS-HEADER.
           03 WS-EYECATCHER            PIC X(16)
                                        VALUE 'HCMABA01------WS'.
           03 WS-TRANSID               P",This COBOL program is a module named HCMABA01 designed for adding a new medication and prescription in a healthcare system. It contains the business logic for this functionality and includes common definitions and working storage sections for runtime information. The program starts with copyright information and details about the Apache License version 2.0 under which it is licensed.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the given code segment.,0.0063672466751171115,0.8646109104156494
cob_syn_2806,COBOL,"      * REFACTOR CANDIDATE BATCH_2806
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. AOC-2021-01-2.
       AUTHOR. ANNA KOSIERADZKA.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT INPUTFILE ASSIGN TO ""d01.input""
           ORGANIZATION IS LINE SEQUENTIAL.

       DATA DIVISION.

       FILE SECTION.
         FD INPUTFILE.
         01 INPUTRECORD PIC X(4).

       WORKING-STORAGE SECTION.
         01 FILE-STATUS PIC 9 VALUE 0.
         01 WS-MEASURE PIC 9(5).
         01 WS-PREV-MEASURE PIC 9(5) VALUE 99999.
         01 WS-CURR PIC 9(4) VALUE 9999.
         01 WS-PREV-1 PIC 9(4) VALUE 9999.
         01 WS-PREV-2 PIC 9(4) VALUE 9999.
         01 WS-PREV-3 PIC 9(4) VALUE 9999.
         01 WS-NUM PIC 9(4) VALUE 0.

       PROCEDURE DIVISION.
       001-MAIN.
            OPEN INPUT INPUTFILE.
            PERFORM 002-READ UNTIL FILE-STATUS = 1.
            CLOSE INPUTFILE.
            DISPLAY WS-NUM.
            STOP RUN.

       002-READ.
            READ INPUTFILE
                AT END MOVE 1 TO FILE-STATUS
                NOT AT END PERFORM 003-PROCESS-RECORD
            END-READ.

       003-PROCESS-RECORD.
           COMPUTE WS-CURR = FUNCTION NUMVAL(INPUTRECORD)
           COMPUTE WS-MEASURE = WS-CURR + WS-PREV-MEASURE - WS-PREV-1
           IF WS-MEASURE > WS-PREV-MEASURE THEN
               ADD 1 TO WS-NUM
           END-IF
           COMPUTE WS-PREV-MEASURE = WS-MEASURE
           MOVE WS-PREV-2 TO WS-PREV-1
           MOVE WS-PREV-3 TO WS-PREV-2
           MOVE WS-CURR TO WS-PREV-3.
","This COBOL program reads input records from a file, calculates a measure based on the values, and increments a counter if the measure is greater than the previous measure. The final count is displayed at the end.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention how the measure is calculated involving past three values in the chain.,0.007805988703535686,0.8703626394271851
cob_syn_4658,COBOL,"      * REFACTOR CANDIDATE BATCH_4658
      * SYSTEM GENERATED
      ******************************************************************
      * Copyright 2011,2014 IBM Corp. All Rights Reserved.
      *
      * Licensed under the Apache License, Version 2.0 (the ""License"");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing,
      * software distributed under the License is distributed on an
      * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
      * either express or implied.
      * See the License for the specific language governing permissions
      * and limitations under the License.
      ******************************************************************
      * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      * This file contains the generated language structure(s) for
      *  restful JSON schema 'getPatient.json'.
      * This structure was generated using 'DFHJS2LS' at mapping level
      *  '3.0'.
      *
      *
      *      06 patient-personal-information.
      *
      * Comments for field 'patient-id':
      * This field represents the value of JSON schema keyword
      *  'patient_personal_information->patient_id'.
      * JSON schema type: 'string'.
      * JSON schema keyword 'minLength' value: '10'.
      * JSON schema keyword 'maxLength' value: '10'.
      *        09 patient-id                    PIC X(10).
      *
      * Comments for field 'insurance-card-number':
      * This field represents the value of JSON schema keyword
      *  'patient_personal_information->insurance_card_number'.
      * JSON schema type: 'string'.
      * JSON schema keyword 'minLength' value: '10'.
      * JSON schema keyword 'maxLength' value: '10'.
      *        09 insurance-card-number         PIC X(10).
      *
      * Comments for field 'first-name':
  ","This COBOL code defines a structure for a RESTful JSON schema named 'getPatient.json'. It includes fields for patient personal information such as patient ID and insurance card number, each with a length of 10 characters represented as PIC X(10) in the code. The comments provide details on the JSON schema type and the minimum/maximum length values for each field.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the code and does not omit any important information.,0.005277645918110919,0.8529155850410461
cob_real_1029,COBOL,"Caligari V00.01ALH             
BitM V0.01 Id 0 Parent 0 Size 00006349
ThumbNailHdrSize 40
ThumbHeader:28 00 00 00 5e 00 00 00 5e 00 00 00 01 00 18 00 00 00 00 00 48 68 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
ColorBufSize 26696
ColorBufZipSize 2046
ZippedThumbnail:78 9c ed 9b 3f 8b 1b 49 10 c5 fd 19 05 0e 34 a0 40 34 13 88 46 81 11 17 2c e2 12 23 1c 18 71 81 11 0e 8c b8 e0 60 1d 18 e4 e0 60 2f 30 cc 7d b6 ab ee aa 7a 55 3d eb 0b bc 9a d1 8c ec 86 46 e8 df ca 9a 9f 5e 55 bd aa 6e 77 ff 76 5d 5d df 5b af 5e 4d fe 15 66 bb 2a 9b ca a6 b2 a9 6c 2a 9b e9 57 65 53 d9 54 36 95 4d 65 33 fd aa 6c 2a 9b ca a6 b2 a9 6c a6 5f 95 4d 65 53 d9 54 36 95 cd f4 ab b2 a9 6c 2a 9b ca a6 b2 99 7e 55 36 95 4d 65 f3 eb b1 79 fa e7 e9 f1 f3 63 f7 ed 17 64 43 97 7e f9 72 39 ff 79 3e fe 71 3c 7d 38 1d 7e df ef 69 3d ec e3 36 86 75 b3 7b 13 43 1b 9a 65 43 b7 a7 0f c7 a7 bf 9f 7e 5e 36 44 e2 f0 ee b0 fb 6d 17 37 74 e9 81 57 6c f3 9d 36 ad b8 91 db 66 d5 84 55 93 6e f9 6d ab 84 87 1e d2 df 26 19 fd 6c 6c 48 1c e9 a2 97 7c b9 4d b3 5c 30 00 5b 4a 28 ad 75 02 43 2b 51 cc b4 6c d1 c3 6d 3c 7f 3a fd 1c 6c be 75 24 17 08 a2 c9 22 20 12 e9 fe 92 a9 a4 95 c5 24 42 69 94 16 3d 99 60 60 65 36 fc e7 14 83 77 ce e6 fc 29 c9 45 42 03 48 92 20 44 1f 21 8b 23 25 98 15 13 0a 16 4a 6b e6 e1 f0 48 30 26 a8 f4 b6 f1 f0 8c cf 86 e4 22 e9 64 ad bf 37 e3 c9 e9 55 d8 28 00 7e c6 83 91 97 1c 18 7c 08 a3 a5 37 1f de 1e ee 90 0d 95 1e 09 1f 77 7d a8 3b 0e 95 c0 e0 98 d2 28 7b 46 b4 0d 54 b6 44 6d 82 47 70 52 69 bb 2b 36 a4 76 49 a3 7a 1d e9 0e 12 0c c5 51 a6 c2 4f 72 64 71 98 a4 1c bd 6c 04 58 5b 0a 68 2b ba 41 e2 91 7f 62 1b 07 57 cf 68 6c 48 31 fe bb cb e2 2c bc 92 02 e4 65 61 cf 2f e5 55 49 d3 6b 4d dc d0 df c6 f4 47 48 50 cb 9a d7 8b 84 67 38 8b 38 0e 1b 02 13 7a 54 72 82 a1 af 9f 6e e5 ce c2 6e 57 ae 54 b9 64 0d 4f 03 7f 53 2c 2d 67 4c 6b 91 3f 67 f7 66 37 14 9e 11 d8 9c 32 18 63 b3 16 59 64 2a 0b 8e 17 bd 8f 20 72 0b 54 10 65 88 41 85 8d b0 4a ef 51 39 26 36 99 3d 3d 4f 0e 73 7e 6c 4e 1f 4f fc 03 9","This COBOL code appears to be a metadata header containing information such as version, ID, parent, size, thumbnail information, color buffer size, and zipped thumbnail data. The code may be responsible for managing and storing metadata information related to a file or image.",Legacy COBOL logic requiring documentation.,Fabricated Variable,True,"The generated documentation erroneously indicates that the provided code is written in COBOL language, but there's no evidence in the source code to support this claim.",0.006883858510498897,0.8670353889465332
py_5072,Python,"def read(self):
        """"""Read incoming message.""""""
        packet = self.packet
        with self.__read_lock:
            buffer = self.__buffer
            while len(buffer) < packet:
                buffer += self._read_data()
            length = self.__unpack(buffer[:packet])[0] + packet
            while len(buffer) < length:
                buffer += self._read_data()
            term, self.__buffer = decode(buffer[packet:])
        return term",Reads incoming messages and decodes the message contents after receiving a full packet as per the specified length.,Read incoming message.,No Error,False,The documentation accurately describes the function's behavior as depicted in the source code.,0.014238348381961592,0.8825153112411499
py_6222,Python,"def report(self):
        """"""
        Report elapsed time.
        """"""
        if not self.end_time:
            self.end()
        print (""Time: {} mins"".format((self.end_time - self.start_time )/ 60))","Report elapsed time. If the end time is not set, it will be automatically set. Then, it calculates and prints the elapsed time in minutes.",Report elapsed time.,No Error,False,"All claims in the documentation are supported by the code, and no critical information is omitted.",0.05022135506220879,0.8922746777534485
py_9722,Python,"def send_password_reset(self):
        """"""Send a password reset to the user's email address.""""""
        site = Site.objects.get_current()
        self.password_reset_notification(user=self, site=site).notify()",Send a password reset to the user's email address.,Send a password reset to the user's email address.,No Error,False,The documentation accurately describes the function of the code.,1.0,0.9999999403953552
py_7133,Python,"def read_features(self, tol=1e-3):
        """"""Reads the features from a file and stores them in the current
        object.

        Parameters
        ----------
        tol: float
            Tolerance level to detect duration of audio.
        """"""
        try:
            # Read JSON file
            with open(self.file_struct.features_file) as f:
                feats = json.load(f)

            # Store duration
            if self.dur is None:
                self.dur = float(feats[""globals""][""dur""])

            # Check that we have the correct global parameters
            assert(np.isclose(
                self.dur, float(feats[""globals""][""dur""]), rtol=tol))
            assert(self.sr == int(feats[""globals""][""sample_rate""]))
            assert(self.hop_length == int(feats[""globals""][""hop_length""]))
            assert(os.path.basename(self.file_struct.audio_file) ==
                   os.path.basename(feats[""globals""][""audio_file""]))

            # Check for specific features params
            feat_params_err = FeatureParamsError(
                ""Couldn't find features for %s id in file %s"" %
                (self.get_id(), self.file_struct.features_file))
            if self.get_id() not in feats.keys():
                raise feat_params_err
            for param_name in self.get_param_names():
                value = getattr(self, param_name)
                if hasattr(value, '__call__'):
                    # Special case of functions
                    if value.__name__ != \
                            feats[self.get_id()][""params""][param_name]:
                        raise feat_params_err
                else:
                    if str(value) != \
                            feats[self.get_id()][""params""][param_name]:
                        raise feat_params_err

            # Store actual features
            self._est_beats_times = np.array(feats[""est_beats""])
            self._est_beatsync_times = np.array(feats[""est_beatsync_times""])
            self._est_beats_frames = librosa.core.time_to_frames(
                self._est_beats_times, sr=self.sr, hop_length=self.hop_length)
            self._framesync_features = \
                np.array(feats[self.get_id()][""framesync""])
            self._est_beatsync_features = \
                np.array(feats[self.get_id()][""est_beatsync""])

            # Read annotated beats if available
            if ""ann_beats"" in feats.keys():
                self._ann_beats_times = np.array(feats[""ann_beats""])
                self._ann_beatsync_times = np.array(feats[""ann_beatsync_times""])
                self._ann_beats_frames = librosa.core.time_to_frames(
                    self._ann_beats_times, sr=self.sr,
                    hop_length=self.hop_length)
                self._ann_beatsync_features = \
                    np.array(feats[self.get_id()][""ann_beatsync""])
        except KeyError:
            raise WrongFeaturesFormatError(
                ""The features file %s is not correctly formatted"" %
                self.file_struct.features_file)
        except AssertionError:
            raise FeaturesNotFound(
                ""The features for the given parameters were not found in ""
                ""features file %s"" % self.file_struct.features_file)
        except IOError:
            raise NoFeaturesFileError(""Could not find features file %s"",
                                      self.file_struct.features_file)","""""""Reads the features from a file and stores them in the current object.

        Parameters
        ----------
        tol: float
            Tolerance level to detect duration of audio.
""""""","Reads the features from a file and stores them in the current
        object.

        Parameters
        ----------
        tol: float
            Tolerance level to detect duration of audio.",Omission,True,The documentation omits the details of the exceptions that could be raised by the function and what they imply.,0.9146912192286945,0.9662258625030518
py_1916,Python,"def iter_chunks(self, fd=None, buf=None, skip_header=None):
        """"""Reads FLV tags from fd or buf and returns them with adjusted
           timestamps.""""""
        timestamps = dict(self.timestamps_add)
        tag_iterator = self.iter_tags(fd=fd, buf=buf, skip_header=skip_header)

        if not self.flv_header_written:
            analyzed_tags = self.analyze_tags(tag_iterator)
        else:
            analyzed_tags = []

        for tag in chain(analyzed_tags, tag_iterator):
            if not self.flv_header_written:
                flv_header = Header(has_video=self.has_video,
                                    has_audio=self.has_audio)
                yield flv_header.serialize()
                self.flv_header_written = True

            if self.verify_tag(tag):
                self.adjust_tag_gap(tag)
                self.adjust_tag_timestamp(tag)

                if self.duration:
                    norm_timestamp = tag.timestamp / 1000
                    if norm_timestamp > self.duration:
                        break
                yield tag.serialize()
                timestamps[tag.type] = tag.timestamp

        if not self.flatten_timestamps:
            self.timestamps_add = timestamps

        self.tags = []","This function iterates over FLV tags read from a file descriptor (fd) or a buffer (buf), adjusts the timestamps of the tags, and yields the tags with the adjusted timestamps. If the FLV header has not been written yet, it writes the FLV header with information about video and audio streams. It continues processing the tags, adjusting their timestamps, and serializing them while updating the timestamps dictionary. Finally, it updates the timestamps dictionary to reflect the adjusted timestamps and clears the tags list.","Reads FLV tags from fd or buf and returns them with adjusted
           timestamps.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.014128565127520061,0.8204988837242126
cob_syn_96,COBOL,"      * REFACTOR CANDIDATE BATCH_96
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    ADD Customer                                *

      *   To add customer's password to the secutity table with        *
      *  details. Default password is BD5 checksum                     *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGACDB02.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.

       WORKING-STORAGE SECTION.

      *----------------------------------------------------------------*
      * Common defintions                                              *
      *----------------------------------------------------------------*
      * Run time (debug) infomation for this invocation
       ","This COBOL program, identified as LGACDB02, is designed to add a customer's password to a security table along with details. The default password used for the customers is BD5 checksum. The program includes licensed materials owned by IBM and contains restrictions on the use, duplication, or disclosure of the code.",Legacy COBOL logic requiring documentation.,Omission,True,"The generated documentation does not explain or mention the ""COMMON DEFINITIONS"" and ""RUN TIME (DEBUG) INFORMATION"" for this invocation, which can be important details in the source code.",0.006065997938636506,0.8614529967308044
cob_syn_5226,COBOL,"      * REFACTOR CANDIDATE BATCH_5226
      * SYSTEM GENERATED
000001 Identification Division.
000002 Program-ID. testantlr143.
000003 Data Division.
000004 Working-Storage Section.
000005
000006 01  CONSTANTS.
000007     05  MYNAME               PIC X(012) VALUE 'testantlr143'.
000008     >>EVALUATE TRUE
000009     >>WHEN X = 1
000010     05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.
000011     >>WHEN X = 2
000012     05  PGM-0001             PIC X(008) VALUE 'PGMA0002'.
000013     >>WHEN X = 3
000014     05  PGM-0001             PIC X(008) VALUE 'PGMA0003'.
000015     >>WHEN OTHER
000016     05  PGM-0001             PIC X(008) VALUE 'PGMA0009'.
000017     >>END-EVALUATE
000018
000019*
000020
000021 Procedure Division.
000022     DISPLAY MYNAME ' Begin'
000023     CALL PGM-0001
000024
000025     DISPLAY MYNAME ' End'
000026     
000027     GOBACK
000028     .
000029
000030
","This COBOL program defines a set of constants and a conditional statement that sets the value of the variable PGM-0001 based on the value of variable X. Then, the program displays the value of MYNAME followed by ""Begin"", calls a program based on the value of PGM-0001, displays the value of MYNAME followed by ""End"", and then ends the program.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention that it is a system generated program and that it is a refactoring candidate for BATCH_5226.,0.005203424609196104,0.846274733543396
cob_real_2848,COBOL,"01  CUSTOMER-RECORD.
       05  LAST-NAME               PIC X(15).
       05  FIRST-NAME              PIC X(8).
       05  STREET-ADDRESS          PIC X(20).
       05  CITY                    PIC X(17).
       05  STATE                   PIC XX.
       05  ZIP-CODE                PIC 9(5).
       05  FILLER                  PIC X(10).","This COBOL code defines a data structure for a customer record with fields for last name, first name, street address, city, state, zip code, and filler. The data types and lengths of each field are specified using PIC clauses.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects what the source code does.,0.007469938459592591,0.8583769202232361
py_1997,Python,"def monochrome(I, color, vmin=None, vmax=None):
    """"""Turns a intensity array to a monochrome 'image' by replacing each intensity by a scaled 'color'

    Values in I between vmin  and vmax get scaled between 0 and 1, and values outside this range are clipped to this.

    Example
    >>> I = np.arange(16.).reshape(4,4)
    >>> color = (0, 0, 1) # red
    >>> rgb = vx.image.monochrome(I, color) # shape is (4,4,3)

    :param I: ndarray of any shape (2d for image)
    :param color: sequence of a (r, g and b) value
    :param vmin: normalization minimum for I, or np.nanmin(I) when None
    :param vmax: normalization maximum for I, or np.nanmax(I) when None
    :return:
    """"""
    if vmin is None:
        vmin = np.nanmin(I)
    if vmax is None:
        vmax = np.nanmax(I)
    normalized = (I - vmin) / (vmax - vmin)
    return np.clip(normalized[..., np.newaxis], 0, 1) * np.array(color)","""""""Turns a intensity array to a monochrome 'image' by replacing each intensity by a scaled 'color'

Values in I between vmin and vmax get scaled between 0 and 1, and values outside this range are clipped to this.
Example:
    I = np.arange(16.).reshape(4,4)
    color = (0, 0, 1) # red
    rgb = vx.image.monochrome(I, color) # shape is (4,4,3)

:param I: ndarray of any shape (2d for image)
:param color: sequence of a (r, g and b) value
:param vmin: normalization minimum for I, or np.nanmin(I) when None
:param vmax: normalization maximum for I, or np.nanmax(I) when None
:return: ndarray representing the monochrome 'image' of shape (4,4,3) colored based on the intensity values""""""","Turns a intensity array to a monochrome 'image' by replacing each intensity by a scaled 'color'

    Values in I between vmin  and vmax get scaled between 0 and 1, and values outside this range are clipped to this.

    Example
    >>> I = np.arange(16.).reshape(4,4)
    >>> color = (0, 0, 1) # red
    >>> rgb = vx.image.monochrome(I, color) # shape is (4,4,3)

    :param I: ndarray of any shape (2d for image)
    :param color: sequence of a (r, g and b) value
    :param vmin: normalization minimum for I, or np.nanmin(I) when None
    :param vmax: normalization maximum for I, or np.nanmax(I) when None
    :return:",No Error,False,The generated code explanation is clear and makes sense in the context of the code. There are no hallucinations or omissions present.,0.8118001108959095,0.9444953203201294
cob_syn_5627,COBOL,"      * REFACTOR CANDIDATE BATCH_5627
      * SYSTEM GENERATED
01  things occurs 3.
...
set content of things to (""Apple"", ""Banana"", ""Coconut"")
perform varying thing as string through things
    display thing
end-perform
","This COBOL program initializes an array called 'things' with three elements: ""Apple"", ""Banana"", and ""Coconut"". Then, it iterates through each element in the array and displays it on the screen using a 'perform' loop.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation correctly captures the main operations performed by the source code.,0.008377152169377823,0.8577689528465271
py_10276,Python,"def calculateFields(self):
        """"""Write calculated fields for read buffer.""""""
        pf1 = self.m_blk_b[Field.Cos_Theta_Ln_1][MeterData.StringValue]
        pf2 = self.m_blk_b[Field.Cos_Theta_Ln_2][MeterData.StringValue]
        pf3 = self.m_blk_b[Field.Cos_Theta_Ln_3][MeterData.StringValue]

        pf1_int = self.calcPF(pf1)
        pf2_int = self.calcPF(pf2)
        pf3_int = self.calcPF(pf3)

        self.m_blk_b[Field.Power_Factor_Ln_1][MeterData.StringValue] = str(pf1_int)
        self.m_blk_b[Field.Power_Factor_Ln_2][MeterData.StringValue] = str(pf2_int)
        self.m_blk_b[Field.Power_Factor_Ln_3][MeterData.StringValue] = str(pf3_int)

        self.m_blk_b[Field.Power_Factor_Ln_1][MeterData.NativeValue] = pf1_int
        self.m_blk_b[Field.Power_Factor_Ln_2][MeterData.NativeValue] = pf2_int
        self.m_blk_b[Field.Power_Factor_Ln_3][MeterData.NativeValue] = pf2_int

        rms_watts_1 = self.m_blk_b[Field.RMS_Watts_Ln_1][MeterData.NativeValue]
        rms_watts_2 = self.m_blk_b[Field.RMS_Watts_Ln_2][MeterData.NativeValue]
        rms_watts_3 = self.m_blk_b[Field.RMS_Watts_Ln_3][MeterData.NativeValue]

        sign_rms_watts_1 = 1
        sign_rms_watts_2 = 1
        sign_rms_watts_3 = 1

        direction_byte = self.m_blk_a[Field.State_Watts_Dir][MeterData.NativeValue]

        if direction_byte == DirectionFlag.ForwardForwardForward:
            # all good
            pass
        if direction_byte == DirectionFlag.ForwardForwardReverse:
            sign_rms_watts_3 = -1
            pass
        if direction_byte == DirectionFlag.ForwardReverseForward:
            sign_rms_watts_2 = -1
            pass
        if direction_byte == DirectionFlag.ReverseForwardForward:
            sign_rms_watts_1 = -1
            pass
        if direction_byte == DirectionFlag.ForwardReverseReverse:
            sign_rms_watts_2 = -1
            sign_rms_watts_3 = -1
            pass
        if direction_byte == DirectionFlag.ReverseForwardReverse:
            sign_rms_watts_1 = -1
            sign_rms_watts_3 = -1
            pass
        if direction_byte == DirectionFlag.ReverseReverseForward:
            sign_rms_watts_1 = -1
            sign_rms_watts_2 = -1
            pass
        if direction_byte == DirectionFlag.ReverseReverseReverse:
            sign_rms_watts_1 = -1
            sign_rms_watts_2 = -1
            sign_rms_watts_3 = -1
            pass

        net_watts_1 = rms_watts_1 * sign_rms_watts_1
        net_watts_2 = rms_watts_2 * sign_rms_watts_2
        net_watts_3 = rms_watts_3 * sign_rms_watts_3
        net_watts_tot = net_watts_1 + net_watts_2 + net_watts_3

        self.m_blk_b[Field.Net_Calc_Watts_Ln_1][MeterData.NativeValue] = net_watts_1
        self.m_blk_b[Field.Net_Calc_Watts_Ln_2][MeterData.NativeValue] = net_watts_2
        self.m_blk_b[Field.Net_Calc_Watts_Ln_3][MeterData.NativeValue] = net_watts_3
        self.m_blk_b[Field.Net_Calc_Watts_Tot][MeterData.NativeValue] = net_watts_tot

        self.m_blk_b[Field.Net_Calc_Watts_Ln_1][MeterData.StringValue] = str(net_watts_1)
        self.m_blk_b[Field.Net_Calc_Watts_Ln_2][MeterData.StringValue] = str(net_watts_2)
        self.m_blk_b[Field.Net_Calc_Watts_Ln_3][MeterData.StringValue] = str(net_watts_3)
        self.m_blk_b[Field.Net_Calc_Watts_Tot][MeterData.StringValue] = str(net_watts_tot)

        pass",Write calculated fields for read buffer.,Write calculated fields for read buffer.,No Error,False,The documentation correctly summarizes the function without any hallucinations or omissions.,1.0,1.0000003576278687
py_1873,Python,"def update_policies(
            self, resource_group_name, registry_name, quarantine_policy=None, trust_policy=None, custom_headers=None, raw=False, polling=True, **operation_config):
        """"""Updates the policies for the specified container registry.

        :param resource_group_name: The name of the resource group to which
         the container registry belongs.
        :type resource_group_name: str
        :param registry_name: The name of the container registry.
        :type registry_name: str
        :param quarantine_policy: An object that represents quarantine policy
         for a container registry.
        :type quarantine_policy:
         ~azure.mgmt.containerregistry.v2018_02_01_preview.models.QuarantinePolicy
        :param trust_policy: An object that represents content trust policy
         for a container registry.
        :type trust_policy:
         ~azure.mgmt.containerregistry.v2018_02_01_preview.models.TrustPolicy
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: The poller return type is ClientRawResponse, the
         direct response alongside the deserialized response
        :param polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :return: An instance of LROPoller that returns RegistryPolicies or
         ClientRawResponse<RegistryPolicies> if raw==True
        :rtype:
         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.containerregistry.v2018_02_01_preview.models.RegistryPolicies]
         or
         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.containerregistry.v2018_02_01_preview.models.RegistryPolicies]]
        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`
        """"""
        raw_result = self._update_policies_initial(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            quarantine_policy=quarantine_policy,
            trust_policy=trust_policy,
            custom_headers=custom_headers,
            raw=True,
            **operation_config
        )

        def get_long_running_output(response):
            deserialized = self._deserialize('RegistryPolicies', response)

            if raw:
                client_raw_response = ClientRawResponse(deserialized, response)
                return client_raw_response

            return deserialized

        lro_delay = operation_config.get(
            'long_running_operation_timeout',
            self.config.long_running_operation_timeout)
        if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)","Updates the policies for the specified container registry by allowing the user to set quarantine policies, trust policies, custom headers, and polling preferences. The function returns an instance of LROPoller that provides the updated RegistryPolicies or a ClientRawResponse object based on the value of the `raw` parameter. Raises a CloudError if an error occurs during the process.","Updates the policies for the specified container registry.

        :param resource_group_name: The name of the resource group to which
         the container registry belongs.
        :type resource_group_name: str
        :param registry_name: The name of the container registry.
        :type registry_name: str
        :param quarantine_policy: An object that represents quarantine policy
         for a container registry.
        :type quarantine_policy:
         ~azure.mgmt.containerregistry.v2018_02_01_preview.models.QuarantinePolicy
        :param trust_policy: An object that represents content trust policy
         for a container registry.
        :type trust_policy:
         ~azure.mgmt.containerregistry.v2018_02_01_preview.models.TrustPolicy
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: The poller return type is ClientRawResponse, the
         direct response alongside the deserialized response
        :param polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :return: An instance of LROPoller that returns RegistryPolicies or
         ClientRawResponse<RegistryPolicies> if raw==True
        :rtype:
         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.containerregistry.v2018_02_01_preview.models.RegistryPolicies]
         or
         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.containerregistry.v2018_02_01_preview.models.RegistryPolicies]]
        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`",No Error,False,The generated documentation accurately represents the functionality and parameters of the source code.,0.055080240311617804,0.7761844396591187
py_1643,Python,"def replace(
            self, word_alterations, custom_headers=None, raw=False, **operation_config):
        """"""Replace alterations data.

        :param word_alterations: Collection of word alterations.
        :type word_alterations:
         list[~azure.cognitiveservices.knowledge.qnamaker.models.AlterationsDTO]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.cognitiveservices.knowledge.qnamaker.models.ErrorResponseException>`
        """"""
        word_alterations1 = models.WordAlterationsDTO(word_alterations=word_alterations)

        # Construct URL
        url = self.replace.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url(""self.config.endpoint"", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(word_alterations1, 'WordAlterationsDTO')

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ErrorResponseException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response","Replace alterations data. 

:param word_alterations: Collection of word alterations.
:type word_alterations: list[~azure.cognitiveservices.knowledge.qnamaker.models.AlterationsDTO]
:param dict custom_headers: headers that will be added to the request
:param bool raw: returns the direct response alongside the deserialized response
:param operation_config: :ref:`Operation configuration overrides<msrest:optionsforoperations>`.
:return: None or ClientRawResponse if raw=true
:rtype: None or ~msrest.pipeline.ClientRawResponse
:raises: :class:`ErrorResponseException<azure.cognitiveservices.knowledge.qnamaker.models.ErrorResponseException>`","Replace alterations data.

        :param word_alterations: Collection of word alterations.
        :type word_alterations:
         list[~azure.cognitiveservices.knowledge.qnamaker.models.AlterationsDTO]
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorResponseException<azure.cognitiveservices.knowledge.qnamaker.models.ErrorResponseException>`",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,0.8886529207229614
cob_syn_260,COBOL,"      * REFACTOR CANDIDATE BATCH_260
      * SYSTEM GENERATED
      * LOOKUP 
        01 WS-LOOKUP-FIELDS.
          05 WS-LOOKUP-TYPE             PIC X(01).
             88 PRODUCT-LOOKUP                    VALUE 'P'.
             88 SALES-LOOKUP                      VALUE 'S'.
             88 INVALID-LOOKUP-TYPE               VALUE 'I'.
             88 INVALID-LOOKUP-KEY                VALUE 'K'.
             88 SUCESSFUL-LOOKUP                  VALUE '0'.
          05 WS-LOOKUP-AREA.
             10 WS-SALES-ID             PIC X(03)    VALUE SPACES.
             10 WS-PRODUCT-ID           PIC X(05)    VALUE SPACES.
             10 WS-SALES-NAME           PIC X(15)    VALUE SPACES.
             10 WS-PRODUCT-NAME         PIC X(10)    VALUE SPACES.
             10 WS-PRODUCT-PRICE-X      PIC X(07)    VALUE SPACES.
             10 WS-PRODUCT-PRICE REDEFINES
                WS-PRODUCT-PRICE-X      PIC 9(05)V99.","This COBOL code defines a data structure `WS-LOOKUP-FIELDS` used for lookup operations. It includes fields for lookup type, such as PRODUCT, SALES, INVALID, etc., and specific lookup area details like sales ID, product ID, names, and product price. The `WS-PRODUCT-PRICE` field is defined as a packed-decimal (COMP-3) with 5 digits before the decimal point and 2 digits after.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation incorrectly states that the field `WS-PRODUCT-PRICE` is defined as a packed-decimal (COMP-3), whereas the code does not specify COMP-3 for this field.",0.005354194904142114,0.8478548526763916
cob_real_705,COBOL,"           02 STD-NUM              PIC 9(3).
           02 STD-NAME             PIC X(10).
           02 STD-PERCENT          PIC 9(03).","Defines a record structure with three fields: STD-NUM as a numeric field of 3 digits, STD-NAME as an alphanumeric field of up to 10 characters, and STD-PERCENT as a numeric field of 3 digits.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the code's functionalities.,0.0,0.8249685764312744
cob_real_1559,COBOL,"       01  nums-table.
           03  num-nums            PIC 999.
           03  nums-area.
               05  nums            PIC S999 OCCURS 1 TO 100 TIMES
                                   DEPENDING ON num-nums
                                   INDEXED BY nums-idx.
","This COBOL code defines a table `nums-table` containing a variable `num-nums` of type 999 and an array `nums` of signed 999 values. The size of the array is determined by the value of `num-nums`, which can vary from 1 to 100. The array is indexed by `nums-idx` for accessing individual elements.",Legacy COBOL logic requiring documentation.,No Error,False,The provided documentation accurately represents the provided COBOL code.,0.005965939103175657,0.8426670432090759
cob_syn_9059,COBOL,"      * REFACTOR CANDIDATE BATCH_9059
      * SYSTEM GENERATED
      *========================== RDWADJST ============================*
      * Authors: Brian D Pead
      *
      * License: MIT
      *
      * Description: This program adjusts the Record Descriptor Word 
      *     (RDW) on variable length record files, to support uploading 
      *     and downloading such files to/from an IBM mainframe.
      *     GnuCOBOL expects RDWs to have a record length excluding 
      *     the RDW while the mainframe RDWs have a record length 
      *     including the RDW, i.e. the GnuCOBOL RDW record length is
      *     4 less than the mainframe.
      *
      *     The program supports GnuCOBOL files read/written with 
      *     COB_VARSEQ_FORMAT = 0, i.e. RDWs have a 2 byte record
      *     length (big-endian) + 2 NULs.
      *
      *     This program must be compiled with option std=mf which  
      *     supports COMP-X fields and CBL_OPEN_FILE, etc.
      *
      *     This program requires 2 run-time arguments:
      *         1. File name containing RDWs to be updated (RDWs are
      *            updated in place).
      *         2. GC2MF or MF2GC to increase or decrease RDWs by 4:
      *                GC2MF is GnuCOBOL to Mainframe,
      *                MF2GC is Mainframe to GnuCOBOL.
      *
      *     When uploading/downloading mainframe files, FTP in binary
      *     mode and specify ""quote site rdw"" to have the mainframe 
      *     include the RDWs. 
      *
      * Date        Version  Description
      * ----        -------  -----------
      * 2020-02-08  1.0      First release
      *================================================================*

       IDENTIFICATION DIVISION.
      *========================

       PROGRAM-ID.                 RDWADJST.

       ENVIRONMENT DIVISION.
      *=====================

       CONFIGURATION SECTION.
      *----------------------

       SOURCE-COMPUTER.
           IBM-Z15.
      *    IBM-Z15 DEBUGGING MODE.

       INPUT-OUTPUT SECTION.
      *------","This COBOL program, named RDWADJST, adjusts the Record Descriptor Word (RDW) on variable length record files to facilitate uploading and downloading such files to/from an IBM mainframe. It corrects the difference in RDW size between GnuCOBOL and mainframe systems by adjusting the record length accordingly. The program is designed to handle GnuCOBOL files with 2 byte RDWs and requires compilation with the 'std=mf' option for compatibility. It takes two runtime arguments: the file name containing RDWs to be updated and the direction of adjustment (GC2MF or MF2GC). For proper file transfer, it is recommended to use FTP in binary mode and specify ""quote site rdw"" to include RDWs. Version 1.0 of this program was released on 2020-02-08.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the provided source code.,0.002951343831953942,0.8347676992416382
cob_real_2485,COBOL,"       identification division.
       program-id. signals.
       data division.
       working-storage section.
       01 signal-flag  pic 9 external.
          88 signalled value 1.
       01 half-seconds usage binary-long.
       01 start-time   usage binary-c-long.
       01 end-time     usage binary-c-long.
       01 handler      usage program-pointer.
       01 SIGINT       constant as 2.

       procedure division.
       call ""gettimeofday"" using start-time null
       set handler to entry ""handle-sigint""
       call ""signal"" using by value SIGINT by value handler

       perform until exit
           if signalled then exit perform end-if
           call ""CBL_OC_NANOSLEEP"" using 500000000
           if signalled then exit perform end-if
           add 1 to half-seconds
           display half-seconds
       end-perform

       call ""gettimeofday"" using end-time null
       subtract start-time from end-time
       display ""Program ran for "" end-time "" seconds""
       goback.
       end program signals.

       identification division.
       program-id. handle-sigint.
       data division.
       working-storage section.
       01 signal-flag  pic 9 external.

       linkage section.
       01 the-signal   usage binary-long.

       procedure division using by value the-signal returning omitted.
       move 1 to signal-flag
       goback.
       end program handle-sigint.
","This COBOL program sets up a signal handler for the SIGINT signal (interrupt signal typically generated by the Ctrl+C keystroke). The main program initializes a signal handler to catch the SIGINT signal and runs a loop, incrementing a counter every half second until the signal is received. After the loop, the program calculates and displays the total run time in seconds. The signal handler program simply sets a flag when the signal is caught.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes what the source code does.,0.004358632673529301,0.8499688506126404
py_5158,Python,"def _start_repl(api):
        # type: (Iota) -> None
        """"""
        Starts the REPL.
        """"""
        banner = (
            'IOTA API client for {uri} ({testnet}) '
            'initialized as variable `api`.\n'
            'Type `help(api)` for list of API commands.'.format(
                testnet='testnet' if api.testnet else 'mainnet',
                uri=api.adapter.get_uri(),
            )
        )

        scope_vars = {'api': api}

        try:
            # noinspection PyUnresolvedReferences
            import IPython
        except ImportError:
            # IPython not available; use regular Python REPL.
            from code import InteractiveConsole
            InteractiveConsole(locals=scope_vars).interact(banner, '')
        else:
            print(banner)
            IPython.start_ipython(argv=[], user_ns=scope_vars)","Starts the REPL (Read-Eval-Print Loop) with a custom banner showing information about the IOTA API client's connection to the mainnet or testnet. If IPython is available, the REPL will be started using IPython, otherwise, it falls back to using the regular Python REPL.",Starts the REPL.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.016360464757048186,0.8809708952903748
py_1863,Python,"def settle_deferred_messages(self, settlement, messages, **kwargs):
        """"""Settle messages that have been previously deferred.

        :param settlement: How the messages are to be settled. This must be a string
         of one of the following values: 'completed', 'suspended', 'abandoned'.
        :type settlement: str
        :param messages: A list of deferred messages to be settled.
        :type messages: list[~azure.servicebus.common.message.DeferredMessage]

        Example:
            .. literalinclude:: ../examples/test_examples.py
                :start-after: [START settle_deferred_messages_service_bus]
                :end-before: [END settle_deferred_messages_service_bus]
                :language: python
                :dedent: 8
                :caption: Settle deferred messages.

        """"""
        if (self.entity and self.requires_session) or kwargs.get('session'):
            raise ValueError(""Sessionful deferred messages can only be settled within a locked receive session."")
        if settlement.lower() not in ['completed', 'suspended', 'abandoned']:
            raise ValueError(""Settlement must be one of: 'completed', 'suspended', 'abandoned'"")
        if not messages:
            raise ValueError(""At least one message must be specified."")
        message = {
            'disposition-status': settlement.lower(),
            'lock-tokens': types.AMQPArray([m.lock_token for m in messages])}

        with BaseHandler(self.entity_uri, self.auth_config, debug=self.debug, **kwargs) as handler:
            return handler._mgmt_request_response(  # pylint: disable=protected-access
                REQUEST_RESPONSE_UPDATE_DISPOSTION_OPERATION,
                message,
                mgmt_handlers.default)","Settle messages that have been previously deferred.

:param settlement: How the messages are to be settled. This must be a string
 of one of the following values: 'completed', 'suspended', 'abandoned'.
:type settlement: str
:param messages: A list of deferred messages to be settled.
:type messages: list[~azure.servicebus.common.message.DeferredMessage]","Settle messages that have been previously deferred.

        :param settlement: How the messages are to be settled. This must be a string
         of one of the following values: 'completed', 'suspended', 'abandoned'.
        :type settlement: str
        :param messages: A list of deferred messages to be settled.
        :type messages: list[~azure.servicebus.common.message.DeferredMessage]

        Example:
            .. literalinclude:: ../examples/test_examples.py
                :start-after: [START settle_deferred_messages_service_bus]
                :end-before: [END settle_deferred_messages_service_bus]
                :language: python
                :dedent: 8
                :caption: Settle deferred messages.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.6761743325317475,0.838144063949585
cob_real_1722,COBOL,"       IDENTIFICATION   DIVISION.                                       COF00010
       PROGRAM-ID. TELL-TRANS.                                          COF00020
       REMARKS.  **************************************************     COF00030
                 * PROGRAMMET PLUKKER UT DE DELER AV FR-REG       *     COF00040
                 * SOM SKAL KJRES VIA STANARD-SYSTEMENE.         *     COF00040
                 *                                                *     COF00040
                 *                                                *     COF00040
                 *    RFOLKE   REGISTER.                          *     COF00040
                 *    LRECL=187                                   *     COF00040
                 **************************************************     COF00080
       AUTHER. CURTIS.                                                  COF00090
                                                                        COF00100
       ENVIRONMENT      DIVISION.                                       COF00110
                                                                                
       CONFIGURATION     SECTION.                                               
                                                                                
       OBJECT-COMPUTER. IBM-370,                                                
           PROGRAM COLLATING SEQUENCE IS IDIOT.                                 
                                                                                
       SPECIAL-NAMES.                                                           
           C01 IS KANAL-1                                                       
           , IDIOT IS 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.                          
                                                                                
       INPUT-OUTPUT      SECTION.                                       COF00130
       FILE-CONTROL.            ",This COBOL program identifies and processes parts of the FR-REG that need to be executed through standard systems. It uses a configuration for an IBM-370 computer with a specific collating sequence and defines special names for certain characters.,Legacy COBOL logic requiring documentation.,No Error,False,The current documentation accurately represents the code.,0.007633935801913548,0.8732891082763672
py_2625,Python,"def run(self, dag):
        """"""
        Pick a layout by assigning n circuit qubits to device qubits 0, .., n-1.

        Args:
            dag (DAGCircuit): DAG to find layout for.

        Raises:
            TranspilerError: if dag wider than self.coupling_map
        """"""
        num_dag_qubits = sum([qreg.size for qreg in dag.qregs.values()])
        if num_dag_qubits > self.coupling_map.size():
            raise TranspilerError('Number of qubits greater than device.')
        self.property_set['layout'] = Layout.generate_trivial_layout(*dag.qregs.values())","Pick a layout by assigning n circuit qubits to device qubits 0, .., n-1. This function takes a DAG (Directed Acyclic Graph) as input and finds a suitable layout for it. It raises a TranspilerError if the number of qubits in the DAG is greater than the number of qubits in the coupling map.","Pick a layout by assigning n circuit qubits to device qubits 0, .., n-1.

        Args:
            dag (DAGCircuit): DAG to find layout for.

        Raises:
            TranspilerError: if dag wider than self.coupling_map",No Error,False,The documentation correctly represents the functionality of the code.,0.2525728471353501,0.8302739858627319
cob_syn_9014,COBOL,"      * REFACTOR CANDIDATE BATCH_9014
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    House Policy Menu                           *
      *                                                                *
      * Menu for House Policy Transactions                             *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGTESTP3.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       77 MSGEND                       PIC X(24) VALUE
                                        'Transaction ended      '.

       COPY SSMAP.
       01 COMM-AREA.
       COPY LGCMAREA.

      *------------------",This COBOL code defines a program named LGTESTP3 that includes definitions for working storage variables and copies external data structures. The program appears to be related to handling house policy transactions. The provided section of code primarily focuses on setting up some initial configurations and variable declarations for the program.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly captures the purpose and the key definitions of the COBOL code.,0.006065997938636506,0.8640170097351074
py_6089,Python,"def stream_json_lines(file):
    """"""
    Load a JSON stream and return a generator, yielding one object at a time.
    """"""
    if isinstance(file, string_type):
        file = open(file, 'rb')
    for line in file:
        line = line.strip()
        if line:
            if isinstance(line, bytes):
                line = line.decode('utf-8')
            yield json.loads(line)","Load a JSON stream and return a generator, yielding one object at a time.","Load a JSON stream and return a generator, yielding one object at a time.",Omission,True,The documentation doesn't mention that the function can also handle a file path in string format as an input.,1.0,0.9999999403953552
py_2245,Python,"def match_events(events_from, events_to, left=True, right=True):
    '''Match one set of events to another.

    This is useful for tasks such as matching beats to the nearest
    detected onsets, or frame-aligned events to the nearest zero-crossing.

    .. note:: A target event may be matched to multiple source events.

    Examples
    --------
    >>> # Sources are multiples of 7
    >>> s_from = np.arange(0, 100, 7)
    >>> s_from
    array([ 0,  7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91,
           98])
    >>> # Targets are multiples of 10
    >>> s_to = np.arange(0, 100, 10)
    >>> s_to
    array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
    >>> # Find the matching
    >>> idx = librosa.util.match_events(s_from, s_to)
    >>> idx
    array([0, 1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9, 9])
    >>> # Print each source value to its matching target
    >>> zip(s_from, s_to[idx])
    [(0, 0), (7, 10), (14, 10), (21, 20), (28, 30), (35, 30),
     (42, 40), (49, 50), (56, 60), (63, 60), (70, 70), (77, 80),
     (84, 80), (91, 90), (98, 90)]

    Parameters
    ----------
    events_from : ndarray [shape=(n,)]
      Array of events (eg, times, sample or frame indices) to match from.

    events_to : ndarray [shape=(m,)]
      Array of events (eg, times, sample or frame indices) to
      match against.

    left : bool
    right : bool
        If `False`, then matched events cannot be to the left (or right)
        of source events.

    Returns
    -------
    event_mapping : np.ndarray [shape=(n,)]
        For each event in `events_from`, the corresponding event
        index in `events_to`.

        `event_mapping[i] == arg min |events_from[i] - events_to[:]|`

    See Also
    --------
    match_intervals

    Raises
    ------
    ParameterError
        If either array of input events is not the correct shape
    '''
    if len(events_from) == 0 or len(events_to) == 0:
        raise ParameterError('Attempting to match empty event list')

    # If we can't match left or right, then only strict equivalence
    # counts as a match.
    if not (left or right) and not np.all(np.in1d(events_from, events_to)):
        raise ParameterError('Cannot match events with left=right=False '
                             'and events_from is not contained '
                             'in events_to')

    # If we can't match to the left, then there should be at least one
    # target event greater-equal to every source event
    if (not left) and max(events_to) < max(events_from):
        raise ParameterError('Cannot match events with left=False '
                             'and max(events_to) < max(events_from)')

    # If we can't match to the right, then there should be at least one
    # target event less-equal to every source event
    if (not right) and min(events_to) > min(events_from):
        raise ParameterError('Cannot match events with right=False '
                             'and min(events_to) > min(events_from)')

    # array of matched items
    output = np.empty_like(events_from, dtype=np.int)

    return __match_events_helper(output, events_from, events_to, left, right)","'''Match one set of events to another.

This is useful for tasks such as matching beats to the nearest detected onsets, or frame-aligned events to the nearest zero-crossing.

.. note:: A target event may be matched to multiple source events.

Parameters
----------
events_from : ndarray [shape=(n,)]
  Array of events (eg, times, sample or frame indices) to match from.

events_to : ndarray [shape=(m,)]
  Array of events (eg, times, sample or frame indices) to match against.

left : bool
right : bool
    If `False`, then matched events cannot be to the left (or right) of source events.

Returns
-------
event_mapping : np.ndarray [shape=(n,)]
    For each event in `events_from`, the corresponding event index in `events_to`.

    `event_mapping[i] == arg min |events_from[i] - events_to[:]|`

See Also
--------
match_intervals

Raises
------
ParameterError
    If either array of input events is not the correct shape
'''","Match one set of events to another.

    This is useful for tasks such as matching beats to the nearest
    detected onsets, or frame-aligned events to the nearest zero-crossing.

    .. note:: A target event may be matched to multiple source events.

    Examples
    --------
    >>> # Sources are multiples of 7
    >>> s_from = np.arange(0, 100, 7)
    >>> s_from
    array([ 0,  7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91,
           98])
    >>> # Targets are multiples of 10
    >>> s_to = np.arange(0, 100, 10)
    >>> s_to
    array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
    >>> # Find the matching
    >>> idx = librosa.util.match_events(s_from, s_to)
    >>> idx
    array([0, 1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9, 9])
    >>> # Print each source value to its matching target
    >>> zip(s_from, s_to[idx])
    [(0, 0), (7, 10), (14, 10), (21, 20), (28, 30), (35, 30),
     (42, 40), (49, 50), (56, 60), (63, 60), (70, 70), (77, 80),
     (84, 80), (91, 90), (98, 90)]

    Parameters
    ----------
    events_from : ndarray [shape=(n,)]
      Array of events (eg, times, sample or frame indices) to match from.

    events_to : ndarray [shape=(m,)]
      Array of events (eg, times, sample or frame indices) to
      match against.

    left : bool
    right : bool
        If `False`, then matched events cannot be to the left (or right)
        of source events.

    Returns
    -------
    event_mapping : np.ndarray [shape=(n,)]
        For each event in `events_from`, the corresponding event
        index in `events_to`.

        `event_mapping[i] == arg min |events_from[i] - events_to[:]|`

    See Also
    --------
    match_intervals

    Raises
    ------
    ParameterError
        If either array of input events is not the correct shape",No Error,False,"The documentation accurately reflects what the code does, providing both clear descriptions and examples of its usage.",0.3853437307018127,0.8439996838569641
cob_syn_616,COBOL,"      * REFACTOR CANDIDATE BATCH_616
      * SYSTEM GENERATED
      ******************************************************************
      *    Primary Key - ABTEILUNG-ID
      *    ABTEILUNG-NAME & PRAEMIE are required
      *    ABTEILUNG-NAME - ALTERNATE KEY
      *    PRAEMIE - ALTERNATE KEY WITH DUPLICATES
      ******************************************************************
       FD  ABTEIL-FILE.
       01  ABTEIL-RECORD.
           05 ABTEILUNG-ID   PIC 9(4).
           05 ABTEILUNG-NAME PIC X(100).
           05 PRAEMIE        PIC 9(3).
","This COBOL code defines a file structure for an ABTEIL-FILE containing ABTEIL-RECORDs with fields for ABTEILUNG-ID (primary key, 4 digits), ABTEILUNG-NAME (required, 100 characters), and PRAEMIE (required, 3 digits). It also specifies ABTEILUNG-NAME as an alternate key and PRAEMIE as an alternate key allowing duplicates.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.006626589205134352,0.8425909280776978
py_2226,Python,"def window_bandwidth(window, n=1000):
    '''Get the equivalent noise bandwidth of a window function.


    Parameters
    ----------
    window : callable or string
        A window function, or the name of a window function.
        Examples:
        - scipy.signal.hann
        - 'boxcar'

    n : int > 0
        The number of coefficients to use in estimating the
        window bandwidth

    Returns
    -------
    bandwidth : float
        The equivalent noise bandwidth (in FFT bins) of the
        given window function

    Notes
    -----
    This function caches at level 10.

    See Also
    --------
    get_window
    '''

    if hasattr(window, '__name__'):
        key = window.__name__
    else:
        key = window

    if key not in WINDOW_BANDWIDTHS:
        win = get_window(window, n)
        WINDOW_BANDWIDTHS[key] = n * np.sum(win**2) / np.sum(np.abs(win))**2

    return WINDOW_BANDWIDTHS[key]","'''Get the equivalent noise bandwidth of a window function.

Parameters
----------
window : callable or string
    A window function, or the name of a window function.
    Examples:
    - scipy.signal.hann
    - 'boxcar'

n : int > 0
    The number of coefficients to use in estimating the
    window bandwidth

Returns
-------
bandwidth : float
    The equivalent noise bandwidth (in FFT bins) of the
    given window function

Notes
-----
This function caches at level 10.

See Also
--------
get_window
'''","Get the equivalent noise bandwidth of a window function.


    Parameters
    ----------
    window : callable or string
        A window function, or the name of a window function.
        Examples:
        - scipy.signal.hann
        - 'boxcar'

    n : int > 0
        The number of coefficients to use in estimating the
        window bandwidth

    Returns
    -------
    bandwidth : float
        The equivalent noise bandwidth (in FFT bins) of the
        given window function

    Notes
    -----
    This function caches at level 10.

    See Also
    --------
    get_window",Omission,True,The generated documentation does not include an explanation of the 'WINDOW_BANDWIDTHS' variable used in the code.,0.9735040436119747,0.9210664629936218
cob_syn_3243,COBOL,"      * REFACTOR CANDIDATE BATCH_3243
      * SYSTEM GENERATED
000010 @OPTIONS MAIN
000020 Identification Division.
000030 Program-Id.  Chapt07x.
000040* Chapter 7 Exercise Solution
000050 Environment Division.
000060 Configuration Section.
000070 Source-Computer.  IBM-PC.
000080 Object-Computer.  IBM-PC.
000090 Data Division.
000100 Working-Storage Section.
000101 01  Word-In          Pic X(40)   Value Spaces.
000102 01  Word-Out         Pic X(40)   Value Spaces.
000103 01  Work-Field-1     Pic X(40)   Value Spaces.
000104 01  Work-Field-2     Pic X(40)   Value Spaces.
000106 Screen Section.
000107 01  Main-Screen Blank Screen.
000108     03  Line 01 Column 01 Value ""Enter Word:"".
000109     03  Line 01 Column 13 Pic X(40) Using Word-In.
000110     03  Line 03 Column 01 Value ""Word Result:"".
000114     03  Line 03 Column 14 Pic X(40) From Word-Out.
000116 Procedure Division.
000117 Chapt07x-Start.
000120     Display Main-Screen
000130     Accept Main-Screen
000131     Unstring Word-In 
000132       Delimited by ""-"" 
000133       Into Work-Field-1 Work-Field-2
000134     End-Unstring
000135     String Work-Field-1 
000136            Work-Field-2
000137            Delimited By Space
000138            Into Word-Out
000139     End-String
000161     Display Main-Screen
000164     Stop Run
000174     .
","This COBOL program defines input and output fields for words, displays a screen prompting the user to enter a word, accepts the user input, extracts two words separated by a hyphen from the input, concatenates these words with a space delimiter, and displays the result on the screen. Finally, it stops the program execution.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation fails to mention the operation of separating the input word by hyphen into two different fields (Work-Field-1 and Work-Field-2) and then concatenating them back without a space (not a space delimiter as mentioned).,0.0056860862169080505,0.8541942834854126
cob_syn_9358,COBOL,"      * REFACTOR CANDIDATE BATCH_9358
      * SYSTEM GENERATED
        identification division.
            program-id. test-program.
        environment division.
        data division.
        working-storage section.
        01 varx.
            05 vary picture is 9999.
            05 varz picture is 9(4) value is 60.
            05 tok1 picture is X(18).

        procedure division.
            move 8 to vary.
            if vary = 8
               then move ""vary is eight"" to tok1
                    move 55 to varz
                    if varz = 55
                       then display varz
                            display tok1.
            compute varz = (6 + vary) / 5.
            display varz, "" is not rounded"".
            compute varz rounded = (6 + vary) / 5.
            display varz, "" is rounded"".
","This COBOL program declares variables `vary`, `varz`, and `tok1`, assigns values to them, performs arithmetic operations on `varz`, and displays the results along with messages indicating whether the value of `varz` is rounded or not.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.008176856499690712,0.8475425839424133
py_7707,Python,"def vcf2cytosure(institute_id, case_name, individual_id):
    """"""Download vcf2cytosure file for individual.""""""

    (display_name, vcf2cytosure) = controllers.vcf2cytosure(store,
        institute_id, case_name, individual_id)

    outdir = os.path.abspath(os.path.dirname(vcf2cytosure))
    filename = os.path.basename(vcf2cytosure)

    log.debug(""Attempt to deliver file {0} from dir {1}"".format(filename, outdir))

    attachment_filename = display_name + "".vcf2cytosure.cgh""

    return send_from_directory(outdir, filename,
        attachment_filename=attachment_filename,
        as_attachment=True)",Download vcf2cytosure file for individual.,Download vcf2cytosure file for individual.,No Error,False,"The generated documentation accurately reflects the function of the source code, which is to download a vcf2cytosure file for an individual.",1.0,1.0000001192092896
py_13230,Python,"def get_config_value(self, section, key, return_type: type):
        """"""Read customer's config value by section and key.

        :param section: config file's section. i.e [default]
        :param key: config file's key under section. i.e packages_scan
        :param return_type: return value type, str | int | bool.
        """"""
        try:
            value = self.method_mapping[return_type](section, key)
        except NoSectionError as e:
            raise ConfigError(e.message)
        except NoOptionError as e:
            raise ConfigError(e.message)
        return value","Reads a customer's configuration value from a config file by specifying the section and key. The return_type parameter determines the type of the returned value (str, int, bool). If the section or key does not exist in the config file, it raises a ConfigError exception.","Read customer's config value by section and key.

        :param section: config file's section. i.e [default]
        :param key: config file's key under section. i.e packages_scan
        :param return_type: return value type, str | int | bool.",No Error,False,"The provided documentation accurately explains the function's purpose, its input parameters, expected output, and error handling.",0.038198636233478904,0.8414625525474548
py_3928,Python,"def remote_app(self, name, register=True, **kwargs):
        """"""Registers a new remote application.

        :param name: the name of the remote application
        :param register: whether the remote app will be registered

        Find more parameters from :class:`OAuthRemoteApp`.
        """"""
        remote = OAuthRemoteApp(self, name, **kwargs)
        if register:
            assert name not in self.remote_apps
            self.remote_apps[name] = remote
        return remote","Registers a new remote application with the given name and specified registration status. Creates an instance of OAuthRemoteApp with the provided arguments. If the registration parameter is set to True, adds the remote application to the list of remote apps owned by self. Returns the instance of the remote application created. More parameters can be found in the documentation for the OAuthRemoteApp class.","Registers a new remote application.

        :param name: the name of the remote application
        :param register: whether the remote app will be registered

        Find more parameters from :class:`OAuthRemoteApp`.",No Error,False,The documentation accurately reflects the code and does not contain hallucinations or omissions.,0.08605491591482159,0.8277605175971985
cob_syn_10290,COBOL,"      * REFACTOR CANDIDATE BATCH_10290
      * SYSTEM GENERATED
000000 IDENTIFICATION DIVISION.
000000 PROGRAM-ID.  Multiplier.
000000 AUTHOR.  Michael Coughlan.
000000* Example program using ACCEPT, DISPLAY and MULTIPLY to 
000000* get two single digit numbers from the user and multiply them together
000000 
000000 DATA DIVISION.
000000 
000000 WORKING-STORAGE SECTION.
000000 01  Num1                                PIC 9  VALUE ZEROS.
000000 01  Num2                                PIC 9  VALUE ZEROS.
000000 01  Result                              PIC 99 VALUE ZEROS.
000000 
000000 PROCEDURE DIVISION.
000000     DISPLAY ""Enter first number  (1 digit) : "" WITH NO ADVANCING.
000000     ACCEPT Num1.
000000     DISPLAY ""Enter second number (1 digit) : "" WITH NO ADVANCING.
000000     ACCEPT Num2.
000000     MULTIPLY Num1 BY Num2 GIVING Result.
000000     DISPLAY ""Result is = "", Result.
000000     STOP RUN.
000000 
000000 
","This COBOL program, named Multiplier, takes two single-digit numbers as input from the user, multiplies them together, and displays the result. The program uses ACCEPT to get user input, MULTIPLY to perform the multiplication operation, and DISPLAY to show the result on the screen.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately describes the actions performed by the source code.,0.0067525623389387635,0.8566434979438782
cob_real_3749,COBOL,"       identification division.
       program-id. callsym.

       data division.
       working-storage section.
       01 handle usage pointer.
       01 addr   usage program-pointer.

       procedure division.
       call ""dlopen"" using
           by reference null
           by value 1
           returning handle
           on exception
               display function exception-statement upon syserr
               goback
       end-call
       if handle equal null then
           display function module-id "": error getting dlopen handle""
             upon syserr
           goback
       end-if

       call ""dlsym"" using
           by value handle
           by content z""perror""
           returning addr
       end-call
       if addr equal null then
           display function module-id "": error getting perror symbol""
              upon syserr
       else
           call addr returning omitted
       end-if

       goback.
       end program callsym.
","This COBOL program dynamically loads a shared library using the `dlopen` function, retrieves a symbol address using the `dlsym` function, and calls the retrieved function. If any errors occur during these operations, error messages are displayed.",Legacy COBOL logic requiring documentation.,No Error,False,The provided code documentation accurately reflects what the source code is doing.,0.007986728673290205,0.8637836575508118
py_8067,Python,"def home():
    '''Serve the status page of the capture agent.
    '''
    # Get IDs of existing preview images
    preview = config()['capture']['preview']
    previewdir = config()['capture']['preview_dir']
    preview = [p.replace('{{previewdir}}', previewdir) for p in preview]
    preview = zip(preview, range(len(preview)))
    preview = [p[1] for p in preview if os.path.isfile(p[0])]

    # Get limits for recording table
    try:
        limit_upcoming = int(request.args.get('limit_upcoming', 5))
        limit_processed = int(request.args.get('limit_processed', 15))
    except ValueError:
        limit_upcoming = 5
        limit_processed = 15

    db = get_session()
    upcoming_events = db.query(UpcomingEvent)\
                        .order_by(UpcomingEvent.start)\
                        .limit(limit_upcoming)
    recorded_events = db.query(RecordedEvent)\
                        .order_by(RecordedEvent.start.desc())\
                        .limit(limit_processed)
    recording = get_service_status(Service.CAPTURE) == ServiceStatus.BUSY
    uploading = get_service_status(Service.INGEST) == ServiceStatus.BUSY
    processed = db.query(RecordedEvent).count()
    upcoming = db.query(UpcomingEvent).count()

    return render_template('home.html', preview=preview, config=config(),
                           recorded_events=recorded_events,
                           upcoming_events=upcoming_events,
                           recording=recording, uploading=uploading,
                           processed=processed, upcoming=upcoming,
                           limit_upcoming=limit_upcoming,
                           limit_processed=limit_processed,
                           dtfmt=dtfmt)","Serve the status page of the capture agent including preview images, recording information, upcoming and recorded events, and service statuses.",Serve the status page of the capture agent.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.2915369229944523,0.9267411231994629
cob_syn_88,COBOL,"      * REFACTOR CANDIDATE BATCH_88
      * SYSTEM GENERATED
       01  CUSTOMER-MASTER-RECORD.
      *
           05  CM-CUSTOMER-NUMBER      PIC X(6).
           05  CM-FIRST-NAME           PIC X(20).
           05  CM-LAST-NAME            PIC X(30).
           05  CM-ADDRESS              PIC X(30).
           05  CM-CITY                 PIC X(20).
           05  CM-STATE                PIC X(2).
           05  CM-ZIP-CODE             PIC X(10).
","This COBOL code defines a customer master record data structure with fields for customer number, first name, last name, address, city, state, and zip code. The fields are defined with various PIC X data types specifying their lengths.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly describes the source code without any omissions or hallucinations.,0.007633935801913548,0.8591594099998474
cob_syn_599,COBOL,"      * REFACTOR CANDIDATE BATCH_599
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. PGM1.
       PROCEDURE DIVISION.
       S1 SECTION.
         CALL TOTO.
       S1_END.
         GOBACK.
","This COBOL program defines a procedure that calls a subroutine named ""TOTO"" in section S1 and then ends the program.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately and succinctly describes the function of the code.,0.013038525962482981,0.87604820728302
py_1302,Python,"def recall_at_k(y_true: List[int], y_pred: List[List[np.ndarray]], k: int):
    """"""
    Calculates recall at k ranking metric.

    Args:
        y_true: Labels. Not used in the calculation of the metric.
        y_predicted: Predictions.
            Each prediction contains ranking score of all ranking candidates for the particular data sample.
            It is supposed that the ranking score for the true candidate goes first in the prediction.

    Returns:
        Recall at k
    """"""
    num_examples = float(len(y_pred))
    predictions = np.array(y_pred)
    predictions = np.flip(np.argsort(predictions, -1), -1)[:, :k]
    num_correct = 0
    for el in predictions:
        if 0 in el:
            num_correct += 1
    return float(num_correct) / num_examples",Calculates recall at k ranking metric based on the provided predictions and k value.,"Calculates recall at k ranking metric.

    Args:
        y_true: Labels. Not used in the calculation of the metric.
        y_predicted: Predictions.
            Each prediction contains ranking score of all ranking candidates for the particular data sample.
            It is supposed that the ranking score for the true candidate goes first in the prediction.

    Returns:
        Recall at k",Omission,True,The parameter y_true is not mentioned or explained in the generated documentation.,0.017837978995033497,0.8075956106185913
cob_syn_1413,COBOL,"      * REFACTOR CANDIDATE BATCH_1413
      * SYSTEM GENERATED
      ******************************************************************        
      **                                                              **        
      **                  WebSphere MQ for z/OS                       **        
      **                                                              **        
      **  FILE NAME:      CMQV                                        **        
      **                                                              **        
      **  DESCRIPTION:    Constants for Main MQI                      **        
      **                                                              **        
      ******************************************************************        
      **  @START_COPYRIGHT@                                           **        
      **  Licensed Materials - Property of IBM                        **        
      **                                                              **        
      **  5655-F10                                                    **        
      **                                                              **        
      **  (C) Copyright IBM Corporation 1993, 2002.                   **        
      **                                                              **        
      **  Status: Version 5 Release 3                                 **        
      **  @END_COPYRIGHT@                                             **        
      ******************************************************************        
      **                                                              **        
      **  FUNCTION:       This file declares the named constants      **        
      **                  for the main MQI.                           **        
      **                                                              **        
      **  PROCESSOR:      COBOL                                       **        
      **                                                ",This COBOL code file contains named constants for the main MQI (Message Queuing Interface) in WebSphere MQ for z/OS. It serves as a reference for maintaining consistency and clarity in using these constants throughout the application.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately represents the given code.,0.007986728673290205,0.868122398853302
py_2686,Python,"def gaussian_square(duration: int, amp: complex, sigma: float,
                    risefall: int, name: str = None) -> SamplePulse:
    """"""Generates gaussian square `SamplePulse`.

    Centered at `duration/2` and zeroed at `t=-1` and `t=duration+1` to prevent
    large initial/final discontinuities.

    Applies `left` sampling strategy to generate discrete pulse from continuous function.

    Args:
        duration: Duration of pulse. Must be greater than zero.
        amp: Pulse amplitude.
        sigma: Width (standard deviation) of gaussian rise/fall portion of the pulse.
        risefall: Number of samples over which pulse rise and fall happen. Width of
            square portion of pulse will be `duration-2*risefall`.
        name: Name of pulse.
    """"""
    center = duration/2
    width = duration-2*risefall
    zeroed_width = duration + 2
    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma,
                                          zeroed_width=zeroed_width, name=name)","""""""Generates a Gaussian square `SamplePulse` centered at `duration/2` with gaussian rise/fall portions and a square portion. The pulse is zeroed at `t=-1` and `t=duration+1` to prevent large initial/final discontinuities. Applies the `left` sampling strategy to discretize the pulse from a continuous function.

Args:
    duration (int): Duration of the pulse. Must be greater than zero.
    amp (complex): Amplitude of the pulse.
    sigma (float): Width (standard deviation) of the gaussian rise/fall portion of the pulse.
    risefall (int): Number of samples over which the pulse rise and fall occur. Width of the square portion of the pulse will be `duration-2*risefall`.
    name (str, optional): Name of the pulse.
Returns:
    SamplePulse: The generated Gaussian square `SamplePulse`.
""""""","Generates gaussian square `SamplePulse`.

    Centered at `duration/2` and zeroed at `t=-1` and `t=duration+1` to prevent
    large initial/final discontinuities.

    Applies `left` sampling strategy to generate discrete pulse from continuous function.

    Args:
        duration: Duration of pulse. Must be greater than zero.
        amp: Pulse amplitude.
        sigma: Width (standard deviation) of gaussian rise/fall portion of the pulse.
        risefall: Number of samples over which pulse rise and fall happen. Width of
            square portion of pulse will be `duration-2*risefall`.
        name: Name of pulse.",No Error,False,"The generated documentation accurately describes the arguments, return, and functionality of the code without adding unsupported claims or omitting critical information.",0.3312192455028195,0.9285721182823181
py_13737,Python,"def _get_pc_covered_str(self):
        """"""Returns the percent covered, as a string, without a percent sign.

        Note that ""0"" is only returned when the value is truly zero, and ""100""
        is only returned when the value is truly 100.  Rounding can never
        result in either ""0"" or ""100"".

        """"""
        pc = self.pc_covered
        if 0 < pc < self._near0:
            pc = self._near0
        elif self._near100 < pc < 100:
            pc = self._near100
        else:
            pc = round(pc, self._precision)
        return ""%.*f"" % (self._precision, pc)","Returns the percent covered, as a string, without a percent sign. Note that ""0"" is only returned when the value is truly zero, and ""100"" is only returned when the value is truly 100. Rounding can never result in either ""0"" or ""100"".","Returns the percent covered, as a string, without a percent sign.

        Note that ""0"" is only returned when the value is truly zero, and ""100""
        is only returned when the value is truly 100.  Rounding can never
        result in either ""0"" or ""100"".",No Error,False,The generated documentation accurately reflects what the code does without any unsupported claims or critical omissions.,1.0,0.9274623990058899
cob_syn_2658,COBOL,"      * REFACTOR CANDIDATE BATCH_2658
      * SYSTEM GENERATED
##parameters=message
# Copyright (c) 2004-2006 gocept gmbh & co. kg
# See also LICENSE.txt
# $Id: af_redirect_to_content.py 4491 2007-02-28 17:49:42Z ctheune $
context.af_redirect_to_workitem_view(message)
",This COBOL code appears to be a comment block describing a refactoring candidate named BATCH_2658. It includes system-generated information such as copyright notices and a version control ID. The code seems to call a function `af_redirect_to_workitem_view` with the parameter `message`.,Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The given source code is not COBOL, it's Python.",0.007313425995364251,0.8524412512779236
cob_syn_243,COBOL,"      * REFACTOR CANDIDATE BATCH_243
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. loop-do-while.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  i PIC 99 VALUE 0.

       PROCEDURE DIVISION.
           PERFORM WITH TEST AFTER UNTIL FUNCTION MOD(i, 6) = 0
               ADD 1 TO i
               DISPLAY i
           END-PERFORM

           GOBACK
           .
","This COBOL program defines a loop using a ""PERFORM"" statement that increments the variable 'i' by 1 in each iteration, displays the value of 'i', and continues the loop until the result of 'i' modulo 6 is equal to 0.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.007313425995364251,0.8562921285629272
cob_real_3603,COBOL,"       identification division.
       program-id. Lab6Demo.

       author. Henry Zheng.
       date-written. 2018-03-02. 
      * Purpose:  To demonstrate the student's ability to use performs 
      *            within performs
       environment division.
       configuration section.

       input-output section.
       file-control.
      * configure input file
           select input-file 
               assign to ""../../../Data/lab8.dat""
               organization is line sequential.

      * configure output file
           select G-output-file
               assign to ""../../../Data/G-lab8.out""
               organization is line sequential.

      * configure output file
           select N-output-file
               assign to ""../../../Data/N-lab8.out""
               organization is line sequential.
       data division.
       file section.

      * declare an input record definition 
       fd input-file
           data record is input-line
           record contains 28 characters.

       01  input-line.
           05 il-emp-num                       pic xxx.
           05 il-name                          pic x(15).
           05 il-edu-code                      pic x.
           05 il-years                         pic 99.
           05 il-cur-salary                    pic 9(5)V99.


       fd G-output-file
           data record is G-output-line
           record contains 90 characters.
       
       01  G-output-line                       pic x(90).

       fd N-output-file
           data record is N-output-line
           record contains 90 characters.

       01  N-output-line                       pic x(90).

       working-storage section.

       01  ws-eof-flag                         pic x
           value ""n"".  

      * Checks if there's a reset has been performed already
       01  ws-reset-flag                       pic x
           value ""n"".

       01  ws-no-reset                         pic x
           value ""n"".

       01  ws-ye","This COBOL program demonstrates the use of nested PERFORM statements. It reads employee data from an input file, processes the data, and writes specific records to two output files based on certain conditions. The program involves file handling, data manipulation, and conditional logic.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not specify what specific conditions must be met to write records to two different output files.,0.006883858510498897,0.8749293088912964
cob_real_2212,COBOL,"000001*
000002*  Game of Life
000003* 
000004* 
000005* 
000006* 
000007* 
000008* 
000009* 
000010* 
000011* 
000012* 
000013* 
000014* 
000015
000016  IDENTIFICATION DIVISION.
000017  PROGRAM-ID. GameOfLife.
000018  
000019  ENVIRONMENT DIVISION.
000020  INPUT-OUTPUT SECTION.
000021  FILE-CONTROL.
000022      SELECT InputFile ASSIGN TO 'input.txt'
000023        ORGANIZATION IS LINE SEQUENTIAL
000024        FILE STATUS IS inputErr.
000025      SELECT OutputFile ASSIGN TO fname
000026        ORGANIZATION IS LINE SEQUENTIAL
000027        FILE STATUS IS outputErr.
000028             
000029  DATA DIVISION.
000030  FILE SECTION.
000031  FD InputFile.
000032  01 InputPattern.
000033      02 ReadLine PIC X(100).
000034  FD OutputFile.
000035  01 OutputPattern.
000036      02 WriteLine OCCURS 1 TO 100 TIMES DEPENDING ON strlen.
000037          03 LineContent PIC X.
000038
000039  WORKING-STORAGE SECTION.
000040  01 Pattern.
000041      02 PatternName PIC X(80).
000042      02 Generation PIC 9(5).
000043      02 Row PIC 9(3).
000044      02 Col PIC 9(2).
000045      02 Matrix PIC X(82) VALUE '0' OCCURS 1 TO 102 TIMES DEPENDING ON Row.
000046  01 inputErr PIC XX.
000047  01 outputErr PIC XX.
000048  01 str PIC X(102).
000049  01 tempstr PIC X(102).
000050  01 GenerationString PIC Z(5).
000051  01 mString PIC Z(5).
000052  01 i PIC 9(5) VALUE 2.
000053  01 j PIC 9(5) VALUE 2.
000054  01 k PIC 9(5).
000055  01 l PIC 9(5).
000056  01 m PIC 9(5) VALUE 1.
000057  01 n PIC 9(5).
000058  01 alifeCellsCount PIC 9(1).
000059  01 NextPattern.
000060      02 NextMatrix PIC X(82) VALUE '0' OCCURS 1 TO 102 TIMES DEPENDING ON Row.
000061  01 isStillLife PIC 9(1) VALUE 1.
000062  01 fname PIC X(90).
000063  01 strlen PIC 9(3).
000064  
000065  PROCEDURE DIVISION.
000066  MAIN-PARAGRAPH.
000067* Read input file
000068      OPEN INPUT InputFile
000069      IF NOT inputErr = '00' THEN
000070        DISPLAY 'No input files f","This COBOL program implements Conway's Game of Life. It reads an input file containing a pattern, processes the pattern according to the rules of the game, and outputs the result to a specified output file. The program utilizes matrices to represent the game grid and determines the next generation of cells based on the current configuration. The main logic is implemented in the PROCEDURE DIVISION with the MAIN-PARAGRAPH as the entry point.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately represents the function of the source code without any hallucinations or omissions.,0.0053049282909038925,0.8528966307640076
py_10366,Python,"def always_iterable(item):
	""""""
	Given an object, always return an iterable. If the item is not
	already iterable, return a tuple containing only the item. If item is
	None, an empty iterable is returned.

	>>> always_iterable([1,2,3])
	<list_iterator...>
	>>> always_iterable('foo')
	<tuple_iterator...>
	>>> always_iterable(None)
	<tuple_iterator...>
	>>> always_iterable(range(10))
	<range_iterator...>
	>>> def _test_func(): yield ""I'm iterable""
	>>> print(next(always_iterable(_test_func())))
	I'm iterable

	Although mappings are iterable, treat each like a singleton, as
	it's more like an object than a sequence.

	>>> next(always_iterable(dict(a=1)))
	{'a': 1}
	""""""
	base_types = six.text_type, bytes, collections.abc.Mapping
	return more_itertools.always_iterable(item, base_type=base_types)","Given an object, always return an iterable. If the item is not already iterable, return a tuple containing only the item. If item is None, an empty iterable is returned.","Given an object, always return an iterable. If the item is not
	already iterable, return a tuple containing only the item. If item is
	None, an empty iterable is returned.

	>>> always_iterable([1,2,3])
	<list_iterator...>
	>>> always_iterable('foo')
	<tuple_iterator...>
	>>> always_iterable(None)
	<tuple_iterator...>
	>>> always_iterable(range(10))
	<range_iterator...>
	>>> def _test_func(): yield ""I'm iterable""
	>>> print(next(always_iterable(_test_func())))
	I'm iterable

	Although mappings are iterable, treat each like a singleton, as
	it's more like an object than a sequence.

	>>> next(always_iterable(dict(a=1)))
	{'a': 1}",Omission,True,"The documentation does not mention that mappings are treated like singletons rather than sequences, a detail which is covered in the source code comments.",0.2306931822549628,0.8695891499519348
py_8544,Python,"def f_set(self, *args, **kwargs):
        """""" Method to put data into the result.

        :param args:

            The first positional argument is stored with the name of the result.
            Following arguments are stored with `name_X` where `X` is the position
            of the argument.

        :param kwargs: Arguments are stored with the key as name.

        :raises: TypeError if outer data structure is not understood.

        Example usage:

        >>> res = Result('supergroup.subgroup.myresult', comment='I am a neat example!')
        >>> res.f_set(333,42.0, mystring='String!')
        >>> res.f_get('myresult')
        333
        >>> res.f_get('myresult_1')
        42.0
        >>> res.f_get(1)
        42.0
        >>> res.f_get('mystring')
        'String!'

        """"""
        if args and self.v_name is None:
            raise AttributeError('Cannot set positional value because I do not have a name!')
        for idx, arg in enumerate(args):
            valstr = self.f_translate_key(idx)
            self.f_set_single(valstr, arg)

        for key, arg in kwargs.items():
            self.f_set_single(key, arg)","Method to put data into the result.

:param args:

    The first positional argument is stored with the name of the result.
    Following arguments are stored with `name_X` where `X` is the position
    of the argument.

:param kwargs: Arguments are stored with the key as name.

:raises: TypeError if outer data structure is not understood.

Example usage:

>>> res = Result('supergroup.subgroup.myresult', comment='I am a neat example!')
>>> res.f_set(333,42.0, mystring='String!')
>>> res.f_get('myresult')
333
>>> res.f_get('myresult_1')
42.0
>>> res.f_get(1)
42.0
>>> res.f_get('mystring')
'String!'","Method to put data into the result.

        :param args:

            The first positional argument is stored with the name of the result.
            Following arguments are stored with `name_X` where `X` is the position
            of the argument.

        :param kwargs: Arguments are stored with the key as name.

        :raises: TypeError if outer data structure is not understood.

        Example usage:

        >>> res = Result('supergroup.subgroup.myresult', comment='I am a neat example!')
        >>> res.f_set(333,42.0, mystring='String!')
        >>> res.f_get('myresult')
        333
        >>> res.f_get('myresult_1')
        42.0
        >>> res.f_get(1)
        42.0
        >>> res.f_get('mystring')
        'String!'",No Error,False,"The generated documentation accurately represents what the code does, with no unsupported claims or significant omissions.",1.0,0.9251640439033508
py_6693,Python,"def download(url, file_name, headers=None, show_progress=True):
    '''stream to a temporary file, rename on successful completion

        Parameters
        ==========
        file_name: the file name to stream to
        url: the url to stream from
        headers: additional headers to add
    '''

    fd, tmp_file = tempfile.mkstemp(prefix=(""%s.tmp."" % file_name)) 
    os.close(fd)

    if DISABLE_SSL_CHECK is True:
        bot.warning('Verify of certificates disabled! ::TESTING USE ONLY::')

    verify = not DISABLE_SSL_CHECK
    response = stream(url, headers=headers, stream_to=tmp_file)
    shutil.move(tmp_file, file_name)
    return file_name","This function downloads a file from a given URL and saves it to a specified file name. It streams the file to a temporary file and then renames it upon successful completion. Additional headers can be provided, and progress during the download can be displayed.","stream to a temporary file, rename on successful completion

        Parameters
        ==========
        file_name: the file name to stream to
        url: the url to stream from
        headers: additional headers to add",Omission,True,"The documentation does not mention the handling of SSL certificate verification and the warning when disabled, also the use of 'show_progress' parameter is not explained.",0.04227374007680069,0.8009939789772034
cob_syn_3063,COBOL,"      * REFACTOR CANDIDATE BATCH_3063
      * SYSTEM GENERATED
cradle:
  multi:
    - path: ""./test/data""
      config: { cradle: { none:  } }
    - path: ""./""
      config: 
        cradle:
          cabal:
            - path: ""./src""
              component: ""ghcide:lib:ghcide""
            - path: ""./exe""
              component: ""ghcide:exe:ghcide""
            - path: ""./test""
              component: ""ghcide:test:ghcide-tests""
            - path: ""./test/preprocessor""
              component: ""ghcide:exe:ghcide-test-preprocessor""
","This COBOL code appears to be a comment block containing information related to a batch job named ""BATCH_3063"". It includes a list of file paths and configurations for different components within a system. The purpose of the code seems to be to provide documentation or instructions for setting up the system, specifically related to the file paths and configurations for the components mentioned.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The code provided is not written in COBOL as stated, it's in YAML format.",0.0049936829345510496,0.8590471148490906
cob_syn_4586,COBOL,"      * REFACTOR CANDIDATE BATCH_4586
      * SYSTEM GENERATED
      *================================================================*
       IDENTIFICATION                                  DIVISION.
      *================================================================*
       PROGRAM-ID. ""Comandos aritmeticos"".
       AUTHOR. ""LUCAS KURATA"".
      *================================================================*
       ENVIRONMENT                                     DIVISION.
      *=================================================================
      *-----------------------------------------------------------------
       CONFIGURATION                          SECTION.
      *-----------------------------------------------------------------

       SPECIAL-NAMES.


      *-----------------------------------------------------------------
       INPUT-OUTPUT                           SECTION.
      *=================================================================

      *=================================================================
      *-----------------------------------------------------------------
       FILE-CONTROL.
      *=================================================================
       DATA                                            DIVISION.
      *=================================================================
      *-----------------------------------------------------------------
       FILE                                   SECTION.
      *-----------------------------------------------------------------
      *-----------------------------------------------------------------
       WORKING-STORAGE                     SECTION.
       77  WRK-CONTADOR                    PIC 9(3) VALUE ZEROS.

       77  WRK-REPLACE                     PIC 9(2) VALUE 10.

       77  WRK-COMPUTE                     PIC 9(3) VALUE 100.

       77  WRK-RECEBE_COMPUTE              PIC 9(3) VALUE ZEROS.

       77  WRK-SALDO                       PIC 9(4) VALUE ZEROS.

       77  WRK-BOLETO                      PIC ",This COBOL program defines several numeric variables in the working storage section with different PIC clauses specifying their size and initial values. The variables are used for arithmetic operations and maintaining counts in a batch processing environment.,Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention the ""WRK-BOLETO"" variable which is only partially defined in the code.",0.007805988703535686,0.8751944303512573
py_10295,Python,"def transform_describe(self, node, describes, context_variable):
        """"""
        Transform a describe node into a ``TestCase``.

        ``node`` is the node object.
        ``describes`` is the name of the object being described.
        ``context_variable`` is the name bound in the context manager (usually
        ""it"").

        """"""

        body = self.transform_describe_body(node.body, context_variable)
        return ast.ClassDef(
            name=""Test"" + describes.title(),
            bases=[ast.Name(id=""TestCase"", ctx=ast.Load())],
            keywords=[],
            starargs=None,
            kwargs=None,
            body=list(body),
            decorator_list=[],
        )",Transform a describe node into a ``TestCase``.,"Transform a describe node into a ``TestCase``.

        ``node`` is the node object.
        ``describes`` is the name of the object being described.
        ``context_variable`` is the name bound in the context manager (usually
        ""it"").",No Error,False,"The documentation correctly describes the function and its parameters, providing an accurate reflection of the code without any omissions or hallucinations.",0.028115659748972045,0.8599140644073486
py_7821,Python,"def plot_calibrated_diode(dio_cross,chan_per_coarse=8,feedtype='l',**kwargs):
    '''
    Plots the corrected noise diode spectrum for a given noise diode measurement
    after application of the inverse Mueller matrix for the electronics chain.
    '''
    #Get full stokes data for the ND observation
    obs = Waterfall(dio_cross,max_load=150)
    freqs = obs.populate_freqs()
    tsamp = obs.header['tsamp']
    data = obs.data
    obs = None
    I,Q,U,V = get_stokes(data,feedtype)
    data = None

    #Calculate Mueller Matrix variables for each coarse channel
    psis = phase_offsets(I,Q,U,V,tsamp,chan_per_coarse,feedtype,**kwargs)
    G = gain_offsets(I,Q,U,V,tsamp,chan_per_coarse,feedtype,**kwargs)

    #Apply the Mueller matrix to original noise diode data and refold
    I,Q,U,V = apply_Mueller(I,Q,U,V,G,psis,chan_per_coarse,feedtype)
    I_OFF,I_ON = foldcal(I,tsamp,**kwargs)
    Q_OFF,Q_ON = foldcal(Q,tsamp,**kwargs)
    U_OFF,U_ON = foldcal(U,tsamp,**kwargs)
    V_OFF,V_ON = foldcal(V,tsamp,**kwargs)

    #Delete data arrays for space
    I = None
    Q = None
    U = None
    V = None

    #Plot new ON-OFF spectra
    plt.plot(freqs,I_ON-I_OFF,'k-',label='I')
    plt.plot(freqs,Q_ON-Q_OFF,'r-',label='Q')
    plt.plot(freqs,U_ON-U_OFF,'g-',label='U')
    plt.plot(freqs,V_ON-V_OFF,'m-',label='V')

    plt.legend()
    plt.xlabel('Frequency (MHz)')
    plt.title('Calibrated Full Stokes Noise Diode Spectrum')
    plt.ylabel('Power (Counts)')",Plots the corrected noise diode spectrum for a given noise diode measurement after application of the inverse Mueller matrix for the electronics chain.,"Plots the corrected noise diode spectrum for a given noise diode measurement
    after application of the inverse Mueller matrix for the electronics chain.",No Error,False,The provided documentation correctly describes what the function does without hallucination or omission.,1.0,0.9615707993507385
py_8703,Python,"def markdown_to_reST(text):
    '''This is not a general purpose converter. Only converts this readme'''
    # Convert parameters to italics and prepend a newline
    text = re.sub(pattern=r""\n       (\w+) - (.+)\n"",
                  repl=r""\n\n       *\g<1>* - \g<2>\n"",
                  string=text)

    # Parse [http://url](text), and just leave the url
    text = re.sub(pattern=r""\[([^\]]+)\]\([^)]+\)"",
                  repl=r""\g<1>"",
                  string=text)

    # Disable formatting of numbered lists
    text = re.sub(pattern=r""\n(\d+). "",
                  repl=r""\n\\\g<1>. "",
                  string=text)
    return text","This function converts a specific README text from Markdown to reStructuredText format. It italicizes parameters, extracts URLs, and disables formatting for numbered lists. It is not intended for general-purpose conversion tasks.",This is not a general purpose converter. Only converts this readme,No Error,False,The documentation correctly describes the function's operations and intentions with no hallucinations or omissions.,0.024996234713067306,0.8670255541801453
py_12969,Python,"def classification(self, classification):
        """"""
        Sets the classification of this CompanyDetailCompany.
        Classification of Company

        :param classification: The classification of this CompanyDetailCompany.
        :type: str
        """"""
        allowed_values = [""Public Limited Indian Non-Government Company"", ""Private Limited Indian Non-Government Company"", ""One Person Company"", ""Private Limited Foreign Company Incorporated in India"", ""Public Limited Foreign Company Incorporated in India"", ""Union Government Company"", ""State Government Company"", ""Guarantee & Association Public"", ""Guarantee & Association Private"", ""Not For Profit Company"", ""Unlimited Liabilities Public"", ""Unlimited Liabilities Private"", ""Undefined""]
        if classification not in allowed_values:
            raise ValueError(
                ""Invalid value for `classification`, must be one of {0}""
                .format(allowed_values)
            )
        self._classification = classification","Sets the classification of a CompanyDetailCompany object with the provided classification value. The classification must be a string and must be one of the predefined allowed values listed in the docstring. If the provided classification is not in the allowed values, a ValueError is raised.","Sets the classification of this CompanyDetailCompany.
        Classification of Company

        :param classification: The classification of this CompanyDetailCompany.
        :type: str",No Error,False,The generated documentation accurately reflects the source code without any hallucinations or omissions.,0.06290733290326718,0.7859057784080505
py_4288,Python,"def init_package(self, run_object):
        """"""Initializes profiler with a package.""""""
        self.profile = self.profile_package
        self._run_object, _, self._run_args = run_object.partition(' ')
        self._object_name = '%s (package)' % self._run_object
        self._replace_sysargs()",Initializes profiler with a package.,Initializes profiler with a package.,Omission,True,"The documentation does not mention other operations such as partitioning the run_object, creation of the object name, or the action performed by the _replace_sysargs function.",1.0,1.0
cob_syn_2269,COBOL,"      * REFACTOR CANDIDATE BATCH_2269
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HELLO-WORLD.
       PROCEDURE DIVISION.
         DISPLAY 'Hello, world!'.
         STOP RUN.
","This COBOL program defines a simple procedure that displays the message ""Hello, world!"" on the screen and then stops the program execution.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly explains the functionality of the provided source code.,0.012042033681462784,0.8816364407539368
py_9830,Python,"def add_member_by_id(self, member_id, membership_type='normal'):
        '''
        Add a member to the board using the id. Membership type can be
        normal or admin. Returns JSON of all members if successful or raises an
        Unauthorised exception if not.
        '''
        return self.fetch_json(
            uri_path=self.base_uri + '/members/%s' % member_id,
            http_method='PUT',
            query_params={
                'type': membership_type
            }
        )",Add a member to the board using the id. Membership type can be normal or admin. Returns JSON of all members if successful or raises an Unauthorised exception if not.,"Add a member to the board using the id. Membership type can be
        normal or admin. Returns JSON of all members if successful or raises an
        Unauthorised exception if not.",Omission,True,The documentation does not explain the parameters and the function of the method.,1.0,0.9158815741539001
cob_real_64,COBOL,"      ******************************************************************
      * Author: Maxfx
      * Date: 11/5/2016
      * Revision: Maxfx 30/8/2017
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. SIGN-CONDITION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
      ******************************************************************
      * For signed number we use ""S""
      ******************************************************************
           01 NUM01 PIC S9(9) VALUE -5000.
           01 NUM02 PIC S9(9) VALUE 6.
           01 NUM03 PIC 9(9) VALUE ZERO.

       PROCEDURE DIVISION.
       MAIN-PROCEDURE.

           IF NUM01 IS POSITIVE THEN
             DISPLAY 'NUM01 IS POSITIVE'
           END-IF

           IF NUM01 IS NEGATIVE THEN
             DISPLAY 'NUM01 IS NEGATIVE'
           END-IF

           IF NUM02 IS ZERO THEN
             DISPLAY 'NUM02 IS ZERO'
           END-IF

           IF NUM02 IS POSITIVE THEN
             DISPLAY 'NUM02 IS POSITIVE'
           END-IF

           IF NUM03 IS ZERO THEN
             DISPLAY 'NUM03 IS ZERO'
           END-IF

           IF NUM03 IS POSITIVE THEN
             DISPLAY 'NUM03 IS POSITIVE'
           END-IF.

           GOBACK.
","This COBOL program defines three numeric variables - NUM01, NUM02, and NUM03. It then checks each variable for being positive, negative, or zero and displays a message accordingly. Finally, it ends the program.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not mention that NUM01, NUM02, and NUM03 are signed numbers with ""S"", and does not mention the revision history.",0.008588486560503192,0.8667639493942261
py_10360,Python,"def grouper_nofill_str(n, iterable):
	""""""
	Take a sequence and break it up into chunks of the specified size.
	The last chunk may be smaller than size.

	This works very similar to grouper_nofill, except
	it works with strings as well.

	>>> tuple(grouper_nofill_str(3, 'foobarbaz'))
	('foo', 'bar', 'baz')

	You can still use it on non-strings too if you like.

	>>> tuple(grouper_nofill_str(42, []))
	()

	>>> tuple(grouper_nofill_str(3, list(range(10))))
	([0, 1, 2], [3, 4, 5], [6, 7, 8], [9])
	""""""
	res = more_itertools.chunked(iterable, n)
	if isinstance(iterable, six.string_types):
		res = (''.join(item) for item in res)
	return res","Take a sequence and break it up into chunks of the specified size.
The last chunk may be smaller than the specified size.

This function is similar to grouper_nofill, but it can work with strings as well.

You can use it on non-string iterables as well.

Examples:
- Tuple of chunks from a string: tuple(grouper_nofill_str(3, 'foobarbaz')) -> ('foo', 'bar', 'baz')
- Empty tuple: tuple(grouper_nofill_str(42, [])) -> ()
- Tuple of chunks from a list: tuple(grouper_nofill_str(3, list(range(10)))) -> ([0, 1, 2], [3, 4, 5], [6, 7, 8], [9])","Take a sequence and break it up into chunks of the specified size.
	The last chunk may be smaller than size.

	This works very similar to grouper_nofill, except
	it works with strings as well.

	>>> tuple(grouper_nofill_str(3, 'foobarbaz'))
	('foo', 'bar', 'baz')

	You can still use it on non-strings too if you like.

	>>> tuple(grouper_nofill_str(42, []))
	()

	>>> tuple(grouper_nofill_str(3, list(range(10))))
	([0, 1, 2], [3, 4, 5], [6, 7, 8], [9])",No Error,False,The documentation accurately and completely explains the code.,0.4278577881281404,0.9324628114700317
cob_syn_5755,COBOL,"      * REFACTOR CANDIDATE BATCH_5755
      * SYSTEM GENERATED
       PROCESS CICS,NODYNAM,NSYMBOL(NATIONAL),TRUNC(STD)
      * Licensed Materials - Property of IBM
      *
      * SAMPLE
      *
      * (c) Copyright IBM Corp. 2017 All Rights Reserved
      *
      * US Government Users Restricted Rights - Use, duplication or
      * disclosure restricted by GSA ADP Schedule Contract with IBM Corp
      *
      ******************************************************************
      *  ACCTPTNR

      * This program is part of the CICS Asynchronous API Redbooks
      * Internet banking Example

      * ACCTPTNR - Get the current account(s) details from the 
      *            banks partner database.
      * An account number is used to retrieve the account details for
      * a customer. The customer accounts database is hosted on
      * a different system in a different organisation. 
      *
      ******************************************************************

       IDENTIFICATION DIVISION.
        PROGRAM-ID. ACCTPTNR.
        AUTHOR. GOHILPR.

       ENVIRONMENT DIVISION.

       DATA DIVISION.
        WORKING-STORAGE SECTION.

      * Input record
       1 ACCOUNT-NUMBER-IN.
         2 CUST-NO-IN PIC X(4).

       1 RETURN-DATA.
         2 NUMBER-OF-ACCOUNTS     PIC S9(4) COMP-5 SYNC VALUE 9. 
         2 ACCOUNT-DETAILS OCCURS 5 TIMES.
           3 ACCT-NUMBER     PIC X(8) VALUE ' '.
           3 BALANCE         PIC X(8) VALUE ' '.
           3 OVERDRAFT       PIC X(8) VALUE ' '.

       1 CONTAINER-NAMES.
         2 INPUT-CONTAINER    PIC X(16) VALUE 'INPUTCONTAINER  '.
         2 ACCTPTNR-CONTAINER PIC X(16) VALUE 'ACCTPTNRCONT    '.

       1 COMMAND-RESP  PIC S9(8) COMP.
       1 COMMAND-RESP2 PIC S9(8) COMP.

        LINKAGE SECTION.

       PROCEDURE DIVISION .

       MAINLINE SECTION.
       
      * Delay for 4 seconds to indicate an example
      * cross network database read delay
           EXEC CICS DELAY FOR SECONDS(4) END-EXEC

      * Get the input account number

           EXEC CICS GET CONTAINER (","This COBOL program, named ACCTPTNR, is part of the CICS Asynchronous API Redbooks Internet banking Example. It retrieves the account details for a customer from a partner bank's database using an account number as input. The program delays for 4 seconds to simulate a cross-network database read delay before getting the input account number.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.0056860862169080505,0.8548272252082825
py_2377,Python,"async def delete(self, keys: List[str]):
        """"""Remove storeitems from storage.

        :param keys:
        :return:
        """"""
        try:
            # check if the database and container exists and if not create
            if not self.__container_exists:
                self.__create_db_and_container()
            # call the function for each key
            for k in keys:
                self.client.DeleteItem(
                    document_link=self.__item_link(self.__sanitize_key(k)))
                # print(res)
        except cosmos_errors.HTTPFailure as h:
            # print(h.status_code)
            if h.status_code != 404:
                raise h
        except TypeError as e:
            raise e",Remove storeitems from storage.,"Remove storeitems from storage.

        :param keys:
        :return:",No Error,False,The provided documentation correctly describes the method's functionality without any omission or hallucinations.,0.4723665527410147,0.8277970552444458
py_305,Python,"def download_mail_attachments(self,
                                  name,
                                  local_output_directory,
                                  mail_folder='INBOX',
                                  check_regex=False,
                                  latest_only=False,
                                  not_found_mode='raise'):
        """"""
        Downloads mail's attachments in the mail folder by its name to the local directory.

        :param name: The name of the attachment that will be downloaded.
        :type name: str
        :param local_output_directory: The output directory on the local machine
                                       where the files will be downloaded to.
        :type local_output_directory: str
        :param mail_folder: The mail folder where to look at.
        :type mail_folder: str
        :param check_regex: Checks the name for a regular expression.
        :type check_regex: bool
        :param latest_only: If set to True it will only download
                            the first matched attachment.
        :type latest_only: bool
        :param not_found_mode: Specify what should happen if no attachment has been found.
                               Supported values are 'raise', 'warn' and 'ignore'.
                               If it is set to 'raise' it will raise an exception,
                               if set to 'warn' it will only print a warning and
                               if set to 'ignore' it won't notify you at all.
        :type not_found_mode: str
        """"""
        mail_attachments = self._retrieve_mails_attachments_by_name(name,
                                                                    mail_folder,
                                                                    check_regex,
                                                                    latest_only)

        if not mail_attachments:
            self._handle_not_found_mode(not_found_mode)

        self._create_files(mail_attachments, local_output_directory)","Downloads mail's attachments in the mail folder by its name to the local directory. The method accepts various parameters such as the attachment's name, output directory path, mail folder, option to check regex for the name, option to download only the latest matching attachment, and defines behavior when no attachment is found.","Downloads mail's attachments in the mail folder by its name to the local directory.

        :param name: The name of the attachment that will be downloaded.
        :type name: str
        :param local_output_directory: The output directory on the local machine
                                       where the files will be downloaded to.
        :type local_output_directory: str
        :param mail_folder: The mail folder where to look at.
        :type mail_folder: str
        :param check_regex: Checks the name for a regular expression.
        :type check_regex: bool
        :param latest_only: If set to True it will only download
                            the first matched attachment.
        :type latest_only: bool
        :param not_found_mode: Specify what should happen if no attachment has been found.
                               Supported values are 'raise', 'warn' and 'ignore'.
                               If it is set to 'raise' it will raise an exception,
                               if set to 'warn' it will only print a warning and
                               if set to 'ignore' it won't notify you at all.
        :type not_found_mode: str",No Error,False,The documentation accurately reflects the function and its parameters.,0.055227869965346635,0.757193922996521
cob_real_99,COBOL,"       ID DIVISION.
       PROGRAM-ID. EPSMLIST.
      *    THIS DEMONSTRATES CICS/DEBUG           - EPSDEMOS 2008
      *
      *    THIS PROGRAM WILL RECEIVE A DATE AND COVERT THE DATE TO
      *    AN INTEGER IN A CALLED PROGRAM TO DETERMINE DAYS FROM
      *    CURRENT DATE.
      *
      *    (C) 2008 IBM - JIM HILDNER RESERVED.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER. IBM-FLEX-ES.
       OBJECT-COMPUTER. IBM-FLEX-ES.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.
      *
       01  W-FLAGS.
           10  W-SEND-FLAG                    PIC X.
               88  SEND-ERASE                   VALUE '1'.
               88  SEND-DATAONLY                VALUE '2'.
               88  SEND-MAPONLY                 VALUE '3'.
               88  SEND-DATAONLY-ALARM          VALUE '4'.

       01 W-CONVERSIONS.
           05  W-PMT-CNVRT     PIC X(12).
           05  W-PMT-NUMBER
               REDEFINES W-PMT-CNVRT
                               PIC 9(10)V99.
           05  WS-FORMAT-NUMBER PIC Z,ZZZ,ZZ9.99.
           05  W-PRINC-CNVRT   PIC X(12).
           05  W-PRINC-NUMBER
               REDEFINES W-PRINC-CNVRT
                               PIC 9(10)V99.

       01 W-CALL-PROGRAM                      PIC X(8).
       01 RESPONSE                            PIC S9(8) COMP.
       01 INTERNAL-PROGRAM-VARIABLES.
           05 RID-LENGTH                      PIC S9(9) COMP.
           05 DISP-COUNT                      PIC S9(4) COMP.
           05 MAX-LOOP                        PIC S9(4) COMP
                                              VALUE IS 8.
           05 END-OF-FILE                     PIC X.
           05 CLOSE-FILE                      PIC X.
      *
       01 W-RETIREMENT-WA                     PIC 9(4).
       01 W-COMAREA-LENGTH                    PIC 9(4) COMP.

       01 SAVE-COMM-AREA.
          COPY EPSMTCOM.

       01  END-OF-TRANS-MSG                 PIC X(30)
             VALUE 'END OF TRA","This COBOL program is designed to receive a date as input and convert it to an integer in order to determine the number of days from the current date. The program uses various working storage sections to store flags, conversions, call program details, response variables, internal program variables, retirement data, communication area length, and an end of transaction message. There are predefined values and data structures used for handling conversions and program interactions.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not mention the use and role of the 'EPSMTCOM' copybook that is copied into the SAVE-COMM-AREA.,0.004409125062663348,0.8559133410453796
cob_syn_1472,COBOL,"      * REFACTOR CANDIDATE BATCH_1472
      * SYSTEM GENERATED
1|2|3325|771.64|, even theodolites. regular, final theodolites eat after the carefully pending foxes. furiously regular deposits sleep slyly. carefully bold realms above the ironic dependencies haggle careful
1|4|8076|993.49|ven ideas. quickly even packages print. pending multipliers must have to are fluff
1|6|3956|337.09|after the fluffily ironic deposits? blithely special dependencies integrate furiously even excuses. blithely silent theodolites could have to haggle pending, express requests; fu
1|8|4069|357.84|al, regular dependencies serve carefully after the quickly final pinto beans. furiously even deposits sleep quickly final, silent pinto beans. fluffily reg
2|3|8895|378.49|nic accounts. final accounts sleep furiously about the ironic, bold packages. regular, regular accounts
2|5|4969|915.27|ptotes. quickly pending dependencies integrate furiously. fluffily ironic ideas impress blithely above the express accounts. furiously even epitaphs need to wak
2|7|8539|438.37|blithely bold ideas. furiously stealthy packages sleep fluffily. slyly special deposits snooze furiously carefully regular accounts. regular deposits according to the accounts nag carefully slyl
2|9|3025|306.39|olites. deposits wake carefully. even, express requests cajole. carefully regular ex
3|4|4651|920.92|ilent foxes affix furiously quickly unusual requests. even packages across the carefully even theodolites nag above the sp
3|6|4093|498.13|ending dependencies haggle fluffily. regular deposits boost quickly carefully regular requests. deposits affix furiously around the pinto beans. ironic, unusual platelets across the p
3|8|3917|645.40|of the blithely regular theodolites. final theodolites haggle blithely carefully unusual ideas. blithely even f
3|10|9942|191.92| unusual, ironic foxes according to the ideas detect furiously alongside of the even, express requests. blithely regular the
4|5|1339|113.97| carefully unusual ideas. packages use slyly. blithely final pinto beans cajole along the f",This COBOL code appears to be a placeholder or dummy code as it does not contain any valid COBOL statements. The comments in the code suggest that it might be a template or a generated piece of code for testing purposes.,Legacy COBOL logic requiring documentation.,No Error,False,The assertion made in the documentation aligns with the source code as it merely consists of comments and non-executable statements.,0.0071638813215387015,0.8724194765090942
cob_real_3530,COBOL,"       fd   pd00300.
       
       01   f00300-estado.
            03 f00300-cd-empresa                   pic 9(03).
            03 f00300-cd-filial                    pic 9(04).
            03 f00300-id-estado                    pic 9(09).
            03 f00300-cd-estado                    pic 9(02).
            03 f00300-nome-estado                  pic x(55).
            03 f00300-sigla-estado                 pic x(02).
            03 f00300-id-pais                      pic 9(09).
      


","This COBOL code defines a file layout for a file named ""pd00300"". The file contains records with fields representing information about states, including company code, branch code, state ID, state code, state name, state abbreviation, and country ID. Each field is defined with a specific length and format using ""pic"" clauses.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the provided COBOL source code without any omissions or hallucinations.,0.005965939103175657,0.8546662926673889
py_3276,Python,"def log(self, from_date=None, to_date=None, branches=None, encoding='utf-8'):
        """"""Read the commit log from the repository.

        The method returns the Git log of the repository using the
        following options:

            git log --raw --numstat --pretty=fuller --decorate=full
                --all --reverse --topo-order --parents -M -C -c
                --remotes=origin

        When `from_date` is given, it gets the commits equal or older
        than that date. This date is given in a datetime object.

        The list of branches is a list of strings, with the names of the
        branches to fetch. If the list of branches is empty, no commit
        is fetched. If the list of branches is None, all commits
        for all branches will be fetched.

        :param from_date: fetch commits newer than a specific
            date (inclusive)
        :param branches: names of branches to fetch from (default: None)
        :param encoding: encode the log using this format

        :returns: a generator where each item is a line from the log

        :raises EmptyRepositoryError: when the repository is empty and
            the action cannot be performed
        :raises RepositoryError: when an error occurs fetching the log
        """"""
        if self.is_empty():
            logger.warning(""Git %s repository is empty; unable to get the log"",
                           self.uri)
            raise EmptyRepositoryError(repository=self.uri)

        cmd_log = ['git', 'log', '--reverse', '--topo-order']
        cmd_log.extend(self.GIT_PRETTY_OUTPUT_OPTS)

        if from_date:
            dt = from_date.strftime(""%Y-%m-%d %H:%M:%S %z"")
            cmd_log.append('--since=' + dt)

        if to_date:
            dt = to_date.strftime(""%Y-%m-%d %H:%M:%S %z"")
            cmd_log.append('--until=' + dt)

        if branches is None:
            cmd_log.extend(['--branches', '--tags', '--remotes=origin'])
        elif len(branches) == 0:
            cmd_log.append('--max-count=0')
        else:
            branches = ['refs/heads/' + branch for branch in branches]
            cmd_log.extend(branches)

        for line in self._exec_nb(cmd_log, cwd=self.dirpath, env=self.gitenv):
            yield line

        logger.debug(""Git log fetched from %s repository (%s)"",
                     self.uri, self.dirpath)","""""""Reads the commit log from the Git repository based on specified criteria.

The method retrieves the Git log of the repository using various options like --raw, --numstat, --pretty=fuller, --decorate=full, --all, --reverse, --topo-order, --parents, -M, -C, -c, --remotes=origin.

If a `from_date` is provided, it fetches commits equal to or older than that date, which is expected to be a datetime object.

The `branches` parameter controls which branches' commits to fetch. Providing an empty list means no commits are fetched, while None fetches all commits from all branches.

:param from_date: Fetch commits newer than or equal to the specified date
:param to_date: Fetch commits older than or equal to the specified date
:param branches: Names of branches to fetch (default: None)
:param encoding: Encoding format for the log output

:returns: A generator where each item represents a line from the log

:raises EmptyRepositoryError: If the repository is empty and log retrieval fails
:raises RepositoryError: If an error occurs during log fetch operation
""""""","Read the commit log from the repository.

        The method returns the Git log of the repository using the
        following options:

            git log --raw --numstat --pretty=fuller --decorate=full
                --all --reverse --topo-order --parents -M -C -c
                --remotes=origin

        When `from_date` is given, it gets the commits equal or older
        than that date. This date is given in a datetime object.

        The list of branches is a list of strings, with the names of the
        branches to fetch. If the list of branches is empty, no commit
        is fetched. If the list of branches is None, all commits
        for all branches will be fetched.

        :param from_date: fetch commits newer than a specific
            date (inclusive)
        :param branches: names of branches to fetch from (default: None)
        :param encoding: encode the log using this format

        :returns: a generator where each item is a line from the log

        :raises EmptyRepositoryError: when the repository is empty and
            the action cannot be performed
        :raises RepositoryError: when an error occurs fetching the log",Omission,True,The documentation does not mention the 'to_date' parameter which is used in the code to fetch commits older than or equal to the specified date.,0.23731293400433318,0.8348668813705444
py_2400,Python,"def _do_pass(self, pass_, dag, options):
        """"""Do a pass and its ""requires"".

        Args:
            pass_ (BasePass): Pass to do.
            dag (DAGCircuit): The dag on which the pass is ran.
            options (dict): PassManager options.
        Returns:
            DAGCircuit: The transformed dag in case of a transformation pass.
            The same input dag in case of an analysis pass.
        Raises:
            TranspilerError: If the pass is not a proper pass instance.
        """"""

        # First, do the requires of pass_
        if not options[""ignore_requires""]:
            for required_pass in pass_.requires:
                dag = self._do_pass(required_pass, dag, options)

        # Run the pass itself, if not already run
        if pass_ not in self.valid_passes:
            if pass_.is_transformation_pass:
                pass_.property_set = self.fenced_property_set
                new_dag = pass_.run(dag)
                if not isinstance(new_dag, DAGCircuit):
                    raise TranspilerError(""Transformation passes should return a transformed dag.""
                                          ""The pass %s is returning a %s"" % (type(pass_).__name__,
                                                                             type(new_dag)))
                dag = new_dag
            elif pass_.is_analysis_pass:
                pass_.property_set = self.property_set
                pass_.run(FencedDAGCircuit(dag))
            else:
                raise TranspilerError(""I dont know how to handle this type of pass"")

            # update the valid_passes property
            self._update_valid_passes(pass_, options['ignore_preserves'])

        return dag","Do a pass and its ""requires"" on a given DAGCircuit with the specified PassManager options. Returns the transformed DAGCircuit in case of a transformation pass and the same input DAGCircuit in case of an analysis pass. Raises a TranspilerError if the pass is not a proper pass instance.","Do a pass and its ""requires"".

        Args:
            pass_ (BasePass): Pass to do.
            dag (DAGCircuit): The dag on which the pass is ran.
            options (dict): PassManager options.
        Returns:
            DAGCircuit: The transformed dag in case of a transformation pass.
            The same input dag in case of an analysis pass.
        Raises:
            TranspilerError: If the pass is not a proper pass instance.",No Error,False,The generated documentation accurately represents the source code without any omission or hallucination.,0.33489841699030326,0.8152225613594055
cob_real_2699,COBOL,"identification division.
program-id. sierpinski-triangle-program.
data division.
working-storage section.
01  sierpinski.
    05 n              pic 99.
    05 i              pic 999.
    05 k              pic 999.
    05 m              pic 999.
    05 c              pic 9(18).
    05 i-limit        pic 999.
    05 q              pic 9(18).
    05 r              pic 9.
procedure division.
control-paragraph.
    move 4 to n.
    multiply n by 4 giving i-limit.
    subtract 1 from i-limit.
    perform sierpinski-paragraph
    varying i from 0 by 1 until i is greater than i-limit.
    stop run.
sierpinski-paragraph.
    subtract i from i-limit giving m.
    multiply m by 2 giving m.
    perform m times,
    display space with no advancing,
    end-perform.
    move 1 to c.
    perform inner-loop-paragraph
    varying k from 0 by 1 until k is greater than i.
    display ''.
inner-loop-paragraph.
    divide c by 2 giving q remainder r.
    if r is equal to zero then display '  * ' with no advancing.
    if r is not equal to zero then display '    ' with no advancing.
    compute c = c * (i - k) / (k + 1).
",This COBOL program generates a Sierpinski triangle pattern by displaying spaces and asterisks based on calculations involving the loop index variables. The triangle is built by adjusting the number of spaces and asterisks in each row according to certain mathematical conditions.,Legacy COBOL logic requiring documentation.,No Error,False,"The documentation accurately describes the process, purpose, and calculations of the COBOL program's code.",0.0071638813215387015,0.8608032464981079
py_6984,Python,"def inner_fork_insanity_checks(pipeline_string):
    """"""
    This function performs two sanity checks in the pipeline string. The first
    check, assures that each fork contains a lane token '|', while the second
    check looks for duplicated processes within the same fork.

    Parameters
    ----------
    pipeline_string: str
         String with the definition of the pipeline, e.g.::
             'processA processB processC(ProcessD | ProcessE)'

    """"""

    # first lets get all forks to a list.
    list_of_forks = []  # stores forks
    left_indexes = []  # stores indexes of left brackets

    # iterate through the string looking for '(' and ')'.
    for pos, char in enumerate(pipeline_string):
        if char == FORK_TOKEN:
            # saves pos to left_indexes list
            left_indexes.append(pos)
        elif char == CLOSE_TOKEN and len(left_indexes) > 0:
            # saves fork to list_of_forks
            list_of_forks.append(pipeline_string[left_indexes[-1] + 1: pos])
            # removes last bracket from left_indexes list
            left_indexes = left_indexes[:-1]

    # sort list in descending order of number of forks
    list_of_forks.sort(key=lambda x: x.count(FORK_TOKEN), reverse=True)

    # Now, we can iterate through list_of_forks and check for errors in each
    # fork
    for fork in list_of_forks:
        # remove inner forks for these checks since each fork has its own entry
        # in list_of_forks. Note that each fork is now sorted in descending
        # order which enables to remove sequentially the string for the fork
        # potentially with more inner forks
        for subfork in list_of_forks:
            # checks if subfork is contained in fork and if they are different,
            # avoiding to remove itself
            if subfork in list_of_forks and subfork != fork:
                # removes inner forks. Note that string has no spaces
                fork_simplified = fork.replace(""({})"".format(subfork), """")
            else:
                fork_simplified = fork

        # Checks if there is no fork separator character '|' within each fork
        if not len(fork_simplified.split(LANE_TOKEN)) > 1:
            raise SanityError(""One of the forks doesn't have '|' ""
                              ""separator between the processes to fork. This is""
                              "" the prime suspect: '({})'"".format(fork))","This function performs two sanity checks in the pipeline string. The first check assures that each fork contains a lane token '|', while the second check looks for duplicated processes within the same fork.","This function performs two sanity checks in the pipeline string. The first
    check, assures that each fork contains a lane token '|', while the second
    check looks for duplicated processes within the same fork.

    Parameters
    ----------
    pipeline_string: str
         String with the definition of the pipeline, e.g.::
             'processA processB processC(ProcessD | ProcessE)'",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.5586450767132758,0.8793701529502869
cob_real_1658,COBOL,"       Identification Division.
       Program-ID. testantlr022.
       Data Division.
       Working-Storage Section.

       01  CONSTANTS.
           05  MYNAME               PIC X(012) VALUE 'testantlr022'.
           05  PGM-0001             PIC X(008) VALUE 'PGMA0001'.
           05  PGM-0002             PIC X(008) VALUE 'PGMA0002'.
           05  PGM-0003             PIC X(008) VALUE 'PGMA0003'.

      *

       COPY 'testantlr005.cpy' REPLACING ==:PRFX:== BY ==AA-==
       .
       

       Procedure Division.
           DISPLAY MYNAME ' Begin'
           

           DISPLAY MYNAME ' End'
           
           GOBACK
           .


",This COBOL program defines constants representing program names and then displays a message indicating the beginning and end of the program execution. The program uses a COPY statement to include external copybook 'testantlr005.cpy' with specific text replacements.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the operations of the source code and contains no hallucinations or omissions.,0.007805988703535686,0.8679026961326599
py_4340,Python,"def _score(estimator, Z_test, scorer):
    """"""Compute the score of an estimator on a given test set.""""""
    score = scorer(estimator, Z_test)
    if not isinstance(score, numbers.Number):
        raise ValueError(""scoring must return a number, got %s (%s) instead.""
                         % (str(score), type(score)))
    return score",Compute the score of an estimator on a given test set.,Compute the score of an estimator on a given test set.,Omission,True,"The documentation does not mention about the type check for score, raising an exception when the score is not a number.",1.0,1.0000001192092896
py_11436,Python,"def djfrontend_normalize(version=None):
    """"""
    Returns Normalize CSS file.
    Included in HTML5 Boilerplate.
    """"""
    if version is None:
        version = getattr(settings, 'DJFRONTEND_NORMALIZE', DJFRONTEND_NORMALIZE_DEFAULT)

    return format_html(
        '<link rel=""stylesheet"" href=""{0}djfrontend/css/normalize/{1}/normalize.css"">',
        _static_url, version)","Returns Normalize CSS file included in HTML5 Boilerplate. The `version` parameter allows specifying the version of the CSS file; if not provided, it falls back to a default version defined in the settings. The function then formats an HTML link to the Normalize CSS file using the specified or default version.","Returns Normalize CSS file.
    Included in HTML5 Boilerplate.",No Error,False,The documentation correctly describes the function and its behavior.,0.042117685498138775,0.8780950903892517
cob_syn_9982,COBOL,"      * REFACTOR CANDIDATE BATCH_9982
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID.    TSUBR10.
000300 AUTHOR.        COMPUWARE ISPW TRAINING.
000400 DATE-WRITTEN.  JANUARY 24TH, 1996.
000500 DATE-COMPILED.
000600
000700********************************************************
000800* THIS PROGRAM IS A TRAINING PROGRAM
000900*      CALLED FROM    TPROG10
001000*      WITH COPYLIB   TCPYB10 (LINKAGE AREA)
001100* ======================================================
001200*  ISPW (TM)
001300*  COPYRIGHT (C) 1986-2016 COMPUWARE CORPORATION.
001400*  UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT
001500*  LAWS OF THE UNITED STATES.
001600*
001700* ======================================================
001800*                   MODIFICATION  LOG
001900*
002000*  DD/MM/YY  PROGRAMMER  CHANGES
002100*  ********  **********  *******
002200*  96/01/24  ISPW        NEW PROGRAM
002300* ======================================================
002400 ENVIRONMENT DIVISION.
002500 CONFIGURATION SECTION.
002600 SOURCE-COMPUTER. IBM-370.
002700 OBJECT-COMPUTER. IBM-370.
002800
002900 INPUT-OUTPUT SECTION.
003000 FILE-CONTROL.
003100
003200********************************************************
003300*  FILES USED:
003400*   INPUT   JUST SOME DUMMY DATA TO READ IN
003500********************************************************
003600     SELECT INFILE  ASSIGN UT-S-INPUT
003700       ORGANIZATION IS SEQUENTIAL
003800       ACCESS IS SEQUENTIAL.
003900
004000
004100 DATA DIVISION.
004200
004300 FILE SECTION.
004400
004500 FD  INFILE
004600     LABEL RECORDS OMITTED
004700     BLOCK CONTAINS 0 RECORDS
004800     RECORDING MODE IS F
004900     DATA RECORD IS INPUT-REC.
005000
005100 01  INPUT-REC         PIC X(80).
005200
005300 WORKING-STORAGE SECTION.
005400
005500 01   INFILE-OPEN-FLAG     PIC X(1) VALUE 'N'.
005600      88 INFILE-OPEN       VALUE 'Y'.
005700
005800 LINKAGE SECTION.
005900********************************************************
006000**** A C","This COBOL program, named TSUBR10, is a training program called from TPROG10 with a copy library TCPYB10. It reads dummy data from an input file sequentially. The program includes information about its purpose, copyright, and modification log.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.007805988703535686,0.8665931820869446
py_2254,Python,"def autocorrelate(y, max_size=None, axis=-1):
    """"""Bounded auto-correlation

    Parameters
    ----------
    y : np.ndarray
        array to autocorrelate

    max_size  : int > 0 or None
        maximum correlation lag.
        If unspecified, defaults to `y.shape[axis]` (unbounded)

    axis : int
        The axis along which to autocorrelate.
        By default, the last axis (-1) is taken.

    Returns
    -------
    z : np.ndarray
        truncated autocorrelation `y*y` along the specified axis.
        If `max_size` is specified, then `z.shape[axis]` is bounded
        to `max_size`.

    Notes
    -----
    This function caches at level 20.

    Examples
    --------
    Compute full autocorrelation of y

    >>> y, sr = librosa.load(librosa.util.example_audio_file(), offset=20, duration=10)
    >>> librosa.autocorrelate(y)
    array([  3.226e+03,   3.217e+03, ...,   8.277e-04,   3.575e-04], dtype=float32)

    Compute onset strength auto-correlation up to 4 seconds

    >>> import matplotlib.pyplot as plt
    >>> odf = librosa.onset.onset_strength(y=y, sr=sr, hop_length=512)
    >>> ac = librosa.autocorrelate(odf, max_size=4* sr / 512)
    >>> plt.plot(ac)
    >>> plt.title('Auto-correlation')
    >>> plt.xlabel('Lag (frames)')

    """"""

    if max_size is None:
        max_size = y.shape[axis]

    max_size = int(min(max_size, y.shape[axis]))

    # Compute the power spectrum along the chosen axis
    # Pad out the signal to support full-length auto-correlation.
    fft = get_fftlib()
    powspec = np.abs(fft.fft(y, n=2 * y.shape[axis] + 1, axis=axis))**2

    # Convert back to time domain
    autocorr = fft.ifft(powspec, axis=axis)

    # Slice down to max_size
    subslice = [slice(None)] * autocorr.ndim
    subslice[axis] = slice(max_size)

    autocorr = autocorr[tuple(subslice)]

    if not np.iscomplexobj(y):
        autocorr = autocorr.real

    return autocorr","Bounded auto-correlation

Parameters
----------
y : np.ndarray
    array to autocorrelate

max_size  : int > 0 or None
    maximum correlation lag.
    If unspecified, defaults to `y.shape[axis]` (unbounded)

axis : int
    The axis along which to autocorrelate.
    By default, the last axis (-1) is taken.

Returns
-------
z : np.ndarray
    truncated autocorrelation `y*y` along the specified axis.
    If `max_size` is specified, then `z.shape[axis]` is bounded
    to `max_size`.

Notes
-----
This function caches at level 20.

Examples
--------
Compute full autocorrelation of y

>>> y, sr = librosa.load(librosa.util.example_audio_file(), offset=20, duration=10)
>>> librosa.autocorrelate(y)
array([  3.226e+03,   3.217e+03, ...,   8.277e-04,   3.575e-04], dtype=float32)

Compute onset strength auto-correlation up to 4 seconds

>>> import matplotlib.pyplot as plt
>>> odf = librosa.onset.onset_strength(y=y, sr=sr, hop_length=512)
>>> ac = librosa.autocorrelate(odf, max_size=4* sr / 512)
>>> plt.plot(ac)
>>> plt.title('Auto-correlation')
>>> plt.xlabel('Lag (frames)')","Bounded auto-correlation

    Parameters
    ----------
    y : np.ndarray
        array to autocorrelate

    max_size  : int > 0 or None
        maximum correlation lag.
        If unspecified, defaults to `y.shape[axis]` (unbounded)

    axis : int
        The axis along which to autocorrelate.
        By default, the last axis (-1) is taken.

    Returns
    -------
    z : np.ndarray
        truncated autocorrelation `y*y` along the specified axis.
        If `max_size` is specified, then `z.shape[axis]` is bounded
        to `max_size`.

    Notes
    -----
    This function caches at level 20.

    Examples
    --------
    Compute full autocorrelation of y

    >>> y, sr = librosa.load(librosa.util.example_audio_file(), offset=20, duration=10)
    >>> librosa.autocorrelate(y)
    array([  3.226e+03,   3.217e+03, ...,   8.277e-04,   3.575e-04], dtype=float32)

    Compute onset strength auto-correlation up to 4 seconds

    >>> import matplotlib.pyplot as plt
    >>> odf = librosa.onset.onset_strength(y=y, sr=sr, hop_length=512)
    >>> ac = librosa.autocorrelate(odf, max_size=4* sr / 512)
    >>> plt.plot(ac)
    >>> plt.title('Auto-correlation')
    >>> plt.xlabel('Lag (frames)')",No Error,False,"The documentation accurately describes the source code, providing sufficient details about its parameters, return values, and usage examples. There's no evidence of hallucinations or omissions.",1.0,0.9372525811195374
cob_syn_9929,COBOL,"      * REFACTOR CANDIDATE BATCH_9929
      * SYSTEM GENERATED
123456 IDENTIFICATION DIVISION. 
       PROGRAM-ID. UD05E3.
       REMARKS. UNIDAD 5. EJERCICIO 3.
      *
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
           DECIMAL-POINT IS COMMA.   
      *			  
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77 NOMBRE    PIC  X(15).
       77 APELLIDO1 PIC  X(15).
       77 APELLIDO2 PIC  X(15).
       77 SEXO      PIC  X.
       77 GUION     PIC X(64) VALUE ALL '-'.
       77 LIN       PIC 99.
       77 CONTADOR  PIC 99.
      *
       PROCEDURE DIVISION.
       INICIO.
           PERFORM PREPARAR.
           PERFORM PANTALLA.
           PERFORM PEDIR 10 TIMES.
           STOP RUN.
      *
      * Limpia la pantalla e inicializa variables.
       PREPARAR.
           DISPLAY SPACE ERASE.
           MOVE 8 TO LIN.
           MOVE ZEROS TO CONTADOR.
      *
      * ************************************************
      * Mostrar Cabecera de pantalla
      * ************************************************
       PANTALLA.  
           DISPLAY 'N.'         LINE  7 POSITION 3  HIGH.
           DISPLAY 'NOMBRE'     LINE  7 POSITION 6  HIGH.
           DISPLAY 'APELLIDO 1' LINE  7 POSITION 23 HIGH.
           DISPLAY 'APELLIDO 2' LINE  7 POSITION 40 HIGH.
           DISPLAY 'SEXO'       LINE  7 POSITION 58 HIGH.
           DISPLAY GUION        LINE  8 POSITION 3  HIGH.
      *
      * ************************************************
      * Peticion de datos
      * ************************************************
       PEDIR.
           DISPLAY SPACES LINE 23 COLUMN 1 ERASE EOS.
           DISPLAY 'Introduce el nombre.:'  
                    NO ADVANCING LINE 23 POSITION 5 HIGH.
           ACCEPT NOMBRE NO BEEP.
      * 
           DISPLAY SPACES LINE 23 COLUMN 1 ERASE EOS.
           DISPLAY 'Introduce el primer apellido.:'  
                    NO ADVANCING LINE 23 POSITION 5 HIGH.
           ACCEPT APELLIDO1 NO BEEP.
      * 
           DISPLAY SPACES LINE 23 COLUMN 1 ERASE ","This COBOL code defines a program that prompts the user to enter personal information such as a name, two last names, and gender. The program displays a screen with labels for each field and then sequentially prompts the user for each piece of information. The input fields are cleared before each input prompt is shown, and the program terminates after prompting for information 10 times.",Legacy COBOL logic requiring documentation.,No Error,False,The generated documentation accurately describes the functionality of the provided COBOL code.,0.004863687509482329,0.8619502186775208
py_8004,Python,"def _enforce_no_overlap(self, start_at=0):
        """"""Enforce that no ranges overlap in internal storage.""""""
        i = start_at
        while i+1 < len(self.data):
            if self.data[i][1] >= self.data[i+1][0]:
                # beginning of i+1-th range is contained in i-th range
                if self.data[i][1] < self.data[i+1][1]:
                    # i+1-th range is longer, thus enlarge i-th range
                    self.data[i][1] = self.data[i+1][1]

                # removed contained range
                del self.data[i+1]
            i += 1",Enforce that no ranges overlap in internal storage.,Enforce that no ranges overlap in internal storage.,No Error,False,The documentation accurately describes what the code does without any omissions or hallucinations.,1.0,0.9999998807907104
py_12108,Python,"def build_callback_url(request, urlname, message):
    """"""
    Build Twilio callback url for confirming message delivery status

    :type message: OutgoingSMS
    """"""
    location = reverse(urlname, kwargs={""pk"": message.pk})

    callback_domain = getattr(settings, ""TWILIO_CALLBACK_DOMAIN"", None)
    if callback_domain:
        url = ""{}://{}{}"".format(
            ""https"" if getattr(settings, ""TWILIO_CALLBACK_USE_HTTPS"", False) else ""http"",
            callback_domain,
            location
        )

    elif request is not None:
        url = request.build_absolute_uri(location)
    else:
        raise ValueError(
            ""Unable to build callback url. Configure TWILIO_CALLBACK_DOMAIN ""
            ""or pass request object to function call""
        )
    return url",Build Twilio callback url for confirming message delivery status,"Build Twilio callback url for confirming message delivery status

    :type message: OutgoingSMS",Omission,True,The documentation doesn't mention about usage and purpose of request and urlname parameters in build_callback_url function.,0.7165313105737893,0.9282751083374023
py_9338,Python,"def DeleteItem(self, item):
        ""Remove the item from the list and unset the related data""
        wx_data = self.GetItemData(item)
        py_data = self._py_data_map[wx_data]
        del self._py_data_map[wx_data]
        del self._wx_data_map[py_data]
        wx.ListCtrl.DeleteItem(self, item)",Remove the item from the list and unset the related data.,Remove the item from the list and unset the related data,Omission,True,The documentation does not mention about the deleting process that occurs with the '_py_data_map' and '_wx_data_map'.,0.8931539818068694,0.9921994209289551
py_5169,Python,"def add_transaction(self, transaction):
        # type: (ProposedTransaction) -> None
        """"""
        Adds a transaction to the bundle.

        If the transaction message is too long, it will be split
        automatically into multiple transactions.
        """"""
        if self.hash:
            raise RuntimeError('Bundle is already finalized.')

        if transaction.value < 0:
            raise ValueError('Use ``add_inputs`` to add inputs to the bundle.')

        self._transactions.append(ProposedTransaction(
            address=transaction.address,
            value=transaction.value,
            tag=transaction.tag,
            message=transaction.message[:Fragment.LEN],
            timestamp=transaction.timestamp,
        ))

        # If the message is too long to fit in a single transactions,
        # it must be split up into multiple transactions so that it will
        # fit.
        fragment = transaction.message[Fragment.LEN:]
        while fragment:
            self._transactions.append(ProposedTransaction(
                address=transaction.address,
                value=0,
                tag=transaction.tag,
                message=fragment[:Fragment.LEN],
                timestamp=transaction.timestamp,
            ))

            fragment = fragment[Fragment.LEN:]","Adds a transaction to the bundle. If the transaction message is too long, it will be split automatically into multiple transactions.","Adds a transaction to the bundle.

        If the transaction message is too long, it will be split
        automatically into multiple transactions.",No Error,False,The documentation accurately describes the code's function without any unsupported claims or critical omissions.,1.0,0.9016876816749573
py_14358,Python,"def get_pid_from_file(self):
        """"""Get the pid from the pid file.

        If the  pid file doesn't exist a :exc:`PIDFileError` is raised.
        """"""
        pid_file = os.path.join(self.profile_dir.pid_dir, self.name + u'.pid')
        if os.path.isfile(pid_file):
            with open(pid_file, 'r') as f:
                s = f.read().strip()
                try:
                    pid = int(s)
                except:
                    raise PIDFileError(""invalid pid file: %s (contents: %r)""%(pid_file, s))
                return pid
        else:
            raise PIDFileError('pid file not found: %s' % pid_file)","Get the pid from the pid file.

If the pid file doesn't exist a `PIDFileError` is raised.","Get the pid from the pid file.

        If the  pid file doesn't exist a :exc:`PIDFileError` is raised.",No Error,False,The documentation accurately reflects what the code is doing.,0.848219861937046,0.9349977374076843
cob_syn_8438,COBOL,"      * REFACTOR CANDIDATE BATCH_8438
      * SYSTEM GENERATED
       IDENTIFICATION DIVISION.
       PROGRAM-ID. COBOLAMBDA.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       PROCEDURE DIVISION.
           DISPLAY ""Hello Serverless World!"".
","This COBOL code defines a program with the program ID COBOLAMBDA that simply displays the message ""Hello Serverless World!"" when executed.",Legacy COBOL logic requiring documentation.,No Error,False,"The code directly corresponds to the provided documentation, showing no discrepancies.",0.012518377344512808,0.875497043132782
cob_real_2882,COBOL,"       Process cics('cobol3,sp')
       Process arith(extend) trunc(bin) list map xref rent
      *****************************************************************
      * Licensed Materials - Property of IBM
      *
      * CICS SupportPac CA1Y - CICS  TS support for sending emails
      *
      *  Copyright IBM Corporation 2012 All Rights Reserved.
      *
      *  US Government Users Restricted Rights - Use, duplication,
      *  or disclosure restricted by GSA ADP Schedule Contract with
      *  IBM Corporation.
      *****************************************************************
      * This example illustrates how to convert an XML document to a
      * PDF document using an XSLT stylesheet.
      *
      * The container named ""CA1Y"" is created with properties:
      * 1. MyXSLT that loads the XSLT document from zFS.
      * 2. MyPDF that puts the converted PDF document into container
      *    ""PDF"". The PDF documented is created by converting from
      *    MIME type text/xml to application/pdf using the XSLT in
      *    property MyXSLT.
      * 
      * The SupportPac program CA1Y is then called to create the PDF
      * document. The PDF document is then retrieved from the ""PDF""
      * container.
      *****************************************************************
       Identification Division.
       Program-id. CA1YCOB4.
       Environment division.
       Data division.
      *****************************************************************
       Working-storage section.
       01 CONFIG.
           02 CONFIG-CHANNEL-NAME   PIC X(16) VALUE 'MyChannel       '.
           02 CONFIG-CONT-NAME      PIC X(16) VALUE 'CA1Y            '.
           02 CONFIG-DATA-LENGTH    PIC 9(8) COMP VALUE 0.
           02 CONFIG-DATA           PIC X(2048) VALUE SPACES.
       01 PDF-DOC.
           02 PDF-CONT-NAME         PIC X(16) VALUE 'PDF             '.
           02 PDF-DATA-LENGTH       PIC 9(8) COMP VALUE 0.
           02 PDF-DATA              PIC X","This COBOL program demonstrates converting an XML document to a PDF using an XSLT stylesheet. It creates a container named ""CA1Y"" with properties for loading XSLT from zFS and putting the converted PDF. The SupportPac program CA1Y is used to create and retrieve the PDF document from the ""PDF"" container.",Legacy COBOL logic requiring documentation.,Omission,True,"The documentation does not include details about the working-storage section of the code, including information about CONFIG and PDF-DOC variables.",0.006065997938636506,0.8542557954788208
cob_syn_4171,COBOL,"      * REFACTOR CANDIDATE BATCH_4171
      * SYSTEM GENERATED
       ID Division.
      * 
      * Copyright (C) 2021 Craig Schneiderwent.  All rights reserved.
      * 
      * I accept no liability for damages of any kind resulting 
      * from the use of this software.  Use at your own risk.
      *
      * This software may be modified and distributed under the terms
      * of the MIT license. See the LICENSE file for details.
      *
      *
       Program-ID. cs03b.
       Environment Division.
       Input-Output Section.
       File-Control.
           Select INPT-DATA            Assign Keyboard.
       Data Division.
       File Section.
       FD  INPT-DATA.
       01  INPT-DATA-REC-MAX PIC X(024).

       Working-Storage Section.
       01  CONSTANTS.
           05  MYNAME             PIC X(008) VALUE 'cs03b'.

       01  WORK-AREAS.
           05  WS-REC-COUNT       PIC 9(008) COMP    VALUE 0.
           05  O2-COUNT           PIC 9(008) COMP    VALUE 9.
           05  CO2-COUNT          PIC 9(008) COMP    VALUE 9.
           05  O2-INDX            PIC 9(009) COMP    VALUE 0.
           05  CO2-INDX           PIC 9(009) COMP    VALUE 0.
           05  BIT-EXPONENT       PIC 9(008) COMP    VALUE 0.
           05  NB-BITS            PIC 9(008) COMP    VALUE 1.
           05  BIT-TO-COUNT       PIC 9(008) COMP    VALUE 0.
           05  CURR-PRODUCT       PIC 9(018) COMP    VALUE 0.
           05  O2-RATING          PIC 9(018) COMP    VALUE 0.
           05  CO2-RATING         PIC 9(018) COMP    VALUE 0.
           05  PROCESS-TYPE       PIC X(004)         VALUE LOW-VALUES.

       01  WS-INPT-DATA.
           05  WS-INPT            PIC X(024)         VALUE SPACES.

       01  SWITCHES.
           05  INPT-DATA-EOF-SW   PIC X(001)         VALUE 'N'.
               88  INPT-DATA-EOF                     VALUE 'Y'.
           05  PROCESS-SW         PIC X(004)         VALUE LOW-VALUES.
               88  PROCESS-TEST                      VALUE 'TEST'.

       01  BIT-COUNTS.
           05  BIT-COUNT-TABLE
              ","This COBOL code is a program with various sections defining file control, data divisions, working storage sections, and different data structures. It seems to handle input data processing and manipulation based on the defined variables and configurations.",Legacy COBOL logic requiring documentation.,Omission,True,The documentation does not explain the function and use of specific variables and data structures in the program.,0.007805988703535686,0.8749855160713196
py_9912,Python,"def decode(self, packet):
        '''
        Decode a CONNECT control packet. 
        '''
        self.encoded = packet
        # Strip the fixed header plus variable length field
        lenLen = 1
        while packet[lenLen] & 0x80:
            lenLen += 1
        packet_remaining = packet[lenLen+1:]
        # Variable Header
        version_str, packet_remaining = decodeString(packet_remaining)
        version_id = int(packet_remaining[0])
        if version_id == v31['level']:
            self.version = v31
        else:
            self.version = v311
        flags = packet_remaining[1]
        self.cleanStart = (flags & 0x02) != 0
        willFlag   = (flags & 0x04) != 0
        willQoS    = (flags >> 3) & 0x03
        willRetain = (flags & 0x20) != 0
        userFlag   = (flags & 0x80)  != 0
        passFlag   = (flags & 0x40)  != 0
        packet_remaining = packet_remaining[2:]
        self.keepalive = decode16Int(packet_remaining)
        # Payload
        packet_remaining = packet_remaining[2:]
        self.clientId, packet_remaining = decodeString(packet_remaining)
        if willFlag:
            self.willRetain = willRetain
            self.willQoS    = willQoS
            self.willTopic,  packet_remaining  = decodeString(packet_remaining)
            self.willMessage, packet_remaining = decodeString(packet_remaining)
        if userFlag:
            self.username, packet_remaining = decodeString(packet_remaining)
        if passFlag:
            l = decode16Int(packet_remaining)
            self.password = packet_remaining[2:2+l]","Decode a CONNECT control packet and extract relevant information such as version, flags, clean start, will flag, will QoS, will retain, user flag, password, and other payload details.",Decode a CONNECT control packet.,Omission,True,"The documentation does not mention about 'version_id', 'clientId', 'willTopic', 'willMessage', 'username' that are also extracted from the CONNECT control packet.",0.08359764098433711,0.904685378074646
cob_syn_1161,COBOL,"      * REFACTOR CANDIDATE BATCH_1161
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. SCTN.
 PROCEDURE DIVISION.
 SOME-SECTION SECTION.
     INIT.
        STOP RUN.
        PERFORM INIT.
     AFTER-INIT.
        DISPLAY ""Hello World"".
        STOP RUN.","This COBOL code defines a program with a section called SOME-SECTION. This section contains two paragraphs, INIT and AFTER-INIT. The INIT paragraph calls itself recursively, creating an infinite loop. The AFTER-INIT paragraph displays ""Hello World"" and stops the program.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,The INIT paragraph does not create an infinite loop as it is only called once and does not call itself recursively.,0.007469938459592591,0.857502818107605
cob_syn_2547,COBOL,"      * REFACTOR CANDIDATE BATCH_2547
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      * By default queue name of GENAERRS is used if                   *
      *  parm Q=nnnn is passed then Queue name GENAnnnn is used        *
      *                                                                *
      *                                                                *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGSTSQ.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       01  WS-FLAG                   PIC X.
       01  WS-RESP                   PIC S9(8) COMP.
       01  WS-STARTCODE              PIC XX Value spaces.
       01  WS-INVOKEPROG             PIC X(8) Value spaces.
       01  WS-PRINSYSID              P","This COBOL program defines working storage variables and provides informational notes and copyright details. It includes placeholders for flags, response codes, program identification, and other system-specific information. The main purpose of this program seems to be related to handling queues, with options to customize queue names based on input parameters.",Legacy COBOL logic requiring documentation.,No Error,False,"The documentation accurately reflects the code's working storage variables, program identification, and queue-handling functions.",0.006065997938636506,0.8695831894874573
cob_real_2414,COBOL,"      *****************************************************************
      *                                                               *
      * Copyright (C) 2020-2022 Micro Focus.  All Rights Reserved.    *
      * This software may be used, modified, and distributed          *
      * (provided this notice is included without modification)       *
      * solely for demonstration purposes with other                  *
      * Micro Focus software, and is otherwise subject to the EULA at *
      * https://www.microfocus.com/en-us/legal/software-licensing.    *
      *                                                               *
      * THIS SOFTWARE IS PROVIDED ""AS IS"" AND ALL IMPLIED           *
      * WARRANTIES, INCLUDING THE IMPLIED WARRANTIES OF               *
      * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,         *
      * SHALL NOT APPLY.                                              *
      * TO THE EXTENT PERMITTED BY LAW, IN NO EVENT WILL              *
      * MICRO FOCUS HAVE ANY LIABILITY WHATSOEVER IN CONNECTION       *
      * WITH THIS SOFTWARE.                                           *
      *                                                               *
      *****************************************************************
      
       copy ""mfunit_prototypes.cpy"".
       
       identification division.
       program-id. TestInterestCalculator as ""TestInterestCalculator"".

       environment division.
       configuration section.

       data division.
       working-storage section.
       copy ""mfunit.cpy"".
       copy ""PROCEDURE-NAMES.cpy"".
       copy ""FUNCTION-CODES.cpy"".
       copy ""HELPER-FUNCTIONS.cpy"".
       copy ""ACCOUNT-RECORD.cpy"" replacing ==(PREFIX)== by ==TEST==.
       copy ""CUSTOMER-RECORD.cpy"" replacing ==(PREFIX)== by ==TEST==.
       copy ""TRANSACTION-RECORD.cpy"" replacing ==(PREFIX)== by ==TEST==.
       copy ""DATE.cpy"" replacing ==(PREFIX)== by ==WS==. 
       01 function-code            ","This COBOL code defines a program called ""TestInterestCalculator"" that likely calculates interest based on provided account, customer, and transaction records. The code includes various copy statements to import external files containing function prototypes, procedure names, function codes, helper functions, account records, customer records, transaction records, and date information. The program appears to be a demonstration for use with Micro Focus software and is subject to Micro Focus's End-User License Agreement.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.00456847385554301,0.8538166880607605
py_256,Python,"def create_bucket(self, bucket_name, region_name=None):
        """"""
        Creates an Amazon S3 bucket.

        :param bucket_name: The name of the bucket
        :type bucket_name: str
        :param region_name: The name of the aws region in which to create the bucket.
        :type region_name: str
        """"""
        s3_conn = self.get_conn()
        if not region_name:
            region_name = s3_conn.meta.region_name
        if region_name == 'us-east-1':
            self.get_conn().create_bucket(Bucket=bucket_name)
        else:
            self.get_conn().create_bucket(Bucket=bucket_name,
                                          CreateBucketConfiguration={
                                              'LocationConstraint': region_name
                                          })","Creates an Amazon S3 bucket in the specified region if provided, otherwise defaults to the region of the current S3 connection. The `bucket_name` parameter specifies the name of the bucket, while the `region_name` parameter (optional) specifies the AWS region where the bucket should be created.","Creates an Amazon S3 bucket.

        :param bucket_name: The name of the bucket
        :type bucket_name: str
        :param region_name: The name of the aws region in which to create the bucket.
        :type region_name: str",No Error,False,The documentation accurately describes the functionality of the code.,0.09687950349392005,0.8403905630111694
cob_syn_3002,COBOL,"      * REFACTOR CANDIDATE BATCH_3002
      * SYSTEM GENERATED
000100 IDENTIFICATION DIVISION.
000110 PROGRAM-ID. PRAC14.
000120 AUTHOR. LUIS CECILIANO.
000130 DATE-WRITTEN. DECEMBER 18, 2019.
000140*ESTE PROGRAMA CARGA VALORES EN RAM EN UNA BASE DE DATOS
000150 SECURITY. FOREVER.
000200 ENVIRONMENT DIVISION.
000300 DATA DIVISION.
       DATA-BASE SECTION.
           DB BD01CURSOS VALUE OF TITLE IS
             ""BD01CURSOS ON CREDITO"".
       WORKING-STORAGE SECTION.
           01 WKS-EOF-LISTA PIC 9(02) VA 0.
           01 WKS-INDICE    PIC 9(02).
           01 WKS-LISTA-CURSOS.
               02 FILLER PIC X(11) VA ""0502CANDE03"".
               02 FILLER PIC X(11) VA ""0202COBOL06"".
               02 FILLER PIC X(11) VA ""0604DMSII02"".
               02 FILLER PIC X(11) VA ""0404DASDL03"".
               02 FILLER PIC X(11) VA ""0301ALGOL21"".
           01 WKS-LISTA-CURSO REDEFINES WKS-LISTA-CURSOS.
               02 WKS-CURSO OCCURS 5 TIMES.
                   03 WKS-CVE-CURSO       PIC 9(04).
                   03 WKS-DESCRIPCION     PIC X(05).
                   03 WKS-HORAS-DEDICADAS PIC 9(02).
       PROCEDURE DIVISION.
       0000-PRINCIPAL.
           PERFORM 1000-INICIO
           PERFORM 2000-PROCESO
           PERFORM 3000-TERMINA
           STOP RUN.
       1000-INICIO.
           OPEN UPDATE BD01CURSOS.
       2000-PROCESO.
           PERFORM 999-DMS-BEGIN-TRANSACTION
           PERFORM 2500-ACTUALIZA-BD02 VARYING WKS-INDICE FROM 1 BY 1
                                               UNTIL WKS-INDICE > 5
           PERFORM 999-DMS-END-TRANSACTION.
       2500-ACTUALIZA-BD02.
           PERFORM 2600-CREA-BD02
           PERFORM 2700-MUEVE-DATOS
           PERFORM 2800-GRABA-BD02.
       2600-CREA-BD02.
           CREATE BD02CURSOS.
       2700-MUEVE-DATOS.
           MOVE WKS-CVE-CURSO       (WKS-INDICE) TO BD02-CVE-CURSO
           MOVE WKS-DESCRIPCION     (WKS-INDICE) TO BD02-DESCRIP
           MOVE WKS-HORAS-DEDICADAS (WKS-INDICE) TO BD02-HORAS-ASIG.
       2800-GRABA-BD","This COBOL program loads values into RAM in a database. It defines data structures for courses and their details, opens a database file, processes data by beginning a transaction, updating database records for each course, and ending the transaction. Note that the code provided is incomplete and lacks the complete implementation of the database update process.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.005514743143838301,0.8636746406555176
cob_syn_7892,COBOL,"      * REFACTOR CANDIDATE BATCH_7892
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. MERGESTMT.
 PROCEDURE DIVISION.
    MERGE SOMEFILE1
       ON DESCENDING KEY SOMEID1
       ON ASCENDING KEY SOMEID2 SOMEID3
       COLLATING SEQUENCE IS SOMEALPHA1 SOMEALPHA2
          FOR ALPHANUMERIC IS SOMEALPHA3
          FOR NATIONAL IS SOMEALPHA4
       USING SOMEFILE2
       OUTPUT PROCEDURE IS SOMEPROC1 THRU SOMEPROC2
       GIVING SOMEFILE3 NO REWIND.","This COBOL program merges records from SOMEFILE2 into SOMEFILE1 based on the ordering of keys SOMEID1, SOMEID2, and SOMEID3. The collating sequence for alphanumeric values is defined by SOMEALPHA1 and SOMEALPHA2, while SOMEALPHA3 is used for alphanumeric comparisons and SOMEALPHA4 for national comparisons. The merged output is directed to SOMEFILE3 without rewinding, and the output procedures are specified from SOMEPROC1 to SOMEPROC2.",Legacy COBOL logic requiring documentation.,Wrong Logic,True,"The documentation claims that the code merges records from SOMEFILE2 into SOMEFILE1, while the code merges SOMEFILE1 using SOMEFILE2.",0.0050615410611162615,0.84073406457901
cob_real_3255,COBOL,"*****************************************************************
*                                                               *
* Frances Coronel                                               *
* COBOL PROGRAM                                                 *
* CSC 308                                                       *
*                                                               *
*****************************************************************
identification division.
program-id. BubbleSort.

environment division.
configuration section.

data division.
working-storage section.
* defining array values
01  arraydata value '34 56 4 10 77 51 93 30 5 52'.
* defining array
   05 array occurs 10 times pic 999.
* defining temp array
05 temp pic 999.
* for printing out array
01  displayarray pic zz9.
01  spacing pic 99 value 1.
* defining i and j for looping
01  i pic 99.
01  j pic 99.
* defining size of array variable
01  sizeof pic 99.


procedure division.
* defining size of array
  divide length of arraydata by length of array giving sizeof.
* unsorted array
  display ""Unsorted Array""
  perform varying i from 1 by 1 until i is greater than sizeof
    move array(i) to displayarray
    display displayarray at line number 1 column spacing
    add 3 to spacing
  end-perform.
* bubble sort
  perform varying i from 1 by 1 until is sizeof add 1
    perform varying j from i add 1 by 1 until is sizeof
      if array(j) is less than array(i) then
        move array(i) to temp
        move array(j) to arr(i)
        move temp to array(j)
      end-if
    end-perform.
  end-perform.
* sorted array
  display ""Sorted Array""
  perform varying i from 1 by 1 until i is greater than sizeof
    move array(i) to displayarray
    display displayarray at line number 1 column spacing
    add 3 to spacing
  end-perform.
* end program
end program BubbleSort.","This COBOL program implements the Bubble Sort algorithm to sort an array of integers in ascending order. It first displays the unsorted array, then performs the Bubble Sort algorithm to rearrange the elements, and finally displays the sorted array. The sorting process involves comparing adjacent elements and swapping them if they are in the wrong order.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation effectively and accurately describes the functionality and logic utilized within the provided COBOL program.,0.005514743143838301,0.8564321994781494
py_9810,Python,"def print_variables(self, context):
        """"""
        Print a set of variables
        """"""
        text = []
        for name, expr in self.variables:
            # Some extended resolving, to handle unknown variables
            data = ''
            try:
                if isinstance(expr.var, Variable):
                    data = expr.var.resolve(context)
                else:
                    data = expr.resolve(context)  # could return TEMPLATE_STRING_IF_INVALID
            except VariableDoesNotExist as e:
                # Failed to resolve, display exception inline
                keys = []
                for scope in context:
                    keys += scope.keys()
                keys = sorted(set(keys))  # Remove duplicates, e.g. csrf_token
                return ERROR_TYPE_BLOCK.format(style=PRE_ALERT_STYLE, error=escape(u""Variable '{0}' not found!  Available context variables are:\n\n{1}"".format(expr, u', '.join(keys))))
            else:
                # Regular format
                textdata = linebreaksbr(pformat_django_context_html(data))

            # At top level, prefix class name if it's a longer result
            if isinstance(data, SHORT_NAME_TYPES):
                text.append(BASIC_TYPE_BLOCK.format(style=PRE_STYLE, name=name, value=textdata))
            else:
                text.append(OBJECT_TYPE_BLOCK.format(style=PRE_STYLE, name=name, type=data.__class__.__name__, value=textdata))
        return u''.join(text)","Print a set of variables, resolve any unknown variables, and return a formatted string displaying the variable names and corresponding values.",Print a set of variables,No Error,False,The documentation is accurate and consistent with the source code's functions and operations.,0.11369306152454814,0.8946977853775024
cob_syn_2855,COBOL,"      * REFACTOR CANDIDATE BATCH_2855
      * SYSTEM GENERATED
000001     >>DEFINE B B'1' OVERRIDE                                     00000001
000002                                                                  00000002
",Defines a symbolic constant B with a value of 1.,Legacy COBOL logic requiring documentation.,No Error,False,The documentation correctly summarizes the code.,0.0,0.8538184762001038
py_3394,Python,"def phids(self, *phids):
        """"""Retrieve data about PHIDs.

        :params phids: list of PHIDs
        """"""
        params = {
            self.PHIDS: phids
        }

        response = self._call(self.PHAB_PHIDS, params)

        return response",Retrieve data about PHIDs.,"Retrieve data about PHIDs.

        :params phids: list of PHIDs",No Error,False,The generated documentation accurately describes the function of the code.,0.2865047968601901,0.870424747467041
cob_syn_9892,COBOL,"      * REFACTOR CANDIDATE BATCH_9892
      * SYSTEM GENERATED
      ******************************************************************
      *                                                                *
      * LICENSED MATERIALS - PROPERTY OF IBM                           *
      *                                                                *
      * ""RESTRICTED MATERIALS OF IBM""                                  *
      *                                                                *
      * CB12                                                           *
      *                                                                *
      * (C) COPYRIGHT IBM CORP. 2011, 2013 ALL RIGHTS RESERVED         *
      *                                                                *
      * US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION,      *
      * OR DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE                   *
      * CONTRACT WITH IBM CORPORATION                                  *
      *                                                                *
      *                                                                *
      *                    Inquire Policy                              *
      *                                                                *
      * This program will return a random Policy/customer number from  *
      *  the VSAM KSDS Policy file. Input parm of policy type will     *
      *  determine the key                                             *
      *                                                                *
      ******************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LGIPVS01.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
      *
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       01  WS-FLAG-TSQE              PIC X.
       01  WS-FLAG-TSQH              PIC X.
       01  WS-FLAG-TSQL              PIC X.
       01  WS-FLAG                   PIC X.
       01  WS-RANDOM-Seed          ",This COBOL program is a batch job named LGIPVS01 that retrieves a random Policy/customer number from a VSAM KSDS Policy file based on an input parameter specifying the policy type as the key. The program appears to be proprietary IBM material and is designed to return randomized data from the specified file.,Legacy COBOL logic requiring documentation.,Omission,True,The documentation doesn't mention or explain the listed working-storage section variables in the code.,0.005869389976559867,0.8574841022491455
py_4400,Python,"def _onIncomingMessageReceived(self, conn, message):
        """"""
        Callback for initial messages on incoming connections. Handles encryption, utility messages, and association of the connection with a Node.
        Once this initial setup is done, the relevant connected callback is executed, and further messages are deferred to the onMessageReceived callback.

        :param conn: connection object
        :type conn: TcpConnection
        :param message: received message
        :type message: any
        """"""

        if self._syncObj.encryptor and not conn.sendRandKey:
            conn.sendRandKey = message
            conn.recvRandKey = os.urandom(32)
            conn.send(conn.recvRandKey)
            return

        # Utility messages
        if isinstance(message, list):
            done = False
            try:
                if message[0] == 'status':
                    conn.send(self._syncObj.getStatus())
                    done = True
                elif message[0] == 'add':
                    self._syncObj.addNodeToCluster(message[1], callback = functools.partial(self._utilityCallback, conn = conn, cmd = 'ADD', arg = message[1]))
                    done = True
                elif message[0] == 'remove':
                    if message[1] == self._selfNode.address:
                        conn.send('FAIL REMOVE ' + message[1])
                    else:
                        self._syncObj.removeNodeFromCluster(message[1], callback = functools.partial(self._utilityCallback, conn = conn, cmd = 'REMOVE', arg = message[1]))
                    done = True
                elif message[0] == 'set_version':
                    self._syncObj.setCodeVersion(message[1], callback = functools.partial(self._utilityCallback, conn = conn, cmd = 'SET_VERSION', arg = str(message[1])))
                    done = True
            except Exception as e:
                conn.send(str(e))
                done = True
            if done:
                return

        # At this point, message should be either a node ID (i.e. address) or 'readonly'
        node = self._nodeAddrToNode[message] if message in self._nodeAddrToNode else None

        if node is None and message != 'readonly':
            conn.disconnect()
            self._unknownConnections.discard(conn)
            return

        readonly = node is None
        if readonly:
            nodeId = str(self._readonlyNodesCounter)
            node = Node(nodeId)
            self._readonlyNodes.add(node)
            self._readonlyNodesCounter += 1

        self._unknownConnections.discard(conn)
        self._connections[node] = conn
        conn.setOnMessageReceivedCallback(functools.partial(self._onMessageReceived, node))
        if not readonly:
            self._onNodeConnected(node)
        else:
            self._onReadonlyNodeConnected(node)","Callback for initial messages on incoming connections. Handles encryption, utility messages, and association of the connection with a Node. Once this initial setup is done, the relevant connected callback is executed, and further messages are deferred to the onMessageReceived callback.

:param conn: connection object
:type conn: TcpConnection
:param message: received message
:type message: any","Callback for initial messages on incoming connections. Handles encryption, utility messages, and association of the connection with a Node.
        Once this initial setup is done, the relevant connected callback is executed, and further messages are deferred to the onMessageReceived callback.

        :param conn: connection object
        :type conn: TcpConnection
        :param message: received message
        :type message: any",No Error,False,The documentation accurately represents the code's functionality and parameters.,1.0,0.9143921732902527
py_8666,Python,"def add_to_parser(self, parser):
        """"""
        Adds the argument to an argparse.ArgumentParser instance

        @param parser An argparse.ArgumentParser instance
        """"""
        kwargs = self._get_kwargs()
        args = self._get_args()
        parser.add_argument(*args, **kwargs)",Adds the argument to an argparse.ArgumentParser instance.,"Adds the argument to an argparse.ArgumentParser instance

        @param parser An argparse.ArgumentParser instance",Omission,True,The documentation does not mention the usage of two internal methods _get_kwargs() and _get_args() to collect arguments for the argument parser.,0.3960914423407551,0.9125388264656067
py_3782,Python,"def display_reports(self, layout):
        """"""display results encapsulated in the layout tree""""""
        self.section = 0
        if hasattr(layout, ""report_id""):
            layout.children[0].children[0].data += "" (%s)"" % layout.report_id
        self._display(layout)","Display reports encapsulated in the layout tree by adding a report ID to the first child's data if the layout object has a report_id attribute, then call the _display method with the provided layout.",display results encapsulated in the layout tree,No Error,False,The documentation successfully reflects what is in the code.,0.1018988257220787,0.8852422833442688
cob_syn_10272,COBOL,"      * REFACTOR CANDIDATE BATCH_10272
      * SYSTEM GENERATED
       identification division.
       program-id. string_handling_01.

       data division.
       working-storage section.
       01 ws-cnt1 pic 9(2) value 0.
       01 ws-cnt2 pic 9(2) value 0.
       01 ws-string pic x(15) value 'abcdacdadeaaaff'.

       procedure division.
           inspect ws-string tallying ws-cnt1 for all characters.
           display 'ws-cnt1 : ' ws-cnt1.
           inspect ws-string tallying ws-cnt2 for all 'a'.
           display 'ws-cnt2 : ' ws-cnt2.
","This COBOL program defines three variables: ws-cnt1, ws-cnt2, and ws-string. It then uses the INSPECT statement to count the total number of characters in ws-string and stores the result in ws-cnt1. Next, it counts the occurrences of the character 'a' in ws-string and stores the result in ws-cnt2. Finally, it displays the values of ws-cnt1 and ws-cnt2.",Legacy COBOL logic requiring documentation.,API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.005433186420677938,0.8323360681533813
py_3507,Python,"def list_buckets(self):
    '''List all buckets'''
    result = []
    for bucket in self.s3.list_buckets().get('Buckets') or []:
      result.append({
          'name': S3URL.combine('s3', bucket['Name'], ''),
          'is_dir': True,
          'size': 0,
          'last_modified': bucket['CreationDate']
        })
    return result","Return a list of dictionaries representing all buckets by combining information such as bucket name, if it is a directory, size, and last modified date.",List all buckets,No Error,False,The documentation accurately represents the functionality of the listed source code.,0.02417000107767621,0.8445127010345459
cob_syn_5445,COBOL,"      * REFACTOR CANDIDATE BATCH_5445
      * SYSTEM GENERATED
 IDENTIFICATION DIVISION.
 PROGRAM-ID. CONDTN.
 PROCEDURE DIVISION.
    IF NOT SOME-COND (SOME-INDEX
                    ,SOME-MONTH)
       STOP RUN
    END-IF.
","This COBOL program checks if a condition is not met for a given index and month. If the condition is not met, the program stops running. This code is a refactored batch process named CONDTN.",Legacy COBOL logic requiring documentation.,No Error,False,The documentation accurately reflects the logic and behavior of the provided COBOL source code.,0.008176856499690712,0.8665267825126648
py_5093,Python,"def _generate_checksum(self):
        # type: () -> AddressChecksum
        """"""
        Generates the correct checksum for this address.
        """"""
        checksum_trits = []  # type: MutableSequence[int]

        sponge = Kerl()
        sponge.absorb(self.address.as_trits())
        sponge.squeeze(checksum_trits)

        checksum_length = AddressChecksum.LEN * TRITS_PER_TRYTE

        return AddressChecksum.from_trits(checksum_trits[-checksum_length:])",Generates the correct checksum for a given address by using Kerl sponge function to calculate the checksum trits based on the input address trits. The function then formats and returns the checksum as an AddressChecksum object.,Generates the correct checksum for this address.,No Error,False,The documentation correctly describes what the code does.,0.09598524129805773,0.8872693777084351
py_8924,Python,"def _get_basilisp_bytecode(
    fullname: str, mtime: int, source_size: int, cache_data: bytes
) -> List[types.CodeType]:
    """"""Unmarshal the bytes from a Basilisp bytecode cache file, validating the
    file header prior to returning. If the file header does not match, throw
    an exception.""""""
    exc_details = {""name"": fullname}
    magic = cache_data[:4]
    raw_timestamp = cache_data[4:8]
    raw_size = cache_data[8:12]
    if magic != MAGIC_NUMBER:
        message = (
            f""Incorrect magic number ({magic}) in {fullname}; expected {MAGIC_NUMBER}""
        )
        logger.debug(message)
        raise ImportError(message, **exc_details)  # type: ignore
    elif len(raw_timestamp) != 4:
        message = f""Reached EOF while reading timestamp in {fullname}""
        logger.debug(message)
        raise EOFError(message)
    elif _r_long(raw_timestamp) != mtime:
        message = f""Non-matching timestamp ({_r_long(raw_timestamp)}) in {fullname} bytecode cache; expected {mtime}""
        logger.debug(message)
        raise ImportError(message, **exc_details)  # type: ignore
    elif len(raw_size) != 4:
        message = f""Reached EOF while reading size of source in {fullname}""
        logger.debug(message)
        raise EOFError(message)
    elif _r_long(raw_size) != source_size:
        message = f""Non-matching filesize ({_r_long(raw_size)}) in {fullname} bytecode cache; expected {source_size}""
        logger.debug(message)
        raise ImportError(message, **exc_details)  # type: ignore

    return marshal.loads(cache_data[12:])","Unmarshal the bytes from a Basilisp bytecode cache file, validating the file header prior to returning. If the file header does not match, throw an exception.","Unmarshal the bytes from a Basilisp bytecode cache file, validating the
    file header prior to returning. If the file header does not match, throw
    an exception.",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,1.0,0.9470817446708679
py_9232,Python,"def load(self):
        """"""Load the projects config data from local path

        Returns:
            Dict: project_name -> project_data
        """"""
        projects = {}

        path = os.path.expanduser(self.path)

        if not os.path.isdir(path):
            return projects

        logger.debug(""Load project configs from %s"", path)

        for filename in os.listdir(path):
            filename_parts = os.path.splitext(filename)

            if filename_parts[1][1:] != PROJECT_CONFIG_EXTENSION:
                continue
            name = filename_parts[0]

            try:
                project_file_path = os.path.join(path, filename)
                with open(project_file_path) as f:
                    data = yaml.load(f)
                projects[name] = data
            except ValueError:
                continue

            logger.debug(""Project '{}' config readed from {}"".format(name, project_file_path))

        return projects",Load the projects config data from a local path and return a dictionary containing project names as keys and project data as values.,"Load the projects config data from local path

        Returns:
            Dict: project_name -> project_data",No Error,False,The documentation accurately describes the functionality of the source code.,0.22816849039973935,0.8371551632881165
cob_syn_937,COBOL,"      * REFACTOR CANDIDATE BATCH_937
      * SYSTEM GENERATED
           select pd01000 assign to disk wid-pd01000
                organization        is indexed
                access mode         is dynamic
                record key          is f01000-chave = 
                                       f01000-cd-empresa                
                                       f01000-cd-filial
                                       f01000-cd-perfil
                lock mode           is manual
                file status         is ws-resultado-acesso.
","This COBOL code defines a file named pd01000 to be accessed on disk with indexed organization, dynamic access mode, and manual lock mode. The record key is a composite key consisting of three fields: f01000-chave, f01000-cd-empresa, f01000-cd-filial, and f01000-cd-perfil. File status is stored in the variable ws-resultado-acesso.",Legacy COBOL logic requiring documentation.,No Error,False,"The documentation correctly explains the source code, without any hallucinations or omissions.",0.006389329974674238,0.8340812921524048
py_6901,Python,"def generate_tag(key, value=None):
    """"""Generate a tag for use with the tag backends.

    The key and value (if there is one) are sanitized according to the
    following rules:

    1. after the first character, all characters must be alphanumeric,
       underscore, minus, period, or slash--invalid characters are converted
       to ""_""
    2. lowercase

    If a value is provided, the final tag is `key:value`.

    The final tag must start with a letter. If it doesn't, an ""a"" is prepended.

    The final tag is truncated to 200 characters.

    If the final tag is ""device"", ""host"", or ""source"", then a ""_"" will be
    appended the end.

    :arg str key: the key to use
    :arg str value: the value (if any)

    :returns: the final tag

    Examples:

    >>> generate_tag('yellow')
    'yellow'
    >>> generate_tag('rule', 'is_yellow')
    'rule:is_yellow'

    Example with ``incr``:

    >>> import markus
    >>> mymetrics = markus.get_metrics(__name__)

    >>> mymetrics.incr('somekey', value=1,
    ...                tags=[generate_tag('rule', 'is_yellow')])

    """"""
    # Verify the types
    if not isinstance(key, six.string_types):
        raise ValueError('key must be a string type, but got %r instead' % key)

    if not isinstance(value, six.string_types + (NONE_TYPE,)):
        raise ValueError('value must be None or a string type, but got %r instead' % value)

    # Sanitize the key
    key = BAD_TAG_CHAR_REGEXP.sub('_', key).strip()

    # Build the tag
    if value is None or not value.strip():
        tag = key
    else:
        value = BAD_TAG_CHAR_REGEXP.sub('_', value).strip()
        tag = '%s:%s' % (key, value)

    if tag and not tag[0].isalpha():
        tag = 'a' + tag

    # Lowercase and truncate
    tag = tag.lower()[:200]

    # Add _ if it's a reserved word
    if tag in ['device', 'host', 'source']:
        tag = tag + '_'

    return tag","""""""Generate a tag for use with tag backends by sanitizing the key and value according to specific rules. The final tag is created as `key:value` if a value is provided, starting with a letter and truncated to 200 characters. Certain reserved words like ""device"", ""host"", or ""source"" have ""_"" appended at the end. Exceptions are raised if key or value do not match expected types. """"""","Generate a tag for use with the tag backends.

    The key and value (if there is one) are sanitized according to the
    following rules:

    1. after the first character, all characters must be alphanumeric,
       underscore, minus, period, or slash--invalid characters are converted
       to ""_""
    2. lowercase

    If a value is provided, the final tag is `key:value`.

    The final tag must start with a letter. If it doesn't, an ""a"" is prepended.

    The final tag is truncated to 200 characters.

    If the final tag is ""device"", ""host"", or ""source"", then a ""_"" will be
    appended the end.

    :arg str key: the key to use
    :arg str value: the value (if any)

    :returns: the final tag

    Examples:

    >>> generate_tag('yellow')
    'yellow'
    >>> generate_tag('rule', 'is_yellow')
    'rule:is_yellow'

    Example with ``incr``:

    >>> import markus
    >>> mymetrics = markus.get_metrics(__name__)

    >>> mymetrics.incr('somekey', value=1,
    ...                tags=[generate_tag('rule', 'is_yellow')])",API Error,False,Rate limit exceeded. Please add your openai key to the header 'provider-key' for unlimited access,0.07489031800559413,0.8317549228668213
